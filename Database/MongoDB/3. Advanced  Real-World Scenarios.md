## ‚öôÔ∏è **1. What is Sharding in MongoDB? Why is it needed?**

**Answer:**
**Sharding** is the process of **splitting large datasets across multiple servers (shards)** to achieve **horizontal scalability**.

When your data grows beyond the capacity of a single server (CPU, RAM, or storage), you distribute data across multiple machines.

**Key Components:**

* **Shard:** Actual data storage unit.
* **Config Server:** Stores metadata about shards and cluster.
* **Mongos:** Query router that directs requests to the correct shard.

**Example:**

```bash
// Shard key (partition field)
db.orders.createIndex({ customer_id: 1 })
sh.shardCollection("shop.orders", { customer_id: 1 })
```

‚úÖ **When needed:**

* Huge datasets (TBs)
* High write throughput
* Need for scalability

---

## üîÅ **2. What is Replication, and how does MongoDB achieve high availability?**

**Answer:**
**Replication** is the process of maintaining **identical data copies on multiple servers** to ensure **fault tolerance and high availability**.

### Components:

* **Primary:** Receives all write operations.
* **Secondary:** Copies data from primary asynchronously.
* **Arbiter (optional):** Helps elect a new primary if needed.

**Example:**

```bash
rs.initiate({
  _id: "rs0",
  members: [
    { _id: 0, host: "mongo1:27017" },
    { _id: 1, host: "mongo2:27017" },
    { _id: 2, host: "mongo3:27017", arbiterOnly: true }
  ]
})
```

‚úÖ **Benefits:**

* Automatic failover.
* Data redundancy.
* Backup and disaster recovery.

---

## ‚ö†Ô∏è **3. What happens when the primary node goes down?**

**Answer:**

1. The replica set detects that the primary is unavailable.
2. The **secondaries hold an election**.
3. A new primary is chosen automatically (within seconds).
4. Client drivers automatically reconnect to the new primary.

**Example:**

* Primary ‚Üí Down
* Secondary ‚Üí Elected as new primary
* Writes continue on new primary

‚úÖ This ensures **zero downtime** and **high availability**.

---

## üßÆ **4. How do Write Concern and Read Concern work?**

**Answer:**
These control **data durability** and **consistency** in MongoDB.

### üìù **Write Concern**

Specifies the level of acknowledgment requested from MongoDB when writing data.

| Level        | Description                                     |
| ------------ | ----------------------------------------------- |
| `w:1`        | Acknowledged by primary (default)               |
| `w:majority` | Acknowledged by majority of replica set members |
| `w:0`        | Unacknowledged (fast, risky)                    |

**Example:**

```js
db.orders.insertOne({ item: "Phone" }, { writeConcern: { w: "majority" } })
```

---

### üîç **Read Concern**

Specifies the level of isolation for read operations.

| Level          | Description                           |
| -------------- | ------------------------------------- |
| `local`        | Returns data from the local instance  |
| `majority`     | Returns data acknowledged by majority |
| `linearizable` | Ensures strict consistency            |

**Example:**

```js
db.orders.find({}, { readConcern: { level: "majority" } })
```

‚úÖ Ensures **strong consistency** in distributed setups.

---

## üîó **5. How do you ensure data consistency in distributed MongoDB setups?**

**Answer:**
To maintain **data consistency** across shards or replicas:

‚úÖ Use:

* **Write concern = "majority"** ‚Üí confirms writes across nodes.
* **Read concern = "majority"** ‚Üí ensures reads from up-to-date data.
* **Transactions** ‚Üí for multi-document consistency.
* **Versioning fields** or timestamps for conflict resolution.
* **Proper shard keys** to prevent uneven data distribution.

**Example:**

```js
session.startTransaction();
db.orders.insertOne({ order_id: 1001, amount: 500 });
db.payments.insertOne({ order_id: 1001, status: "paid" });
session.commitTransaction();
```

---

## üí≥ **6. What are Transactions in MongoDB? When would you use them?**

**Answer:**
A **transaction** allows **multiple operations on multiple documents (even across collections)** to be executed **atomically** ‚Äî either all succeed or all fail.

**Example:**

```js
const session = db.getMongo().startSession();
session.startTransaction();

try {
  session.getDatabase("shop").orders.insertOne({ order_id: 1, item: "Laptop" });
  session.getDatabase("shop").payments.insertOne({ order_id: 1, status: "paid" });
  session.commitTransaction();
} catch (error) {
  session.abortTransaction();
}
session.endSession();
```

‚úÖ **When to use:**

* Financial operations (debit + credit)
* Inventory updates
* Multi-document consistency requirements

---

## üöÄ **7. How can you improve query performance in MongoDB?**

**Answer:**

1. **Use Indexes:**

   ```js
   db.users.createIndex({ email: 1 })
   ```
2. **Use Projection** (return only required fields):

   ```js
   db.users.find({}, { name: 1, email: 1 })
   ```
3. **Avoid $where** and complex JS expressions.
4. **Use Aggregation carefully** (filter early with `$match`).
5. **Monitor queries using explain():**

   ```js
   db.orders.find({ customer_id: 10 }).explain("executionStats")
   ```
6. **Shard data** for scalability.
7. **Avoid large documents** (>16MB).
8. **Cache frequent queries** in the application layer.

---

## üìä **8. How do you handle large datasets or pagination efficiently?**

**Answer:**
MongoDB offers multiple strategies for **efficient pagination**:

### (a) Using `skip()` and `limit()` (basic)

```js
db.products.find().skip(20).limit(10)
```

‚ö†Ô∏è Not efficient for large offsets (MongoDB still scans skipped docs).

---

### (b) Using Range-based Pagination (Recommended)

```js
db.products.find({ _id: { $gt: last_seen_id } }).limit(10)
```

‚úÖ Faster because it uses an **index** on `_id` or another field.

---

### (c) Using Aggregation with `$facet`

```js
db.products.aggregate([
  { $sort: { _id: 1 } },
  { $facet: {
      data: [{ $skip: 20 }, { $limit: 10 }],
      totalCount: [{ $count: "count" }]
  }}
])
```

---

## ‚òÅÔ∏è **9. How can you use MongoDB Atlas for deployment and monitoring?**

**Answer:**
**MongoDB Atlas** is a **cloud-based managed MongoDB service** that simplifies:

* Deployment
* Scaling
* Backups
* Security
* Monitoring

**Features:**
‚úÖ One-click cluster setup
‚úÖ Real-time performance metrics
‚úÖ Automated backups & alerts
‚úÖ Integrated sharding and replication
‚úÖ Role-based access and network isolation

**Example use:**

* Host production cluster on Atlas.
* Monitor slow queries and CPU usage from the Atlas dashboard.
* Enable auto-scaling when traffic spikes.

---

## üö´ **10. Explain a scenario where MongoDB is *not* a good fit.**

**Answer:**
MongoDB may not be ideal when:

1. **Strong ACID transactions** across many entities are required (e.g., banking systems with strict consistency).
2. **Complex multi-table joins** are essential.
3. **Data integrity** is tightly coupled and cannot tolerate schema changes.
4. **Small, fixed-schema datasets** (SQL performs better).
5. When **frequent updates to deeply nested fields** are needed ‚Äî may cause document rewrites.

**Example:**
A financial application needing consistent debit-credit operations across 10+ tables ‚Üí better with PostgreSQL or MySQL.

---

‚úÖ **Summary for Quick Recall:**

| Topic             | Key Idea                                  |
| ----------------- | ----------------------------------------- |
| **Sharding**      | Split data across servers for scalability |
| **Replication**   | Copies data for availability              |
| **Failover**      | Automatic election of new primary         |
| **Write Concern** | Acknowledgment of writes                  |
| **Read Concern**  | Level of data consistency when reading    |
| **Transactions**  | Multi-document atomic operations          |
| **Performance**   | Indexes, projection, explain()            |
| **Pagination**    | Use range queries for speed               |
| **MongoDB Atlas** | Cloud-managed MongoDB                     |
| **Not good fit**  | Heavy ACID or multi-join systems          |
