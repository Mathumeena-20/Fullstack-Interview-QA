## 🧩 **1. Difference between MongoDB and SQL joins**

### 💬 Explanation:

MongoDB is **NoSQL** (document-based), whereas SQL uses **table-based relational joins**.

| Feature        | SQL (Relational)                      | MongoDB (NoSQL)                   |
| -------------- | ------------------------------------- | --------------------------------- |
| Data Structure | Tables (rows, columns)                | Collections (documents)           |
| Join Operation | `JOIN` keyword                        | `$lookup` stage in aggregation    |
| Relation Type  | Normalized (foreign keys)             | Denormalized (embedded documents) |
| Query Example  | `SELECT * FROM orders JOIN customers` | Use `$lookup`                     |

### ✅ Example (MongoDB `$lookup`):

```js
db.orders.aggregate([
  {
    $lookup: {
      from: "customers",
      localField: "customer_id",
      foreignField: "_id",
      as: "customer_info"
    }
  }
])
```

💡 **In short:**
SQL joins are explicit relationships between tables;
MongoDB `$lookup` *emulates* joins between collections.

---

## 🧱 **2. How do you handle schema migrations in MongoDB?**

### 💬 Explanation:

MongoDB is **schema-less**, but schema migrations are still needed when you change field structures.

### 🧠 Common Approaches:

1. **Application-level migration (scripts)**
   Use Node.js/Python scripts to update old documents.

   ```js
   db.users.updateMany({}, { $set: { isActive: true } })
   ```
2. **Migration tools:**

   * `migrate-mongo` (Node.js)
   * `MongoBee` (Java)
3. **Versioned schema** – Add a field like `schemaVersion` to track data model changes.

💡 **Example:**
When adding a new field `email_verified`, you can backfill:

```js
db.users.updateMany({ email_verified: { $exists: false } }, { $set: { email_verified: false } })
```

---

## 🧾 **3. How do you perform data validation in MongoDB?**

### 💬 Explanation:

MongoDB (v3.2+) supports **schema validation** at the collection level using **JSON Schema**.

### ✅ Example:

```js
db.createCollection("employees", {
  validator: {
    $jsonSchema: {
      bsonType: "object",
      required: ["name", "age", "department"],
      properties: {
        name: { bsonType: "string" },
        age: { bsonType: "int", minimum: 18 },
        department: { bsonType: "string" }
      }
    }
  }
})
```

* If someone inserts `{ name: 123 }`, MongoDB will reject it ❌

💡 **Used for:**
Maintaining data integrity (similar to constraints in SQL).

---

## 📊 **4. What are the advantages of the Aggregation Framework?**

### 💬 Explanation:

Aggregation Framework = MongoDB’s **data processing pipeline** (like SQL’s `GROUP BY`, `SUM`, etc.)

### ✅ Advantages:

1. **Powerful analytics** – filtering, grouping, sorting, projections.
2. **Efficient** – processed inside MongoDB engine (no app-side computation).
3. **Multi-stage pipelines** (`$match`, `$group`, `$sort`, `$project`, `$lookup` etc.)
4. **Supports large data sets** – handles millions of documents efficiently.

### 🧠 Example:

Get total sales by department:

```js
db.sales.aggregate([
  { $group: { _id: "$department", totalSales: { $sum: "$amount" } } }
])
```

---

## 🆔 **5. Explain ObjectId structure (timestamp, machine id, process id, counter)**

### 💬 Explanation:

Every MongoDB document has a unique `_id` (default: ObjectId).

### Structure (12 bytes total):

| Part       | Size    | Description                               |
| ---------- | ------- | ----------------------------------------- |
| Timestamp  | 4 bytes | Creation time (seconds since epoch)       |
| Machine ID | 3 bytes | Unique machine identifier                 |
| Process ID | 2 bytes | Process that created the ObjectId         |
| Counter    | 3 bytes | Incrementing counter (ensures uniqueness) |

### ✅ Example:

```js
ObjectId("64b1f8e6a79a5e62f4a9a3d2")
```

You can extract time:

```js
ObjectId("64b1f8e6a79a5e62f4a9a3d2").getTimestamp()
```

📤 Output → `ISODate("2025-10-31T10:45:26Z")`

💡 **Used for:** Sorting documents by insertion time without extra “created_at” field.

---

## 🔍 **6. Difference between findOne() and find()**

| Feature     | findOne()                           | find()                           |
| ----------- | ----------------------------------- | -------------------------------- |
| Returns     | Single document                     | Cursor (multiple docs)           |
| Output      | Object                              | Cursor/Array                     |
| Performance | Slightly faster                     | Iterates through collection      |
| Example     | `db.users.findOne({name: "Alice"})` | `db.users.find({city: "Delhi"})` |

### ✅ Example:

```js
db.users.findOne({ age: { $gt: 30 } }) // returns one user
db.users.find({ age: { $gt: 30 } })   // returns all matching users
```

💡 **Tip:** Use `findOne()` when you expect only one result — it saves memory.

---

## 💾 **7. How do you backup and restore MongoDB databases?**

### 💬 Explanation:

MongoDB provides utilities:

* `mongodump` → create backup
* `mongorestore` → restore backup

### ✅ Example Commands:

**Backup:**

```bash
mongodump --db mydatabase --out /backups/mybackup
```

**Restore:**

```bash
mongorestore --db mydatabase /backups/mybackup/mydatabase
```

💡 **Used for:**
Disaster recovery, migrations, environment transfers.

---

## ⚙️ **8. How does MongoDB handle concurrency?**

### 💬 Explanation:

MongoDB uses **multi-granularity locking** and **WiredTiger engine** for concurrency control.

### 🧠 Mechanisms:

1. **Document-level locking** – allows multiple writes in different documents of same collection concurrently.
2. **Readers–writers lock** – multiple readers allowed; writers get exclusive access.
3. **Write concern** – ensures data durability and acknowledgment.
4. **Transactions** – maintain consistency across multiple operations.

### ✅ Example:

Two users updating different documents in same collection:

```js
db.accounts.updateOne({ _id: 1 }, { $inc: { balance: -100 } })
db.accounts.updateOne({ _id: 2 }, { $inc: { balance: +100 } })
```

✅ Both succeed concurrently because MongoDB locks only document level, not the entire collection.

💡 **Advantage:** High throughput and minimal contention in large-scale systems.

---

## 🧾 **Summary Table**

| Topic                  | Key Concept                           | Example / Tool          |
| ---------------------- | ------------------------------------- | ----------------------- |
| MongoDB vs SQL Join    | `$lookup` simulates SQL JOIN          | `$lookup`               |
| Schema Migration       | Scripts or tools like `migrate-mongo` | `updateMany()`          |
| Data Validation        | `$jsonSchema`                         | `db.createCollection()` |
| Aggregation Advantages | Grouping, filtering, analytics        | `$group`, `$match`      |
| ObjectId Structure     | Timestamp + Machine + PID + Counter   | `getTimestamp()`        |
| findOne vs find        | Single doc vs Cursor                  | `db.users.findOne()`    |
| Backup & Restore       | `mongodump` / `mongorestore`          | CLI tools               |
| Concurrency            | Document-level locks                  | WiredTiger engine       |

