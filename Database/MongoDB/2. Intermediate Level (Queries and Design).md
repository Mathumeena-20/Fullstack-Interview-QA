## üß© **1. Difference between Embedded Documents and References**

**Answer:**
MongoDB supports two ways to model relationships between data:

1. **Embedded Documents** ‚Äî store related data *inside* a single document.
2. **References** ‚Äî store related data in *separate collections* and link them using an ID.

### üß± Embedded Documents (Denormalized)

**Example:**

```js
{
  name: "John",
  department: "IT",
  address: { city: "Bangalore", pincode: 560001 }
}
```

‚úÖ **Use when:**

* Data is frequently read together.
* The related data is small and won‚Äôt grow indefinitely.

---

### üîó References (Normalized)

**Example:**

```js
// users collection
{ _id: 1, name: "John" }

// addresses collection
{ user_id: 1, city: "Bangalore", pincode: 560001 }
```

‚úÖ **Use when:**

* Data is large or reused across multiple documents.
* You want to avoid duplication (like ‚Äúone-to-many‚Äù relations).

---

## ‚öôÔ∏è **2. Difference between `$set`, `$push`, `$inc`, and `$addToSet`**

| Operator    | Description                                     | Example                             |
| ----------- | ----------------------------------------------- | ----------------------------------- |
| `$set`      | Updates a field value                           | `{$set: { age: 30 }}`               |
| `$inc`      | Increments a numeric value                      | `{$inc: { salary: 1000 }}`          |
| `$push`     | Adds a value to an array                        | `{$push: { skills: "MongoDB" }}`    |
| `$addToSet` | Adds a value to an array **only if not exists** | `{$addToSet: { skills: "Python" }}` |

**Example:**

```js
db.employees.updateOne(
  { name: "John" },
  {
    $set: { department: "IT" },
    $inc: { salary: 5000 },
    $push: { skills: "MongoDB" },
    $addToSet: { skills: "Python" }
  }
)
```

---

## üî¢ **3. How to sort, limit, and skip results in MongoDB**

**Answer:**
MongoDB provides methods for **pagination and ordering** results.

**Example:**

```js
// Sort by salary descending
db.employees.find().sort({ salary: -1 })

// Limit results to 5
db.employees.find().limit(5)

// Skip first 10 results (used in pagination)
db.employees.find().skip(10)

// Combine
db.employees.find().sort({ salary: -1 }).skip(10).limit(5)
```

‚úÖ Useful for implementing **page-wise data fetching**.

---

## üîÑ **4. What are Aggregation Pipelines?**

**Answer:**
The **aggregation pipeline** processes documents in **stages**, transforming and combining data to produce meaningful results (like SQL‚Äôs `GROUP BY`, `JOIN`, etc.).

### Common Stages:

| Stage      | Purpose                            |
| ---------- | ---------------------------------- |
| `$match`   | Filters documents (like WHERE)     |
| `$group`   | Groups documents (like GROUP BY)   |
| `$sort`    | Sorts documents                    |
| `$project` | Selects or reshapes fields         |
| `$lookup`  | Performs joins between collections |

**Example:**
Find total salary per department:

```js
db.employees.aggregate([
  { $match: { department: { $ne: null } } },
  { $group: { _id: "$department", totalSalary: { $sum: "$salary" } } },
  { $sort: { totalSalary: -1 } },
  { $project: { _id: 0, department: "$_id", totalSalary: 1 } }
])
```

‚úÖ Output:

```js
{ "department": "IT", "totalSalary": 120000 }
{ "department": "HR", "totalSalary": 80000 }
```

---

## üîó **5. How do you perform a JOIN operation in MongoDB?**

**Answer:**
MongoDB doesn‚Äôt have SQL joins, but you can use **`$lookup`** in aggregation to join two collections.

**Example:**

```js
// orders collection
{ _id: 1, customer_id: 101, total: 500 }

// customers collection
{ _id: 101, name: "Alice" }

db.orders.aggregate([
  {
    $lookup: {
      from: "customers",
      localField: "customer_id",
      foreignField: "_id",
      as: "customer_info"
    }
  }
])
```

‚úÖ Output:

```js
{
  _id: 1,
  customer_id: 101,
  total: 500,
  customer_info: [{ _id: 101, name: "Alice" }]
}
```

---

## üîç **6. How can you perform text search or pattern matching in MongoDB?**

**Answer:**

### (a) **Text Search**

Create a **text index** and use `$text` operator.

**Example:**

```js
db.articles.createIndex({ content: "text" })
db.articles.find({ $text: { $search: "mongodb performance" } })
```

‚úÖ Finds documents containing ‚Äúmongodb‚Äù or ‚Äúperformance‚Äù.

---

### (b) **Pattern Matching (Regex)**

Use **regular expressions** for partial or case-insensitive matching.

```js
db.users.find({ name: { $regex: "^A", $options: "i" } })
```

‚úÖ Finds names starting with ‚ÄúA‚Äù or ‚Äúa‚Äù.

---

## ‚öôÔ∏è **7. How can you find all documents where a specific field exists or doesn‚Äôt exist?**

**Answer:**
Use the `$exists` operator.

**Example:**

```js
// Documents with 'email' field
db.users.find({ email: { $exists: true } })

// Documents without 'email' field
db.users.find({ email: { $exists: false } })
```

---

## üß± **8. Explain Schema Design Best Practices in MongoDB**

**Answer:**
MongoDB is **schema-less**, but good design is still crucial.

### ‚úÖ Best Practices:

1. **Embed** data that is read together.
   ‚Üí e.g., Order + OrderItems
2. **Reference** data that is reused or large.
   ‚Üí e.g., User info referenced by many orders.
3. **Avoid deep nesting** (>2 levels).
4. **Precompute data** (denormalize) for performance.
5. Use **indexes** on frequently queried fields.
6. Store **timestamps** for tracking.
7. Avoid **large arrays** ‚Äî use pagination instead.

---

## üì¶ **9. What are Capped Collections?**

**Answer:**
A **capped collection** is a **fixed-size collection** that automatically overwrites the oldest documents when the size limit is reached.

**Example:**

```js
db.createCollection("logs", { capped: true, size: 10000 })
```

‚úÖ Best used for:

* Logs
* Caching
* Temporary data

**Properties:**

* Insertion order preserved.
* No document deletion allowed (except auto overwrite).

---

## üîç **10. What is the difference between `find()` and `aggregate()`?**

| Feature     | `find()`                      | `aggregate()`                             |
| ----------- | ----------------------------- | ----------------------------------------- |
| Purpose     | Simple queries                | Complex data transformations              |
| Operations  | Filters, projections, sorting | Grouping, joining, calculations           |
| Performance | Faster (less overhead)        | Slower but more powerful                  |
| Syntax      | `.find({ age: { $gt: 25 } })` | `$match`, `$group`, `$project`, `$lookup` |

**Example:**

```js
// find()
db.employees.find({ department: "IT" })

// aggregate()
db.employees.aggregate([
  { $match: { department: "IT" } },
  { $group: { _id: "$department", avgSalary: { $avg: "$salary" } } }
])
```

---

‚úÖ **Summary (for Interview Quick Recall):**

* **Embedded vs Reference:** Store together vs Link by ID
* **Operators:** `$set` updates, `$push` adds to array, `$addToSet` avoids duplicates, `$inc` increments
* **Aggregation:** `$match`, `$group`, `$sort`, `$project`, `$lookup`
* **Text search:** `$text` or `$regex`
* **Schema:** Embed small, reference large
* **Capped:** Fixed-size logs
* **find() vs aggregate():** Simple vs Analytical
