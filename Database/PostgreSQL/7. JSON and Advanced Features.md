## ⚙️ **1️⃣ How do you store JSON data in PostgreSQL?**

### ✅ **Definition:**

PostgreSQL provides two native data types to store JSON:

* `json`
* `jsonb`

You can store **structured JSON documents** directly inside a table column.

---

### 💡 **Example:**

```sql
CREATE TABLE products (
  id SERIAL PRIMARY KEY,
  name TEXT,
  details JSONB  -- you can also use JSON
);

INSERT INTO products (name, details) VALUES
('Laptop', '{"brand": "Dell", "specs": {"ram": "16GB", "storage": "512GB SSD"}}'),
('Phone',  '{"brand": "Samsung", "specs": {"ram": "8GB", "storage": "256GB"}}');
```

🧠 **Note:**

* JSON data must be **valid JSON format**.
* JSON fields can be accessed and queried just like regular columns.

---

## ⚡ **2️⃣ What is the difference between `json` and `jsonb`?**

| Feature            | **json**                    | **jsonb**                     |
| ------------------ | --------------------------- | ----------------------------- |
| **Storage Format** | Text (stored as-is)         | Binary (decomposed & indexed) |
| **Performance**    | Slower for search & filter  | Faster for search & indexing  |
| **Duplicates**     | Keeps duplicate keys        | Removes duplicate keys        |
| **Order of keys**  | Preserved                   | Not preserved                 |
| **Index Support**  | No                          | Yes (GIN indexes supported)   |
| **Best For**       | Logging, exact text storage | Querying, filtering, API data |

---

### 💡 **Example Comparison**

```sql
-- JSON type
CREATE TABLE example_json (
  data JSON
);

-- JSONB type
CREATE TABLE example_jsonb (
  data JSONB
);

INSERT INTO example_json VALUES ('{"x":1, "y":2, "x":3}'); -- keeps duplicates
INSERT INTO example_jsonb VALUES ('{"x":1, "y":2, "x":3}'); -- removes duplicates

SELECT * FROM example_json;
-- Output: {"x":1, "y":2, "x":3}

SELECT * FROM example_jsonb;
-- Output: {"x":3, "y":2}
```

🧠 `jsonb` is almost always preferred for **real-world use**, because it’s indexable and query-friendly.

---

## 🔍 **3️⃣ How can you query a `jsonb` column?**

PostgreSQL provides **powerful operators** to extract and filter JSON data.

### ✅ **Common JSONB Operators:**

| Operator | Description                         | Example                         |
| -------- | ----------------------------------- | ------------------------------- |
| `->`     | Get JSON object field               | `details -> 'brand'`            |
| `->>`    | Get JSON field as text              | `details ->> 'brand'`           |
| `#>`     | Get nested JSON object              | `details #> '{specs,ram}'`      |
| `#>>`    | Get nested JSON field as text       | `details #>> '{specs,ram}'`     |
| `@>`     | Check if JSON contains another JSON | `details @> '{"brand":"Dell"}'` |

---

### 💡 **Example 1: Extract a JSON key**

```sql
SELECT name, details ->> 'brand' AS brand
FROM products;
```

🧠 **Output:**

```
 name   | brand
---------+--------
 Laptop  | Dell
 Phone   | Samsung
```

---

### 💡 **Example 2: Access nested keys**

```sql
SELECT
  name,
  details #>> '{specs,ram}' AS ram
FROM products;
```

🧠 **Output:**

```
 name   |  ram
--------+--------
 Laptop | 16GB
 Phone  | 8GB
```

---

### 💡 **Example 3: Filter JSON data**

```sql
SELECT *
FROM products
WHERE details @> '{"brand": "Dell"}';
```

🧠 Returns only rows where brand = “Dell”.

---

### 💡 **Example 4: Create an index on JSONB**

```sql
CREATE INDEX idx_products_details ON products USING gin (details);
```

🧠 Makes queries like `details @> ...` much faster.

---

## 🧮 **4️⃣ Give an example of using PostgreSQL array data types**

### ✅ **Definition:**

PostgreSQL supports **arrays** as column types — allowing you to store multiple values in a single field.

---

### 💡 **Example:**

```sql
CREATE TABLE students (
  id SERIAL PRIMARY KEY,
  name TEXT,
  subjects TEXT[]
);

INSERT INTO students (name, subjects) VALUES
('Alice', ARRAY['Math', 'Science']),
('Bob',   ARRAY['English', 'History']);
```

---

### ✅ **Querying array data:**

```sql
-- 1️⃣ Select rows containing 'Math'
SELECT * FROM students WHERE 'Math' = ANY(subjects);

-- 2️⃣ Add a new subject
UPDATE students SET subjects = array_append(subjects, 'Art') WHERE name = 'Alice';

-- 3️⃣ Get array length
SELECT name, array_length(subjects, 1) AS num_subjects FROM students;
```

🧠 **Output:**

```
 name  | num_subjects
-------+--------------
 Alice | 3
 Bob   | 2
```

---

### 💡 **Array Operators**

| Operator | Description     | Example                               |
| -------- | --------------- | ------------------------------------- |
| `@>`     | contains        | `ARRAY['Math'] @> subjects`           |
| `<@`     | is contained by | `subjects <@ ARRAY['Math','Science']` |
| `&&`     | overlap         | `subjects && ARRAY['Math','History']` |

---

## 🧱 **5️⃣ How do you use `hstore` in PostgreSQL?**

### ✅ **Definition:**

`hstore` is a **key-value store** within a single PostgreSQL column.
It’s lighter than JSON and ideal for **storing dynamic attributes**.

🧠 Must enable it first (it’s an extension).

---

### 💡 **Setup:**

```sql
CREATE EXTENSION hstore;
```

---

### 💡 **Example:**

```sql
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name TEXT,
  attributes hstore
);

INSERT INTO users (name, attributes) VALUES
('John', 'age => 30, city => "Chennai"'),
('Sara', 'age => 25, city => "Delhi"');
```

---

### ✅ **Querying hstore:**

```sql
-- 1️⃣ Extract a value
SELECT name, attributes -> 'city' AS city FROM users;

-- 2️⃣ Filter rows by key-value
SELECT * FROM users WHERE attributes -> 'age' = '30';

-- 3️⃣ Add a new key-value pair
UPDATE users SET attributes = attributes || 'state => "TN"' WHERE name = 'John';
```

🧠 **Output Example:**

```
 name | city
------+--------
 John | Chennai
 Sara | Delhi
```

---

### 💡 **Comparison: hstore vs JSONB**

| Feature   | **hstore**            | **jsonb**               |
| --------- | --------------------- | ----------------------- |
| Type      | Key-value only (flat) | Nested (hierarchical)   |
| Data Type | `TEXT -> TEXT`        | Supports any type       |
| Indexing  | GIN supported         | GIN supported           |
| Use Case  | Simple metadata       | Complex structured data |

---

## ✅ **Quick Summary Table**

| Concept           | Description                                  | Example                         |
| ----------------- | -------------------------------------------- | ------------------------------- |
| **Store JSON**    | Use `json` or `jsonb` type                   | `details JSONB`                 |
| **json vs jsonb** | Text vs Binary, order & indexing differences | `CREATE INDEX ON jsonb_column;` |
| **Query JSONB**   | Use `->`, `->>`, `@>`, `#>`                  | `details @> '{"brand":"Dell"}'` |
| **Arrays**        | Store multiple values in one column          | `subjects TEXT[]`               |
| **hstore**        | Key-value store extension                    | `'key => value'`                |

---

### 🧠 Interview Tip:

If asked “When should you use JSONB vs relational columns?”:

> ✅ Use `JSONB` for flexible or semi-structured data (e.g., API payloads, logs, dynamic settings).
> ✅ Use normal columns for data you query frequently or that must be type-safe (e.g., `salary`, `age`).

