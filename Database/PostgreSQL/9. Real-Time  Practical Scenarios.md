## ‚ö° 1Ô∏è‚É£ **A query is running slow ‚Äî how do you debug it?**

### ‚úÖ **Approach:**

To diagnose a slow query, follow a step-by-step performance check:

---

### üß© **Step 1: Check Query Plan**

```sql
EXPLAIN ANALYZE SELECT * FROM employees WHERE department = 'HR';
```

* **EXPLAIN** ‚Üí shows how PostgreSQL plans to execute your query.
* **ANALYZE** ‚Üí executes it and gives actual runtime.

üß† Look for:

* **Seq Scan** (sequential scan) ‚Üí means no index used.
* **Index Scan** ‚Üí optimized.
* High **cost** or **rows** value ‚Üí possible inefficiency.

---

### üß© **Step 2: Check Index Usage**

```sql
SELECT * FROM pg_indexes WHERE tablename = 'employees';
```

If no index exists on frequently queried columns, create one:

```sql
CREATE INDEX idx_dept ON employees(department);
```

---

### üß© **Step 3: Check Statistics**

```sql
ANALYZE employees;
```

‚Üí Updates query planner statistics.

---

### üß© **Step 4: Monitor Running Queries**

```sql
SELECT pid, usename, state, query, query_start
FROM pg_stat_activity
WHERE state != 'idle';
```

---

### üß© **Step 5: Use `pg_stat_statements`**

```sql
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;
SELECT query, total_exec_time, calls
FROM pg_stat_statements
ORDER BY total_exec_time DESC LIMIT 5;
```

---

### ‚úÖ **Common Fixes:**

* Add proper **indexes**.
* Use **JOINs** instead of subqueries.
* Avoid `SELECT *` ‚Äî specify columns.
* Use **LIMIT**, **CTE**, or **batching** for large data.

---

## üß≠ 2Ô∏è‚É£ **How do you migrate a table from one schema to another?**

### ‚úÖ **Use `ALTER TABLE SET SCHEMA`:**

```sql
ALTER TABLE old_schema.employees SET SCHEMA new_schema;
```

üí° This moves the table and its data **without recreating it**.

---

### ‚ö†Ô∏è **Considerations:**

* Update **dependent objects** (like views, functions, or foreign keys).
* Make sure **target schema exists**:

  ```sql
  CREATE SCHEMA IF NOT EXISTS new_schema;
  ```

---

### üí° **Example:**

```sql
CREATE SCHEMA hr;
ALTER TABLE public.employees SET SCHEMA hr;
```

---

## üß± 3Ô∏è‚É£ **How would you handle schema changes in production?**

### ‚úÖ **Golden Rules:**

1. **Use migrations tools** ‚Üí e.g., Alembic, Flyway, Liquibase.
2. **Apply changes incrementally** (avoid downtime).
3. **Backup before schema change**.
4. **Run schema migrations inside transactions**.
5. **Avoid locks on large tables** ‚Äî use `ADD COLUMN` with defaults carefully.

---

### üí° **Example Scenario:**

You need to add a new column:

```sql
ALTER TABLE employees ADD COLUMN department_head BOOLEAN DEFAULT FALSE;
```

### ‚ö†Ô∏è **Best Practice:**

Instead of adding a default immediately (which locks the table):

1. Add column first (fast):

   ```sql
   ALTER TABLE employees ADD COLUMN department_head BOOLEAN;
   ```
2. Then update values in batches:

   ```sql
   UPDATE employees SET department_head = FALSE WHERE department_head IS NULL;
   ```
3. Finally, add constraint:

   ```sql
   ALTER TABLE employees ALTER COLUMN department_head SET DEFAULT FALSE;
   ```

---

## üëÄ 4Ô∏è‚É£ **How do you check active connections in PostgreSQL?**

### ‚úÖ **Check Active Sessions:**

```sql
SELECT pid, usename, datname, client_addr, state, query
FROM pg_stat_activity;
```

---

### ‚úÖ **Count Connections per Database:**

```sql
SELECT datname, COUNT(*) AS connections
FROM pg_stat_activity
GROUP BY datname;
```

---

### ‚úÖ **Terminate a Specific Connection:**

```sql
SELECT pg_terminate_backend(pid)
FROM pg_stat_activity
WHERE datname = 'test_db' AND state = 'idle';
```

---

### ‚úÖ **Check Max Connections Setting:**

```sql
SHOW max_connections;
```

---

## üß® 5Ô∏è‚É£ **What‚Äôs the difference between DELETE, TRUNCATE, and DROP?**

| Operation    | Action                          | Transaction Safe              | Rollback Possible | Affects Structure |
| ------------ | ------------------------------- | ----------------------------- | ----------------- | ----------------- |
| **DELETE**   | Removes rows matching condition | ‚úÖ Yes                         | ‚úÖ Yes             | ‚ùå No              |
| **TRUNCATE** | Removes all rows instantly      | ‚úÖ Yes (if inside transaction) | ‚úÖ Yes             | ‚ùå No              |
| **DROP**     | Removes the entire table        | ‚ùå No                          | ‚ùå No              | ‚úÖ Yes             |

---

### üí° **Example:**

```sql
DELETE FROM employees WHERE department = 'HR';
TRUNCATE TABLE employees;
DROP TABLE employees;
```

---

### üß† **Performance Note:**

* `TRUNCATE` is **faster** than `DELETE` (doesn‚Äôt log each row).
* `DELETE` triggers row-level constraints.
* `DROP` removes schema and cannot be rolled back unless inside a transaction.

---

## üå≤ 6Ô∏è‚É£ **How do you store hierarchical data (e.g., categories and subcategories)?**

PostgreSQL provides **two approaches**:

---

### ‚úÖ **A. Self-referencing (Adjacency List)**

Use a **parent-child relationship** within the same table.

```sql
CREATE TABLE categories (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    parent_id INT REFERENCES categories(id)
);

-- Example Data
INSERT INTO categories (name, parent_id) VALUES
('Electronics', NULL),
('Mobiles', 1),
('Laptops', 1),
('Accessories', 2);
```

To get hierarchy:

```sql
SELECT c1.name AS category, c2.name AS parent
FROM categories c1
LEFT JOIN categories c2 ON c1.parent_id = c2.id;
```

---

### ‚úÖ **B. Using ltree Extension (for tree structures)**

`ltree` helps store paths like `"Electronics.Mobiles.Samsung"`.

```sql
CREATE EXTENSION ltree;

CREATE TABLE category_tree (
    id SERIAL PRIMARY KEY,
    path LTREE
);

INSERT INTO category_tree(path) VALUES
('Electronics'),
('Electronics.Mobiles'),
('Electronics.Mobiles.Samsung');
```

Query subcategories:

```sql
SELECT * FROM category_tree WHERE path <@ 'Electronics.Mobiles';
```

üß† Meaning: all nodes under ‚ÄúElectronics.Mobiles‚Äù.

---

## üîç 7Ô∏è‚É£ **How do you perform case-insensitive searches?**

### ‚úÖ **Option 1: Use `ILIKE`**

```sql
SELECT * FROM employees WHERE name ILIKE '%john%';
```

‚Üí Case-insensitive version of `LIKE`.

---

### ‚úÖ **Option 2: Use `LOWER()`**

```sql
SELECT * FROM employees WHERE LOWER(name) = LOWER('John');
```

---

### ‚úÖ **Option 3: Use `citext` Extension**

```sql
CREATE EXTENSION citext;

CREATE TABLE users (
    username CITEXT UNIQUE
);
```

Now `"John"` and `"john"` are treated the same.

---

## üß© 8Ô∏è‚É£ **How do you ensure data integrity between related tables?**

### ‚úÖ **Use Foreign Keys**

```sql
CREATE TABLE departments (
    dept_id SERIAL PRIMARY KEY,
    dept_name TEXT UNIQUE
);

CREATE TABLE employees (
    emp_id SERIAL PRIMARY KEY,
    emp_name TEXT,
    dept_id INT REFERENCES departments(dept_id)
);
```

üß† Ensures that every employee‚Äôs `dept_id` exists in the `departments` table.

---

### ‚úÖ **Use ON DELETE / ON UPDATE Rules**

```sql
ALTER TABLE employees
ADD CONSTRAINT fk_dept
FOREIGN KEY (dept_id)
REFERENCES departments(dept_id)
ON DELETE CASCADE
ON UPDATE CASCADE;
```

* `ON DELETE CASCADE`: deletes related employees if department is deleted.
* `ON DELETE SET NULL`: sets dept_id = NULL if department deleted.

---

### ‚úÖ **Other Integrity Tools**

| Type                  | Example              | Purpose                 |
| --------------------- | -------------------- | ----------------------- |
| **CHECK constraint**  | `CHECK (salary > 0)` | Validate column values  |
| **UNIQUE constraint** | `UNIQUE(email)`      | Prevent duplicates      |
| **NOT NULL**          | `NOT NULL`           | Ensure mandatory fields |
| **PRIMARY KEY**       | `PRIMARY KEY(id)`    | Uniquely identify rows  |

---

## ‚úÖ **Summary Table**

| Scenario                   | Solution                                                    | Example                           |
| -------------------------- | ----------------------------------------------------------- | --------------------------------- |
| Slow query                 | `EXPLAIN ANALYZE`, `pg_stat_activity`, `pg_stat_statements` | Tune indexes                      |
| Move table between schemas | `ALTER TABLE ... SET SCHEMA`                                | Move HR data                      |
| Schema changes in prod     | Use migration tools                                         | Alembic / Flyway                  |
| Active connections         | `pg_stat_activity`                                          | Monitor & terminate               |
| Delete vs Truncate vs Drop | Row vs full data vs structure                               | `DELETE FROM`, `TRUNCATE`, `DROP` |
| Hierarchical data          | Self-referencing or `ltree`                                 | Category trees                    |
| Case-insensitive search    | `ILIKE`, `LOWER()`, or `citext`                             | Name search                       |
| Data integrity             | Foreign Keys, Constraints                                   | Maintain referential links        |

