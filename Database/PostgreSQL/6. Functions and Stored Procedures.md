
## ‚öôÔ∏è **1Ô∏è‚É£ How do you create a function in PostgreSQL?**

### ‚úÖ **Definition:**

A **function** in PostgreSQL is a **stored block of code** that performs a task and **returns a value**.
It can be written in SQL or procedural languages like **PL/pgSQL**.

---

### üí° **Basic Syntax:**

```sql
CREATE OR REPLACE FUNCTION function_name(parameter_list)
RETURNS return_type AS $$
BEGIN
   -- function body
   RETURN value;
END;
$$ LANGUAGE plpgsql;
```

---

### üßæ **Example 1: Simple Function**

```sql
CREATE OR REPLACE FUNCTION add_numbers(a INTEGER, b INTEGER)
RETURNS INTEGER AS $$
BEGIN
   RETURN a + b;
END;
$$ LANGUAGE plpgsql;

-- Call the function
SELECT add_numbers(10, 20);
```

üß† **Output:**

```
30
```

---

### üßæ **Example 2: Function using table data**

```sql
CREATE OR REPLACE FUNCTION get_employee_salary(emp_id INT)
RETURNS NUMERIC AS $$
DECLARE
   emp_salary NUMERIC;
BEGIN
   SELECT salary INTO emp_salary FROM employees WHERE id = emp_id;
   RETURN emp_salary;
END;
$$ LANGUAGE plpgsql;

SELECT get_employee_salary(101);
```

---

## üßÆ **2Ô∏è‚É£ What is the difference between a function and a stored procedure?**

| Feature             | **Function**                     | **Stored Procedure**              |
| ------------------- | -------------------------------- | --------------------------------- |
| Return Type         | Must return a value (`RETURNS`)  | May or may not return a value     |
| Usage               | Can be used inside queries       | Called independently using `CALL` |
| Transaction Control | Cannot use `COMMIT` / `ROLLBACK` | Can use transaction control       |
| Invocation          | `SELECT function_name()`         | `CALL procedure_name()`           |
| Introduced in       | Available from the start         | PostgreSQL 11+                    |

---

### üí° **Example: Stored Procedure**

```sql
CREATE OR REPLACE PROCEDURE increase_salary(emp_id INT, inc_amount NUMERIC)
LANGUAGE plpgsql
AS $$
BEGIN
   UPDATE employees
   SET salary = salary + inc_amount
   WHERE id = emp_id;

   COMMIT;
END;
$$;

-- Call the procedure
CALL increase_salary(101, 5000);
```

üß† **Difference summary:**

* **Function** ‚Üí returns something ‚Üí used in `SELECT`.
* **Procedure** ‚Üí performs an action ‚Üí used with `CALL`.

---

## üßæ **3Ô∏è‚É£ How do you return multiple rows from a function?**

### ‚úÖ **Approach 1: RETURN SETOF <table>**

```sql
CREATE OR REPLACE FUNCTION get_all_employees()
RETURNS SETOF employees AS $$
BEGIN
   RETURN QUERY SELECT * FROM employees;
END;
$$ LANGUAGE plpgsql;

-- Call it like a table
SELECT * FROM get_all_employees();
```

üß† **Explanation:**

* `RETURN QUERY` executes the query and returns multiple rows.
* `SETOF employees` means the function returns all rows of that table type.

---

### ‚úÖ **Approach 2: RETURN TABLE(columns...)**

```sql
CREATE OR REPLACE FUNCTION get_employees_by_dept(dept TEXT)
RETURNS TABLE(emp_id INT, emp_name TEXT, emp_salary NUMERIC) AS $$
BEGIN
   RETURN QUERY
   SELECT id, name, salary
   FROM employees
   WHERE department = dept;
END;
$$ LANGUAGE plpgsql;

SELECT * FROM get_employees_by_dept('HR');
```

üß† This is great when you want to define a **custom result structure**.

---

## üß± **4Ô∏è‚É£ What is the DO block in PostgreSQL?**

### ‚úÖ **Definition:**

The `DO` block allows you to **execute anonymous PL/pgSQL code** ‚Äî
that is, code that **isn‚Äôt stored permanently** as a function or procedure.

Useful for **one-time tasks**, testing, or scripts.

---

### üí° **Example:**

```sql
DO $$
DECLARE
   total_employees INT;
BEGIN
   SELECT COUNT(*) INTO total_employees FROM employees;
   RAISE NOTICE 'Total employees: %', total_employees;
END;
$$;
```

üß† **Explanation:**

* The `DO` block executes immediately.
* You can declare variables, perform calculations, and use loops/conditions.
* It‚Äôs not stored ‚Äî runs once and disappears.

---

## üîî **5Ô∏è‚É£ What are triggers? When do you use them?**

### ‚úÖ **Definition:**

A **trigger** is a special database object that **automatically executes** a function **in response to specific events** (like INSERT, UPDATE, DELETE) on a table.

---

### üí° **Trigger structure:**

A trigger always calls a **trigger function**.

### Steps:

1. Create a function that defines what happens.
2. Create a trigger that calls that function.

---

### üßæ **Example:**

```sql
-- Step 1: Create trigger function
CREATE OR REPLACE FUNCTION log_salary_changes()
RETURNS TRIGGER AS $$
BEGIN
   INSERT INTO salary_log(emp_id, old_salary, new_salary, changed_on)
   VALUES (OLD.id, OLD.salary, NEW.salary, NOW());
   RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Step 2: Create trigger on employees table
CREATE TRIGGER salary_update_trigger
AFTER UPDATE OF salary ON employees
FOR EACH ROW
EXECUTE FUNCTION log_salary_changes();
```

### üß† **Explanation:**

* `AFTER UPDATE OF salary`: Trigger runs **after salary changes**.
* `OLD` and `NEW` are **records** available in trigger functions.
* Trigger automatically logs changes into `salary_log` table.

---

### üí° **Types of Triggers:**

| Type                   | Description                                                   |
| ---------------------- | ------------------------------------------------------------- |
| **BEFORE**             | Runs before the operation (used for validation/modification). |
| **AFTER**              | Runs after the operation (used for logging/auditing).         |
| **INSTEAD OF**         | Used with views to replace the original operation.            |
| **FOR EACH ROW**       | Executes once per row affected.                               |
| **FOR EACH STATEMENT** | Executes once per SQL statement.                              |

---

## üß† **6Ô∏è‚É£ What are some common use cases for triggers?**

| Use Case                  | Description                                                  |
| ------------------------- | ------------------------------------------------------------ |
| **Audit Logging**         | Track changes in data (who changed what and when).           |
| **Data Validation**       | Automatically enforce business rules before insert/update.   |
| **Automatic Updates**     | Update related tables automatically (e.g., totals, history). |
| **Soft Deletes**          | Move deleted records into an archive table.                  |
| **Notification System**   | Send alerts or notifications after certain updates.          |
| **Enforcing consistency** | Prevent invalid updates/deletes between related tables.      |

---

### üí° **Example: Soft Delete**

```sql
CREATE OR REPLACE FUNCTION archive_before_delete()
RETURNS TRIGGER AS $$
BEGIN
   INSERT INTO employee_archive SELECT * FROM employees WHERE id = OLD.id;
   RETURN OLD;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER before_delete_trigger
BEFORE DELETE ON employees
FOR EACH ROW
EXECUTE FUNCTION archive_before_delete();
```

üß† Now whenever an employee is deleted, the record is automatically **archived** before deletion.

---

## ‚úÖ **Quick Summary Table**

| Concept                  | Description                              | Example                         |
| ------------------------ | ---------------------------------------- | ------------------------------- |
| **Function**             | Stored code that returns a value         | `CREATE FUNCTION add(a,b)`      |
| **Procedure**            | Stored code that performs an action      | `CREATE PROCEDURE ... CALL ...` |
| **Return Multiple Rows** | Use `RETURN QUERY` or `RETURNS TABLE`    | `SELECT * FROM get_employees()` |
| **DO Block**             | Anonymous PL/pgSQL block                 | `DO $$ BEGIN ... END; $$;`      |
| **Trigger**              | Auto-executes a function on table events | `CREATE TRIGGER ...`            |
| **Common Uses**          | Audit, validation, automation            | Salary log, soft delete         |
