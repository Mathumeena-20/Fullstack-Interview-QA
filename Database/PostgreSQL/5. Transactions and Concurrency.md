## ‚öôÔ∏è **1Ô∏è‚É£ What is a transaction in PostgreSQL?**

### ‚úÖ **Definition:**

A **transaction** is a **sequence of one or more SQL statements** that are executed as a **single unit of work**.

* All statements inside a transaction are either **fully completed (COMMIT)** or **completely undone (ROLLBACK)**.
* It ensures **data integrity** and **consistency**.

---

### üí° **Example:**

```sql
BEGIN;

UPDATE accounts SET balance = balance - 500 WHERE id = 1;  -- debit
UPDATE accounts SET balance = balance + 500 WHERE id = 2;  -- credit

COMMIT;
```

If both queries succeed ‚Üí **changes are saved** (COMMIT).
If one fails ‚Üí you can **ROLLBACK** to undo both.

---

### üß† **Why use transactions?**

To make sure that a group of related operations (like transferring money) either **all happen or none happen**.

---

## üß± **2Ô∏è‚É£ Explain the ACID properties**

### ‚úÖ **ACID = Atomicity, Consistency, Isolation, Durability**

| Property        | Meaning                                                     | Example                                   |
| --------------- | ----------------------------------------------------------- | ----------------------------------------- |
| **Atomicity**   | All operations in a transaction succeed or none do.         | If debit fails, credit doesn‚Äôt occur.     |
| **Consistency** | Database moves from one valid state to another.             | Balance total before = after transfer.    |
| **Isolation**   | Transactions don‚Äôt interfere with each other.               | Two users updating same data don‚Äôt clash. |
| **Durability**  | Once committed, data is saved permanently even after crash. | After COMMIT, data survives restart.      |

---

### üí° **Example for ACID:**

```sql
BEGIN;
UPDATE bank_accounts SET balance = balance - 1000 WHERE id = 1;
UPDATE bank_accounts SET balance = balance + 1000 WHERE id = 2;
COMMIT;
```

If the second statement fails, PostgreSQL automatically rolls back (Atomicity).
Data remains consistent, isolated, and durable.

---

## üîí **3Ô∏è‚É£ What are isolation levels?**

### ‚úÖ **Definition:**

Isolation levels control **how visible uncommitted changes** from one transaction are to other concurrent transactions.

In PostgreSQL, there are **4 standard isolation levels:**

| Isolation Level                | Description                                                         | Phenomena Prevented                   |
| ------------------------------ | ------------------------------------------------------------------- | ------------------------------------- |
| **Read Uncommitted**           | Practically same as Read Committed (PostgreSQL treats it the same). | Prevents dirty reads (by default).    |
| **Read Committed** *(default)* | Each statement sees only committed data.                            | Prevents dirty reads.                 |
| **Repeatable Read**            | All queries in a transaction see the same snapshot.                 | Prevents non-repeatable reads.        |
| **Serializable**               | Transactions behave as if executed sequentially.                    | Prevents all anomalies (most strict). |

---

### üí° **Phenomena explained:**

| Problem                 | Description                                             | Prevented by    |
| ----------------------- | ------------------------------------------------------- | --------------- |
| **Dirty Read**          | Reading uncommitted data from another transaction       | Read Committed  |
| **Non-repeatable Read** | Same query gives different results within a transaction | Repeatable Read |
| **Phantom Read**        | A new row appears between two reads                     | Serializable    |

---

### üßæ **Example of setting isolation level:**

```sql
BEGIN TRANSACTION ISOLATION LEVEL REPEATABLE READ;

SELECT * FROM employees WHERE department = 'HR';

-- ... some concurrent changes by another user ...

SELECT * FROM employees WHERE department = 'HR';

COMMIT;
```

üß† Even if another user adds an employee to HR during this transaction,
you‚Äôll still see the **same snapshot** (no phantom read).

---

## ‚öôÔ∏è **4Ô∏è‚É£ What is the default isolation level in PostgreSQL?**

### ‚úÖ **Default:** `READ COMMITTED`

This means:

* Each SQL statement sees only data **committed before** the statement begins.
* Other transactions‚Äô uncommitted changes are **invisible**.

---

### üí° **Check current isolation level:**

```sql
SHOW default_transaction_isolation;
```

Output:

```
read committed
```

---

## üíæ **5Ô∏è‚É£ What is the difference between COMMIT and ROLLBACK?**

| Command      | Description                                            | Example     |
| ------------ | ------------------------------------------------------ | ----------- |
| **COMMIT**   | Saves all changes made in the transaction permanently. | `COMMIT;`   |
| **ROLLBACK** | Cancels all changes made in the transaction.           | `ROLLBACK;` |

---

### üí° **Example:**

```sql
BEGIN;

UPDATE employees SET salary = salary + 1000 WHERE id = 1;

-- Suppose something goes wrong
ROLLBACK;

-- No changes are saved
```

üß† **Tip:** Always use transactions when updating multiple tables together.

---

## ‚öîÔ∏è **6Ô∏è‚É£ What is a deadlock and how do you prevent it?**

### ‚úÖ **Definition:**

A **deadlock** occurs when **two or more transactions** are waiting for each other to release a **lock**, causing both to **wait forever**.

---

### üí° **Example of deadlock:**

**Transaction 1:**

```sql
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
-- waits for T2
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
```

**Transaction 2:**

```sql
BEGIN;
UPDATE accounts SET balance = balance - 50 WHERE id = 2;
-- waits for T1
UPDATE accounts SET balance = balance + 50 WHERE id = 1;
```

üß† Each one is waiting for the other ‚Üí **Deadlock**.
PostgreSQL will detect it and cancel one of them with:

```
ERROR: deadlock detected
```

---

### ‚úÖ **How to prevent deadlocks:**

1. **Always access tables in the same order** across transactions.
2. **Keep transactions short** (less locking time).
3. **Use SELECT ... FOR UPDATE** carefully.
4. **Avoid manual locking unless necessary.**
5. **Use optimistic concurrency control** for low contention tables.

---

## üë• **7Ô∏è‚É£ How can you handle concurrency in PostgreSQL?**

PostgreSQL handles concurrency using **MVCC (Multi-Version Concurrency Control)**.

### ‚úÖ **MVCC:**

* Each transaction sees a **snapshot** of the database at the time it started.
* Writers don‚Äôt block readers, and readers don‚Äôt block writers.
* Updates create **new versions** of rows instead of overwriting existing ones.

---

### üí° **Example:**

Transaction 1:

```sql
BEGIN;
UPDATE employees SET salary = salary + 1000 WHERE id = 1;
-- Not yet committed
```

Transaction 2:

```sql
SELECT salary FROM employees WHERE id = 1;
```

üß† Transaction 2 still sees the **old salary** until Transaction 1 commits.

---

### ‚úÖ **Concurrency best practices:**

| Tip                                        | Explanation                          |
| ------------------------------------------ | ------------------------------------ |
| Use MVCC (default)                         | PostgreSQL does it automatically.    |
| Keep transactions short                    | Reduces lock contention.             |
| Use `FOR UPDATE` to lock rows if necessary | Prevents conflicting updates.        |
| Use proper isolation level                 | Higher isolation = safer but slower. |
| Monitor locks                              | Use `pg_locks` view to debug.        |

---

### üí° **Check current locks:**

```sql
SELECT * FROM pg_locks;
```

---

## ‚úÖ **Quick Summary Table**

| Concept          | Description                           | Example                                       |
| ---------------- | ------------------------------------- | --------------------------------------------- |
| Transaction      | Group of SQL statements               | `BEGIN ... COMMIT;`                           |
| ACID             | Ensures reliability                   | Atomic, Consistent, Isolated, Durable         |
| Isolation Levels | Control visibility of data            | Read Committed, Repeatable Read, Serializable |
| Default Level    | `READ COMMITTED`                      | ‚Äî                                             |
| COMMIT           | Save changes                          | `COMMIT;`                                     |
| ROLLBACK         | Undo changes                          | `ROLLBACK;`                                   |
| Deadlock         | Circular waiting between transactions | Access resources in same order                |
| Concurrency      | Parallel transactions                 | Managed by MVCC                               |
