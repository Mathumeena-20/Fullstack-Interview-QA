## 🧠 **1️⃣ Write a query to get the second highest salary from an employees table.**

### ✅ **Table Example:**

```sql
CREATE TABLE employees (
  id SERIAL PRIMARY KEY,
  name TEXT,
  salary NUMERIC
);
```

### 💡 **Query #1 (Using `LIMIT` and `OFFSET`):**

```sql
SELECT DISTINCT salary
FROM employees
ORDER BY salary DESC
OFFSET 1 LIMIT 1;
```

🧩 **Explanation:**

* `ORDER BY salary DESC` → sorts salaries from high to low.
* `OFFSET 1` → skips the highest salary.
* `LIMIT 1` → gets the next one (the second highest).

---

### 💡 **Query #2 (Using Subquery):**

```sql
SELECT MAX(salary) AS second_highest_salary
FROM employees
WHERE salary < (SELECT MAX(salary) FROM employees);
```

🧩 **Explanation:**

* Inner query gets the **maximum salary**.
* Outer query gets the **maximum salary that is less than the highest**.

---

## 📅 **2️⃣ Write a query to find employees who joined in the last 30 days.**

### ✅ **Assume table has:**

```sql
ALTER TABLE employees ADD COLUMN joining_date DATE;
```

### 💡 **Query:**

```sql
SELECT *
FROM employees
WHERE joining_date >= CURRENT_DATE - INTERVAL '30 days';
```

🧩 **Explanation:**

* `CURRENT_DATE` gives today’s date.
* Subtracting `'30 days'` gives the threshold date.
* This returns all employees who joined within the last 30 days.

---

## 🔗 **3️⃣ What is the difference between INNER JOIN, LEFT JOIN, RIGHT JOIN, and FULL JOIN?**

| Join Type      | Description                                                      | Example Result                               |
| -------------- | ---------------------------------------------------------------- | -------------------------------------------- |
| **INNER JOIN** | Returns rows that have matching values in both tables            | Only matched records                         |
| **LEFT JOIN**  | Returns all rows from left table + matched rows from right table | Includes unmatched rows from left as `NULL`  |
| **RIGHT JOIN** | Returns all rows from right table + matched rows from left table | Includes unmatched rows from right as `NULL` |
| **FULL JOIN**  | Returns all rows when there’s a match in either table            | Includes unmatched rows from both            |

### 💡 **Example:**

```sql
SELECT e.name, d.department_name
FROM employees e
INNER JOIN departments d ON e.dept_id = d.id;
```

### 📊 **Conceptual Diagram:**

```
INNER JOIN  →  A ∩ B
LEFT JOIN   →  A + (A ∩ B)
RIGHT JOIN  →  B + (A ∩ B)
FULL JOIN   →  A ∪ B
```

---

## 🔄 **4️⃣ How do you perform cross joins in PostgreSQL?**

### ✅ **Definition:**

A **CROSS JOIN** produces the **Cartesian product** of both tables — every row from one table combined with every row from another.

### 💡 **Example:**

```sql
SELECT e.name, p.project_name
FROM employees e
CROSS JOIN projects p;
```

🧩 **Explanation:**
If you have 5 employees and 3 projects → output will have **15 rows (5 × 3)**.

---

## 🔁 **5️⃣ How can you get distinct records from a table?**

### ✅ **Using `DISTINCT`:**

```sql
SELECT DISTINCT department_id FROM employees;
```

### 💡 **Multiple Columns:**

```sql
SELECT DISTINCT department_id, job_title FROM employees;
```

🧩 **Explanation:**
Eliminates duplicate combinations of selected columns.

---

## 🧮 **6️⃣ Write a query to count the number of employees in each department.**

### 💡 **Query:**

```sql
SELECT department_id, COUNT(*) AS total_employees
FROM employees
GROUP BY department_id;
```

### ✅ **With department name:**

```sql
SELECT d.department_name, COUNT(e.id) AS total_employees
FROM employees e
JOIN departments d ON e.department_id = d.id
GROUP BY d.department_name;
```

🧩 **Explanation:**

* `GROUP BY` groups rows per department.
* `COUNT(*)` counts how many employees each group has.

---

## 🧱 **7️⃣ What is a CTE (Common Table Expression)? Give an example.**

### ✅ **Definition:**

A **CTE (Common Table Expression)** is a **temporary named result set** that can be referenced within a `SELECT`, `INSERT`, `UPDATE`, or `DELETE` query.

### 💡 **Syntax:**

```sql
WITH cte_name AS (
    SELECT * FROM employees WHERE salary > 50000
)
SELECT name FROM cte_name WHERE joining_date > '2024-01-01';
```

🧩 **Explanation:**

* The part inside `WITH` runs first and stores the result temporarily.
* The main query then uses that result as if it were a table.

---

## 🔍 **8️⃣ What is the difference between a CTE and a subquery?**

| Feature      | CTE                                | Subquery           |
| ------------ | ---------------------------------- | ------------------ |
| Readability  | Easier to read and debug           | Can get complex    |
| Reusability  | Can be referenced multiple times   | Executes each time |
| Optimization | PostgreSQL may materialize results | Inline execution   |
| Recursion    | Supports recursive queries         | Not supported      |

### 💡 **Example Comparison:**

**Using Subquery:**

```sql
SELECT * 
FROM (SELECT * FROM employees WHERE salary > 50000) AS temp
WHERE joining_date > '2024-01-01';
```

**Using CTE:**

```sql
WITH high_salary AS (
    SELECT * FROM employees WHERE salary > 50000
)
SELECT * FROM high_salary WHERE joining_date > '2024-01-01';
```

✅ CTE improves **clarity** and supports **recursive queries** (like hierarchical org charts).

---

## 📄 **9️⃣ How do you perform pagination in PostgreSQL (showing 10 records per page)?**

### 💡 **Syntax:**

```sql
SELECT *
FROM employees
ORDER BY id
LIMIT 10 OFFSET 0;   -- Page 1
```

For page 2:

```sql
SELECT *
FROM employees
ORDER BY id
LIMIT 10 OFFSET 10;
```

🧩 **Explanation:**

* `LIMIT` → number of rows per page.
* `OFFSET` → number of rows to skip.

✅ **Formula:**
`OFFSET = (page_number - 1) * limit`

---

## 📝 **🔟 What is the RETURNING clause used for in an INSERT, UPDATE, or DELETE statement?**

### ✅ **Definition:**

`RETURNING` lets you return columns from the affected rows — very useful for getting IDs or updated values.

### 💡 **Examples:**

**INSERT:**

```sql
INSERT INTO employees (name, salary)
VALUES ('John', 60000)
RETURNING id, name;
```

🧩 → Returns the inserted record’s `id` and `name`.

**UPDATE:**

```sql
UPDATE employees
SET salary = salary * 1.1
WHERE department_id = 2
RETURNING id, name, salary;
```

**DELETE:**

```sql
DELETE FROM employees
WHERE salary < 30000
RETURNING id, name;
```

✅ **Use Case:**

* Fetch newly created IDs without a second query.
* Log updated/deleted data efficiently.
