# ‚úÖ **1. What is the Strategy Pattern?**

The **Strategy Pattern** is a behavioral design pattern that:

* Defines a **family of algorithms**
* Encapsulates each one as a **strategy class**
* Allows selecting an algorithm **at runtime**
* Avoids large **if-else / switch-case** logic

### Core idea:

> ‚ÄúChange behavior without changing the client code.‚Äù

---

# ‚úÖ **2. How does Strategy pattern help in avoiding if-else?**

Instead of writing:

```java
if (type.equals("credit")) processCredit();
else if (type.equals("paypal")) processPaypal();
else if (type.equals("upi")) processUpi();
```

We select a strategy at runtime:

```java
PaymentStrategy strategy = strategyMap.get(type);
strategy.pay(amount);
```

‚úî No if-else
‚úî Easily extendable
‚úî Clean code

---

# ‚úÖ **3. Difference between Strategy and Factory**

| Feature           | Strategy                 | Factory                         |
| ----------------- | ------------------------ | ------------------------------- |
| Purpose           | Select an algorithm      | Create an object                |
| When used         | Need different behaviors | Need different concrete classes |
| Output            | Behavior (method)        | Object instance                 |
| Runtime switching | Common                   | Possible but not focus          |
| Example           | Payment method           | Create Shape object             |

### Simplified:

* **Factory chooses *what* object** to create
* **Strategy chooses *how* behavior* executes**

---

# üü¢ Interview answer:

> ‚ÄúFactory creates objects, Strategy changes behavior.‚Äù

---

# ‚úÖ **4. Real-world example of Strategy Pattern**

### ‚úî Payment processing

CreditCardStrategy, PaypalStrategy, UPIStrategy

### ‚úî Sorting algorithms

QuickSort, MergeSort, BubbleSort

### ‚úî Compression algorithms

ZipCompression, RarCompression

### ‚úî Pathfinding in maps

DijkstraStrategy, AStarStrategy

### ‚úî Authentication mechanisms

LDAPAuthStrategy, OAuthStrategy

### ‚úî Discount calculation

FestivalDiscount, ClearanceDiscount, NoDiscount

---

# üí° Example: Payment Strategy Pattern

### Strategy Interface

```java
public interface PaymentStrategy {
    void pay(double amount);
}
```

### Strategies

```java
public class CreditCardPayment implements PaymentStrategy {
    public void pay(double amount) {
        System.out.println("Paid via Credit Card: " + amount);
    }
}

public class PaypalPayment implements PaymentStrategy {
    public void pay(double amount) {
        System.out.println("Paid via PayPal: " + amount);
    }
}
```

### Context class

```java
public class PaymentService {
    private PaymentStrategy strategy;
    public PaymentService(PaymentStrategy strategy) {
        this.strategy = strategy;
    }
    public void execute(double amount) {
        strategy.pay(amount);
    }
}
```

### Usage

```java
PaymentService service = new PaymentService(new CreditCardPayment());
service.execute(500);
```

---

# ‚úÖ **5. How do you combine Strategy with Dependency Injection?**

Use Spring to inject strategies.

### Step 1 ‚Äî Annotate strategies

```java
@Component("credit")
public class CreditCardPayment implements PaymentStrategy { ... }

@Component("paypal")
public class PaypalPayment implements PaymentStrategy { ... }
```

### Step 2 ‚Äî Auto-wire using a map

```java
@Service
public class PaymentFactory {

    @Autowired
    private Map<String, PaymentStrategy> strategies;

    public PaymentStrategy getStrategy(String type) {
        return strategies.get(type);
    }
}
```

### Step 3 ‚Äî Use it

```java
PaymentStrategy strategy = paymentFactory.getStrategy("paypal");
strategy.pay(1000);
```

‚úî No if-else
‚úî Easily extendable by adding new beans

---

# üü¢ Spring DI + Strategy is VERY common in enterprise Java.

---

# ‚úÖ **6. How does Spring apply Strategy pattern?**

Spring internally uses Strategy pattern in many places:

### ‚úî ViewResolver strategy

JSPViewResolver, ThymeleafViewResolver, MappingJackson2JsonViewResolver

### ‚úî Cache strategies

ConcurrentMapCache, EhCache, RedisCache

### ‚úî TaskExecutor strategies

ThreadPoolTaskExecutor, SimpleAsyncTaskExecutor

### ‚úî Resource loading

ClassPathResource, UrlResource, FileResource

Spring uses Strategy everywhere to allow plugging in different behaviors.

---

# üü¢ Interview answer:

> ‚ÄúSpring uses Strategy pattern in ViewResolver, CacheManager, TaskExecutor, and more.‚Äù

---

# ‚úÖ **7. Advantages and Disadvantages of Strategy pattern**

### ‚úî **Advantages**

* Avoids big if-else statements
* Open/Closed: easily add new strategies
* Runtime flexibility (swap algorithms)
* Improved readability & maintainability
* Promotes dependency injection
* Unit test friendly

---

### ‚ùå **Disadvantages**

* More classes created
* Client must know which strategy to choose
* Hard to manage if too many small strategy classes

---

# üü¢ Tip: Strategy is GOOD for extensibility, BAD if overused.

---

# ‚úÖ **8. Example of selecting different algorithms using Strategy**

### Sorting Strategy Example

```java
public interface SortStrategy {
    void sort(List<Integer> list);
}
```

Strategies:

```java
public class QuickSort implements SortStrategy {
    public void sort(List<Integer> list) { System.out.println("QuickSort..."); }
}

public class MergeSort implements SortStrategy {
    public void sort(List<Integer> list) { System.out.println("MergeSort..."); }
}
```

Runtime selection:

```java
SortStrategy strategy = new MergeSort();
strategy.sort(data);
```

---

# ‚úÖ **9. How do you make strategies extensible?**

### Techniques:

---

### ‚úî 1. Use Spring‚Äôs `Map<String, Strategy>` auto-discovery

Adding a new @Component automatically registers a new strategy.

---

### ‚úî 2. Use reflection / classpath scanning

Dynamic strategy loading.

---

### ‚úî 3. Use Strategy enum map

```java
public enum PaymentType {
    CREDIT, PAYPAL, UPI
}
```

Map:

```java
Map<PaymentType, PaymentStrategy> map = new HashMap<>();
```

---

### ‚úî 4. Use factory + strategy together

Factory chooses the right strategy.

---

# üü¢ Interview answer:

> ‚ÄúStrategies are extensible because adding a new algorithm requires creating a new class without modifying existing code‚Äîconforming to OCP.‚Äù

---

# ‚úÖ **10. Compare Strategy vs Template Method**

| Feature      | Strategy                      | Template Method                              |
| ------------ | ----------------------------- | -------------------------------------------- |
| Concept      | Behavior chosen at runtime    | Algorithm steps fixed, subclasses fill parts |
| Flexibility  | High (plug and play)          | Medium (inheritance required)                |
| Based on     | Composition                   | Inheritance                                  |
| Change logic | Replace strategy              | Override methods                             |
| Use case     | Payment, sorting, compression | Workflow steps, lifecycle hooks              |

### Example Summary:

* **Strategy**: interchangeable *algorithms*
* **Template Method**: fixed algorithm with *customizable steps*

---

# üéØ **Final Summary (Cheatsheet)**

| Question                    | Short Answer                           |
| --------------------------- | -------------------------------------- |
| Strategy Pattern            | Allows selecting algorithms at runtime |
| Avoid if-else               | Mapping input ‚Üí strategy classes       |
| Strategy vs Factory         | Strategy = behavior; Factory = object  |
| Real-world example          | Payment, sorting, authentication       |
| With DI                     | Use map of strategies in Spring        |
| Spring uses it              | ViewResolver, CacheManager             |
| Pros                        | Extensible, avoids if-else             |
| Cons                        | Many small classes                     |
| Example                     | QuickSort, MergeSort algorithms        |
| Extensible                  | Add new classes; DI auto-register      |
| Strategy vs Template Method | Composition vs Inheritance             |

---

