# **1. What is an Entity in JPA?**

An **Entity** is a lightweight, persistent Java object that represents a table in the database.

* It is managed by the **EntityManager**.
* Each instance of an entity = one row in the table.
* Must have:

  * `@Entity` annotation
  * A primary key (`@Id`)
  * A no-arg constructor

Example:

```java
@Entity
public class Employee {
    @Id
    private Long id;
    private String name;
}
```

---

# **2. Purpose of `@Entity` and `@Table` annotations**

### `@Entity`

* Marks the class as persistent.
* JPA will map it to a table (default: class name).

```java
@Entity
public class Employee { ... }
```

### `@Table`

* Optional.
* Used to override table name or set schema.

```java
@Entity
@Table(name = "employees", schema = "hr")
public class Employee { ... }
```

---

# **3. Difference between `@Id`, `@GeneratedValue`, and strategies**

### `@Id`

* Marks the primary key of an entity.

### `@GeneratedValue`

* Tells JPA that the primary key will be auto-generated.

```java
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;
```

### Generation Strategies

| Strategy     | Description                          | Where used           |
| ------------ | ------------------------------------ | -------------------- |
| **IDENTITY** | DB generates ID using AUTO_INCREMENT | MySQL                |
| **SEQUENCE** | Uses a DB sequence                   | PostgreSQL, Oracle   |
| **TABLE**    | Uses a table to maintain sequence    | DB-agnostic but slow |
| **AUTO**     | JPA selects strategy based on DB     | Default              |

---

# **4. What is `@Column` and when do you customize it?**

Maps a field to a DB column.

```java
@Column(name = "emp_name", nullable = false, length = 100)
private String name;
```

You customize when:

* Column name is different
* Setting `nullable`, `unique`, `length`
* Specifying `columnDefinition`

---

# **5. Relationship Annotations Overview**

| Annotation    | Meaning                       |
| ------------- | ----------------------------- |
| `@OneToOne`   | One entity ↔ One entity       |
| `@OneToMany`  | One entity ↔ Many entities    |
| `@ManyToOne`  | Many entities ↔ One entity    |
| `@ManyToMany` | Many entities ↔ Many entities |

Examples:

### One-to-Many (Employee → Tasks)

```java
@OneToMany(mappedBy = "employee")
private List<Task> tasks;
```

### Many-to-One

```java
@ManyToOne
@JoinColumn(name = "employee_id")
private Employee employee;
```

---

# **6. Owning side vs Inverse side (important)**

**Owning side**

* The side that holds the foreign key.
* Writes the join column.

**Inverse (mappedBy) side**

* Read-only side.
* Mapped by owning side field.

Example:

**Owning side** (Task)

```java
@ManyToOne
@JoinColumn(name = "employee_id")  // owning side
private Employee employee;
```

**Inverse side** (Employee)

```java
@OneToMany(mappedBy = "employee")  // inverse side
private List<Task> tasks;
```

---

# **7. Difference between `@JoinColumn` and `@JoinColumns`**

### `@JoinColumn`

* For single-column foreign key.

```java
@JoinColumn(name = "employee_id")
```

### `@JoinColumns`

* For composite foreign keys.

```java
@JoinColumns({
    @JoinColumn(name="order_id", referencedColumnName="id"),
    @JoinColumn(name="order_type", referencedColumnName="type")
})
```

---

# **8. Cascade Type — Explanation of each**

Cascade tells JPA what to do with child entities when parent is persisted/removed.

```java
@OneToMany(cascade = CascadeType.ALL)
```

Cascade Types:

| Type        | Meaning                             |
| ----------- | ----------------------------------- |
| **PERSIST** | When parent saved → child saved     |
| **MERGE**   | Parent merged → child merged        |
| **REMOVE**  | Parent deleted → child deleted      |
| **REFRESH** | Parent refreshed → child refreshed  |
| **DETACH**  | Child detached when parent detached |
| **ALL**     | Applies all above                   |

---

# **9. What is `orphanRemoval`?**

If you remove a child from the collection of a parent, JPA deletes it from the DB.

```java
@OneToMany(mappedBy = "employee", orphanRemoval = true)
private List<Task> tasks;
```

Example:

```java
employee.getTasks().remove(task);
```

→ Task will be automatically deleted in DB.

---

# **10. Difference between Unidirectional & Bidirectional Mapping**

### **Unidirectional**

* Only one side knows the relationship.
* Simpler, fewer joins.

```java
@OneToMany
private List<Task> tasks;
```

### **Bidirectional**

* Both sides know each other.
* Requires `mappedBy`.

```java
@OneToMany(mappedBy="employee")
private List<Task> tasks;

@ManyToOne
private Employee employee;
```

---

# **11. How do you map composite primary keys?**

Two ways:

1. `@EmbeddedId`
2. `@IdClass`

---

# **12. Difference between `@EmbeddedId` and `@IdClass`**

### **@EmbeddedId (Recommended)**

1. Create an embeddable key class:

```java
@Embeddable
public class OrderKey {
    private Long orderId;
    private Long productId;
}
```

2. Use as key:

```java
@Entity
public class Order {
    @EmbeddedId
    private OrderKey id;
}
```

### **@IdClass**

1. Create a key class:

```java
public class OrderKey implements Serializable {
    private Long orderId;
    private Long productId;
}
```

2. Define IDs in entity:

```java
@Entity
@IdClass(OrderKey.class)
public class Order {
    @Id private Long orderId;
    @Id private Long productId;
}
```

**Interview Tip**:
➡ `@EmbeddedId` is cleaner and preferred.

---

# **13. Mapping a Join Table**

Used in many-to-many or unidirectional one-to-many.

Example Many-to-Many:

```java
@ManyToMany
@JoinTable(
    name = "student_course",
    joinColumns = @JoinColumn(name="student_id"),
    inverseJoinColumns = @JoinColumn(name="course_id")
)
private Set<Course> courses;
```

This creates:

```
student_course(student_id, course_id)
```

---

# **14. What is the use of `@MappedSuperclass`?**

Define base properties common to multiple entities, but it does **not** create a table.

```java
@MappedSuperclass
public abstract class BaseEntity {
    private Instant createdAt;
    private Instant updatedAt;
}
```

Used like:

```java
@Entity
public class Employee extends BaseEntity { ... }
```

**Note**: cannot query `BaseEntity`.

---

# **15. Difference between JPA `@Inheritance` strategies**

| Strategy                   | How it stores inheritance                        | Pros         | Cons                                      |
| -------------------------- | ------------------------------------------------ | ------------ | ----------------------------------------- |
| **SINGLE_TABLE** (default) | All classes → 1 table                            | Fast joins   | Wastes space, many NULL columns           |
| **JOINED**                 | Parent in one table, children in separate tables | Normalized   | More joins, slower                        |
| **TABLE_PER_CLASS**        | Each class = its own table                       | Fast queries | No polymorphic queries, duplicate columns |

### Example:

```java
@Entity
@Inheritance(strategy = InheritanceType.JOINED)
public class Payment { ... }
```

Child:

```java
@Entity
public class CreditCardPayment extends Payment { ... }
```

---

# **16. JPA Entity Lifecycle**

Stages:

1. **New / Transient**
   Object created, not yet persisted.

2. **Managed / Persistent**
   EntityManager tracking the object.

3. **Detached**
   EM is closed or entity is removed from context.

4. **Removed**
   Marked for deletion.

5. **Merged**
   Detached entity reattached using `merge()`.

---

# **17. Problems faced while mapping entities in real projects**

Very common interview question. Real-life problems:

### **1. LazyInitializationException**

Occurs when accessing a lazy relationship outside a transaction.

Solution:

* Use `JOIN FETCH` or DTO projection
* Open session in service layer

### **2. Circular references in JSON serialization**

Bidirectional relationships cause infinite recursion.

Solution:

* Use `@JsonManagedReference` and `@JsonBackReference`
* OR use DTOs

### **3. Wrong owning side**

Only owning side updates foreign keys; developers mistakenly update inverse side.

Solution:

* Always set both sides:

```java
employee.addTask(task);
task.setEmployee(employee);
```

### **4. Cascade delete removed required data**

Wrong cascade settings (especially REMOVE).

Solution:

* Use only required cascades.

### **5. Poor performance due to N+1 queries**

Accessing lazy collections triggers N+1 problem.

Solution:

* Use `@EntityGraph`
* `JOIN FETCH` queries

### **6. Composite key mapping issues**

Wrong equals/hashCode causing duplicate entities.

Solution:

* Implement equals/hashCode properly for keys.

### **7. Using EAGER fetching everywhere**

Causes huge unexpected joins and performance issues.

Solution:

* Default to LAZY.

---


