# ‚úÖ **1. What is Lazy Loading in JPA?**

**Lazy loading** means the related data (relationships) is **NOT loaded from the database until it is actually accessed**.

Example:

```java
@OneToMany(mappedBy = "employee", fetch = FetchType.LAZY)
private List<Task> tasks;
```

* `Employee` loads immediately.
* `tasks` loads **only when you call** `employee.getTasks()`.

This improves performance by avoiding unnecessary queries.

---

# ‚úÖ **2. What is Eager Loading?**

**Eager loading** means related data is fetched **immediately** when the parent entity is loaded.

```java
@ManyToOne(fetch = FetchType.EAGER)
private Department department;
```

* When loading Employee ‚Üí Department is also immediately queried.

---

# ‚úÖ **3. Default Fetch Strategies**

| Relationship   | Default Fetch | Reason                              |
| -------------- | ------------- | ----------------------------------- |
| **@ManyToOne** | **EAGER**     | Foreign key exists, easy quick join |
| **@OneToMany** | **LAZY**      | May contain many rows ‚Üí heavy load  |

Example:

```java
@ManyToOne   // by default EAGER
@OneToMany   // by default LAZY
```

---

# ‚úÖ **4. Difference: LazyInitializationException vs Eager behavior**

### **LazyInitializationException**

Occurs when:

* Lazy collection is accessed
* Outside a transaction
* Persistence context is closed

Example error:

```
org.hibernate.LazyInitializationException: could not initialize proxy - no Session
```

### **Eager behavior**

* Data is fetched immediately
* Never throws LazyInitializationException
* But can cause performance issues (N+1 queries, huge joins)

---

# ‚úÖ **5. What is `FetchType.LAZY` and `FetchType.EAGER`?**

### `FetchType.LAZY`

* Delay loading until needed.
* Hibernate loads a **proxy**, not the actual entity.

### `FetchType.EAGER`

* Load immediately.
* Hibernate executes JOIN queries instantly.

---

# ‚úÖ **6. Real project scenario where Lazy loading caused an issue**

**Scenario:**
A REST controller returned Employee entity directly:

```java
@GetMapping("/employees/{id}")
public Employee getEmployee(@PathVariable Long id) {
    return employeeService.find(id);
}
```

Employee has:

```java
@OneToMany(mappedBy="employee", fetch = FetchType.LAZY)
private List<Task> tasks;
```

When serializing JSON, Jackson tries to access `getTasks()`, but:

* Transaction already closed
* Lazy collection not initialized

‚Üí **LazyInitializationException**

---

# ‚úÖ **7. How do you fix LazyInitializationException?**

### ‚úî Option 1 ‚Äî Use `JOIN FETCH` in queries (BEST)

```java
@Query("SELECT e FROM Employee e JOIN FETCH e.tasks WHERE e.id = :id")
Employee findEmployeeWithTasks(Long id);
```

---

### ‚úî Option 2 ‚Äî Use DTO Projection

```java
@Query("SELECT new com.dto.EmployeeDto(e.id, e.name, t.title) 
        FROM Employee e JOIN e.tasks t WHERE e.id=:id")
EmployeeDto getEmployeeDto(Long id);
```

---

### ‚úî Option 3 ‚Äî Use `@EntityGraph`

```java
@EntityGraph(attributePaths = {"tasks"})
Employee findById(Long id);
```

---

### ‚úî Option 4 ‚Äî Open Session in View (NOT recommended)

---

### ‚úî Option 5 ‚Äî Initialize manually

```java
Hibernate.initialize(employee.getTasks());
```

---

# ‚úÖ **8. Difference between JOIN FETCH and default fetch**

### Default Fetch:

Example default LAZY:

```java
employee.getTasks(); 
```

Triggers query later.

### Join Fetch:

```java
SELECT e FROM Employee e JOIN FETCH e.tasks
```

* Loads parent + children in *single query*
* Avoids LazyInitializationException
* Still respects LAZY in entity mapping

---

# ‚úÖ **9. How does Hibernate proxy work in lazy loading?**

Hibernate creates a **proxy class** instead of the real entity.

Example:

```java
Employee employee = session.getReference(Employee.class, 1);
```

`employee` is NOT actual Employee ‚Äî it's a **proxy** with:

* No data initially
* When calling any getter ‚Üí triggers SQL query ‚Üí loads actual object

For collections:

* Uses **PersistentBag**, **PersistentSet**, etc.

---

# ‚úÖ **10. Can you change fetch type at query level without changing annotation?**

YES.

Use:

### ‚úî JOIN FETCH

```java
SELECT e FROM Employee e JOIN FETCH e.tasks
```

### ‚úî EntityGraph

```java
@EntityGraph(attributePaths = "tasks")
Employee findById(Long id);
```

These override annotation fetch type.

---

# ‚úÖ **11. Why is EAGER fetching dangerous in production?**

### 1. Can cause huge JOIN queries

If entity has 5 relationships ‚Üí 5 JOINs.

### 2. Causes **N+1 queries**

Child relationships load EAGERly too.

### 3. Higher server load

More memory, bigger result size.

### 4. Unpredictable behavior

Frameworks may fetch unnecessary relations.

### 5. Serialization storms

REST APIs send too much data unintentionally.

---

# ‚úÖ **12. When should you intentionally use EAGER fetching?**

### Use EAGER only when:

* Relationship is ALWAYS needed
* Cardinality is small (ManyToOne, OneToOne)
* Data is small (small lookup tables)
* You want immediate availability without extra queries

Examples:

* `Employee ‚Üí Department` (small data)
* `Order ‚Üí Status` (enum table)

---

# ‚úÖ **13. Difference between `@EntityGraph` and fetch join**

| Feature                     | EntityGraph       | Fetch Join                     |
| --------------------------- | ----------------- | ------------------------------ |
| Declarative?                | Yes (annotations) | No (JPQL only)                 |
| Reusable?                   | Yes               | No                             |
| Overrides LAZY?             | Yes               | Yes                            |
| Supports pagination?        | YES üëç            | **NO ‚ùå** Causes duplicate rows |
| Cleaner for multiple graphs | Yes               | No                             |
| Used in repository?         | Yes               | Yes                            |

Example ‚Äî EntityGraph:

```java
@EntityGraph(attributePaths = {"tasks"})
Employee findById(Long id);
```

Example ‚Äî Fetch Join:

```java
@Query("SELECT e FROM Employee e JOIN FETCH e.tasks")
```

---

# ‚úÖ **14. What is bytecode enhancement in relation to lazy loading?**

Hibernate can enhance entity classes at build time to:

* Enable **lazy loading of single fields** not just associations
* Detect dirty changes
* Track field-level writes

Example:

```java
@Column @Basic(fetch = FetchType.LAZY)
private byte[] largeImage;
```

Without bytecode enhancement ‚Üí does NOT work.
With enhancement ‚Üí Hibernate loads image lazily.

Tooling:

* Maven Hibernate enhancer plugin

---

# ‚úÖ **15. Best Practices for Lazy Loading in REST APIs**

### ‚úî 1. NEVER return JPA entities directly

‚Üí Use DTOs

### ‚úî 2. Use JOIN FETCH or EntityGraph to fetch needed relations

### ‚úî 3. Avoid EAGER unless required

### ‚úî 4. Use pagination properly to avoid huge loads

### ‚úî 5. Use projection queries for large collections

### ‚úî 6. Avoid Lazy loading in serialization (e.g., Jackson Infinite Recursion)

---

# üéâ Summary (One-Liner Answers)

| Question                    | Short Answer                               |
| --------------------------- | ------------------------------------------ |
| Lazy loading                | Load on access                             |
| Eager loading               | Load immediately                           |
| Default fetch (@ManyToOne)  | EAGER                                      |
| Default fetch (@OneToMany)  | LAZY                                       |
| LazyInitializationException | Lazy field accessed outside session        |
| Fix it                      | JOIN FETCH / DTO / EntityGraph             |
| Hibernate proxy             | Fake class triggers DB load on method call |
| Change fetch at query level | Yes (JOIN FETCH / EntityGraph)             |
| EAGER danger                | Performance issues                         |
| When use EAGER              | Small and always-needed relations          |
| EntityGraph vs fetch join   | EntityGraph supports pagination            |
| Bytecode enhancement        | Enables lazy fields                        |
| Best practices              | DTO + fetch join                           |

---

