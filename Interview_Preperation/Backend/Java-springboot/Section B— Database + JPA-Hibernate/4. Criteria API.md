# ‚úÖ **1. What is Criteria API?**

Criteria API is a **programmatic**, **type-safe**, and **dynamic** way to build queries in JPA.

Instead of writing JPQL as a string:

```java
SELECT e FROM Employee e WHERE e.salary > :salary
```

You build it using objects:

```java
CriteriaBuilder cb = em.getCriteriaBuilder();
CriteriaQuery<Employee> cq = cb.createQuery(Employee.class);
Root<Employee> root = cq.from(Employee.class);
cq.select(root).where(cb.gt(root.get("salary"), 50000));
```

Useful for **dynamic queries**, **complex filtering**, and **runtime query building**.

---

# ‚úÖ **2. Difference between Criteria API and JPQL**

| Feature                  | JPQL         | Criteria API   |
| ------------------------ | ------------ | -------------- |
| Style                    | String-based | Java API-based |
| Type safety              | ‚ùå No         | ‚úÖ Yes          |
| Dynamic queries          | Hard         | Very easy      |
| Readability              | High         | Low            |
| IDE refactoring          | ‚ùå No         | ‚úÖ Yes          |
| SQL injection prevention | Good         | Best           |

---

# ‚úÖ **3. Advantages of Criteria API**

‚úî Type-safe (compile-time checking)
‚úî Best for **dynamic filters**
‚úî No string concatenation
‚úî Refactoring-safe
‚úî Supports complex queries
‚úî Removes risk of syntax errors
‚úî Helps build reusable filters (with Specifications)

Example:

```java
List<Predicate> predicates = new ArrayList<>();
if (search.getName() != null) {
    predicates.add(cb.like(root.get("name"), "%" + search.getName() + "%"));
}
```

---

# ‚úÖ **4. When do you prefer Criteria API over JPQL?**

Use Criteria API when:

* Query conditions are dynamic
* Filters are optional
* You need advanced OR / AND combinations
* Reusable, modular filtering is needed (Specifications)
* Your query conditions depend on user input
* You don't want brittle string-based queries

JPQL is easier when query is fixed.

---

# ‚úÖ **5. What is `CriteriaBuilder`?**

A factory class used to:

* Create Criteria queries
* Create predicates (conditions)
* Create join conditions
* Create sorting
* Create grouping functions

Example:

```java
CriteriaBuilder cb = em.getCriteriaBuilder();
```

---

# ‚úÖ **6. What is `CriteriaQuery`?**

Represents the actual query that will run.

Example:

```java
CriteriaQuery<Employee> cq = cb.createQuery(Employee.class);
```

You build the query using:

* `select()`
* `where()`
* `orderBy()`
* `groupBy()`

---

# ‚úÖ **7. What is `Root` in Criteria API?**

Represents the **FROM** clause (table root).

Example:

```java
Root<Employee> root = cq.from(Employee.class);
```

Used to access fields:

```java
root.get("salary");
root.get("name");
```

---

# ‚úÖ **8. How do you perform dynamic queries using Criteria API?**

Example:

```java
public List<Employee> searchEmployees(EmployeeSearch search) {

    CriteriaBuilder cb = em.getCriteriaBuilder();
    CriteriaQuery<Employee> cq = cb.createQuery(Employee.class);
    Root<Employee> root = cq.from(Employee.class);

    List<Predicate> predicates = new ArrayList<>();

    if (search.getName() != null) {
        predicates.add(cb.like(root.get("name"), "%" + search.getName() + "%"));
    }
    if (search.getMinSalary() != null) {
        predicates.add(cb.greaterThanOrEqualTo(root.get("salary"), search.getMinSalary()));
    }
    if (search.getDepartmentId() != null) {
        predicates.add(cb.equal(root.get("department").get("id"), search.getDepartmentId()));
    }

    cq.where(predicates.toArray(new Predicate[0]));

    return em.createQuery(cq).getResultList();
}
```

This is the standard pattern.

---

# ‚úÖ **9. How do you add predicates dynamically?**

```java
List<Predicate> predicates = new ArrayList<>();

if (name != null) {
    predicates.add(cb.like(root.get("name"), "%" + name + "%"));
}

if (age != null) {
    predicates.add(cb.equal(root.get("age"), age));
}

cq.where(cb.and(predicates.toArray(new Predicate[0])));
```

This allows **infinite combinations** of filters.

---

# ‚úÖ **10. How do you handle joins in Criteria API?**

Example: Join Employee ‚Üí Department

```java
Join<Employee, Department> dept = root.join("department");
predicates.add(cb.equal(dept.get("name"), "HR"));
```

Example: Employee ‚Üí Tasks (OneToMany)

```java
Join<Employee, Task> tasks = root.join("tasks");
predicates.add(cb.equal(tasks.get("status"), "OPEN"));
```

---

# ‚úÖ **11. How do you implement pagination using Criteria API?**

```java
TypedQuery<Employee> query = em.createQuery(cq);
query.setFirstResult(page * size);   // offset
query.setMaxResults(size);           // limit
return query.getResultList();
```

---

# ‚úÖ **12. How do you use Criteria API for complex filtering?**

Example:
Filtering employees by

* name (optional)
* department (optional)
* salary range (optional)
* active flag
* joining date range
* OR conditions

```java
if (filter.getActive() != null) {
    predicates.add(cb.equal(root.get("active"), filter.getActive()));
}

if (filter.getJoinDateFrom() != null && filter.getJoinDateTo() != null) {
    predicates.add(cb.between(root.get("joinDate"),
                             filter.getJoinDateFrom(),
                             filter.getJoinDateTo()));
}

if (filter.isIncludeContractors()) {
    predicates.add(cb.or(
            cb.equal(root.get("type"), "FULLTIME"),
            cb.equal(root.get("type"), "CONTRACT")
    ));
}
```

---

# ‚úÖ **13. What is Specification in Spring Data JPA?**

**Specification** is a wrapper around Criteria API to create reusable and composable filters.

Example Specification:

```java
public class EmployeeSpecs {
    public static Specification<Employee> hasName(String name) {
        return (root, query, cb) ->
            cb.like(root.get("name"), "%" + name + "%");
    }

    public static Specification<Employee> hasMinSalary(double salary) {
        return (root, query, cb) ->
            cb.greaterThanOrEqualTo(root.get("salary"), salary);
    }
}
```

Usage:

```java
employeeRepo.findAll(
   Specification.where(hasName("John"))
                .and(hasMinSalary(50000))
);
```

This is cleaner than raw Criteria.

---

# ‚úÖ **14. Difference between Criteria API and QueryDSL**

| Feature                    | Criteria API | QueryDSL    |
| -------------------------- | ------------ | ----------- |
| Type safety                | Yes          | Yes         |
| Readability                | ‚ùå Low        | ‚≠ê Excellent |
| Fluent API                 | Limited      | Very fluent |
| IDE refactoring            | Good         | Best        |
| Learning curve             | Moderate     | Moderate    |
| Dynamic queries            | Strong       | Stronger    |
| Code volume                | High         | Low         |
| Custom annotations support | No           | Yes         |

QueryDSL example:

```java
QEmployee e = QEmployee.employee;
queryFactory.selectFrom(e)
            .where(e.salary.gt(50000))
            .fetch();
```

Much cleaner than Criteria.

---

# ‚úÖ **15. How did you use Criteria/Specification in your project?**

Here is a strong interview answer:

---

### **Real-world example (Strong answer)**

In my project, we had a **complex search API**:

`GET /employees/search?name=&minSalary=&maxSalary=&departmentId=&status=&joinedFrom=&joinedTo=`

All fields were optional.

I implemented the search using **Spring Data JPA Specifications**.

* Each filter was its own Specification
* They were combined dynamically based on user input

Example:

```java
Specification<Employee> spec = Specification.where(null);

if (search.getName() != null) {
    spec = spec.and(EmployeeSpecs.hasName(search.getName()));
}
if (search.getMinSalary() != null) {
    spec = spec.and(EmployeeSpecs.hasMinSalary(search.getMinSalary()));
}
```

Benefits:

‚úî Very reusable
‚úî Clean code
‚úî No string-based JPQL
‚úî Easily maintained
‚úî Allowed pagination & sorting
‚úî Worked well with joins & nested objects

---

# üéâ **Final Summary (Quick Revision)**

| Question             | Short Answer                                  |
| -------------------- | --------------------------------------------- |
| Criteria API         | Programmatic, type-safe JPA query builder     |
| vs JPQL              | JPQL is string; Criteria is objects           |
| Advantages           | Dynamic, type-safe, refactor-friendly         |
| Prefer Criteria      | Dynamic filters, complex queries              |
| CriteriaBuilder      | Factory to build predicates & queries         |
| CriteriaQuery        | Represents actual query                       |
| Root                 | Represents table in FROM clause               |
| Dynamic queries      | Build predicates in list                      |
| Dynamic predicates   | Add based on conditions                       |
| Joins                | `root.join("field")`                          |
| Pagination           | setFirstResult(), setMaxResults()             |
| Complex filtering    | combine AND/OR predicates                     |
| Specification        | Wrapper around Criteria for reusable filters  |
| QueryDSL vs Criteria | QueryDSL is more readable & fluent            |
| Real usage           | Search APIs with multiple optional filters üåü |

---

