# ‚úÖ **1. What is the N+1 query problem?**

**N+1 query problem** happens when:

* 1 query loads a list of parent entities
* Then **N additional queries** are executed to load each child entity

Total ‚Üí **1 + N SQL queries**

It happens because of **LAZY loading** used without proper fetching.

---

# ‚úÖ **2. Real-world example of N+1 problem**

### Scenario: Load all employees with their tasks

```java
List<Employee> employees = employeeRepository.findAll();
```

Employee class:

```java
@OneToMany(mappedBy = "employee", fetch = FetchType.LAZY)
private List<Task> tasks;
```

Now iterating:

```java
for (Employee e : employees) {
    e.getTasks().size();
}
```

What happens?

### SQL executed:

1. `SELECT * FROM employee;` ‚Üí returns 100 rows
2. Then for each employee:

```
SELECT * FROM task WHERE employee_id = 1;
SELECT * FROM task WHERE employee_id = 2;
...
SELECT * FROM task WHERE employee_id = 100;
```

Total queries = **1 + 100 = 101**

This is the N+1 problem.

---

# ‚úÖ **3. How does N+1 degrade performance?**

* **Massive DB load** (hundreds/thousands of extra queries)
* **Slow response time**
* **High CPU usage**
* **Huge network overhead**
* **Locks, deadlocks, timeouts**

In production, this easily becomes a bottleneck.

---

# ‚úÖ **4. How to identify N+1 issue?**

### ‚úî Method 1 ‚Äî Enable SQL logs

In application.properties:

```properties
spring.jpa.show-sql=true
```

You will notice many repeated queries.

### ‚úî Method 2 ‚Äî Use Hibernate statistics

Enable:

```properties
hibernate.generate_statistics=true
```

### ‚úî Method 3 ‚Äî Profiling tools (Litho, Glowroot, JProfiler)

### ‚úî Method 4 ‚Äî Logs show repeated SELECT statements

### ‚úî Method 5 ‚Äî Slow endpoints with loops accessing lazy collections

---

# ‚úÖ **5. How to solve N+1 using JOIN FETCH?**

Use JPQL join fetch:

```java
@Query("SELECT e FROM Employee e JOIN FETCH e.tasks")
List<Employee> findAllWithTasks();
```

### What this does:

* Loads employees + tasks in **one query**
* Eliminates extra N queries

SQL:

```
SELECT e.*, t.* FROM employee e JOIN task t ON e.id = t.employee_id;
```

---

# ‚úÖ **6. How `@EntityGraph` helps solve N+1**

```java
@EntityGraph(attributePaths = {"tasks"})
@Query("SELECT e FROM Employee e")
List<Employee> findAll();
```

Benefits:

* No need to write JPQL manually
* Cleaner code
* Works in Spring Data JPA
* Supports pagination (better than fetch join)

---

# ‚úÖ **7. Difference between fetch join and normal join**

### ‚úî Normal Join (JPQL)

Does NOT load the relationship

```java
SELECT e FROM Employee e JOIN e.tasks
```

* Returns Employee only
* Tasks still LAZY

### ‚úî Fetch Join

Loads parent + children together (overrides LAZY)

```java
SELECT e FROM Employee e JOIN FETCH e.tasks
```

* Returns Employee
* Tasks loaded eagerly
* Fixes N+1

---

# ‚úÖ **8. How to prevent N+1 in Spring Data JPA repositories?**

### Option 1 ‚Äî Use `@EntityGraph`

```java
@EntityGraph(attributePaths = "tasks")
List<Employee> findAll();
```

### Option 2 ‚Äî Write Fetch Join Queries

```java
@Query("SELECT e FROM Employee e JOIN FETCH e.tasks")
List<Employee> findAllWithTasks();
```

### Option 3 ‚Äî Use projections (DTO)

```java
@Query("SELECT new com.dto.EmployeeDto(e.name, t.title) FROM Employee e JOIN e.tasks t")
```

### Option 4 ‚Äî Use BatchSize

```java
@BatchSize(size = 20)
```

---

# ‚úÖ **9. Tools used to detect N+1 problem**

* **Hibernate statistics**
* **Spring Hibernate logging**
* **P6Spy**
  Shows detailed SQL execution
* **Datasource-proxy**
  Good for analysis
* **Glowroot / New Relic / Datadog**
* **SonarQube rules for N+1**
* **JProfiler / VisualVM**

---

# ‚úÖ **10. What is subselect fetching in Hibernate?**

Hibernate fetches collections using:

### Step 1 ‚Äî Query for employees:

```
SELECT * FROM employee;
```

### Step 2 ‚Äî For all IDs returned above, use a single query for tasks:

```
SELECT * FROM task WHERE employee_id IN (1,2,3,4,...100);
```

This reduces N+1 ‚Üí 1 + 1 queries

Enabled via:

```java
@Fetch(FetchMode.SUBSELECT)
@OneToMany(mappedBy = "employee")
private List<Task> tasks;
```

Useful when:

* You load many parent entities together

---

# ‚úÖ **11. Difference between Batch Fetching and Join Fetching**

| Feature                       | Join Fetch               | Batch Fetch               |
| ----------------------------- | ------------------------ | ------------------------- |
| Query count                   | Always 1                 | Multiple groups (batches) |
| Works with large collections? | NO (cartesian explosion) | YES                       |
| Pagination?                   | NO                       | YES                       |
| Query size                    | Large                    | Smaller                   |
| Usage                         | fix N+1 in small sets    | fix N+1 in large sets     |

---

# ‚úÖ **12. What is Hibernate `@BatchSize`?**

Example:

```java
@BatchSize(size = 20)
@OneToMany(mappedBy = "employee")
private List<Task> tasks;
```

When loading tasks for multiple employees:

* Hibernate loads **20 employees‚Äô tasks** in one query
* Reduces N+1 dramatically
* Works for both collections and entities

---

# ‚úÖ **13. How pagination behaves with fetch join?**

### ‚ùå NOT supported in Hibernate with collections

If you do:

```java
Page<Employee> page = repo.findAllWithTasks(pageable);
```

Hibernate will fail or produce:

* Duplicate rows
* Incorrect page sizes

**Solution:**

* Use `@EntityGraph`
* OR use two queries (first page IDs, then fetch join using IDs)

---

# ‚úÖ **14. Can caching solve N+1 problem?**

Yes and No.

### ‚úî Second level cache:

If child entities are cached ‚Üí fewer SQL queries

But:

### ‚ùå Cache **cannot solve** fundamental N+1 when:

* Relationships not cached
* High-cardinality relationships
* Large lists

Best solution remains: **fetch join / subselect / EntityGraph / BatchSize**.

---

# ‚úÖ **15. Real-world case where you optimized an N+1 problem**

Example project:

### Problem:

API `/employees` took **9 seconds**.

Reason:

* Employees = 500
* Each employee had 10 tasks
* Code accessed tasks lazily:

```
e.getTasks().size()
```

Generated:

* 1 query for employees
* 500 queries for tasks
  **Total: 501 SQL queries**

### Solution:

Add fetch join:

```java
@Query("SELECT e FROM Employee e JOIN FETCH e.tasks")
List<Employee> findAllWithTasks();
```

### Result:

* Reduced from **501 queries ‚Üí 1**
* API response time: **9 seconds ‚Üí 450 ms**

---

# üéØ Final Summary Table

| Topic                      | Quick Answer                       |
| -------------------------- | ---------------------------------- |
| N+1 problem                | 1 parent query + N child queries   |
| Real-world example         | Employees + Tasks loading          |
| Performance impact         | Many SQL queries ‚Üí slow            |
| Detect N+1                 | SQL logs, P6Spy, profiler          |
| Solve N+1                  | JOIN FETCH, EntityGraph, BatchSize |
| EntityGraph                | Override fetch at query level      |
| Fetch join vs join         | Fetch loads children               |
| Prevent in Spring JPA      | EntityGraph / custom queries       |
| Detection tools            | P6Spy, Glowroot, New Relic         |
| Subselect fetching         | 1 + 1 queries                      |
| Batch vs Join              | Batch supports pagination          |
| @BatchSize                 | Loads related entities in batches  |
| Pagination with fetch join | Not supported                      |
| Caching fixes N+1?         | Partially                          |
| Real optimization          | Reduced 501 queries to 1           |

---


