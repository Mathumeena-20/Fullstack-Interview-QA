# 1. Difference Between ArrayList and LinkedList

| Feature                 | ArrayList               | LinkedList                     |
| ----------------------- | ----------------------- | ------------------------------ |
| Data structure          | Dynamic array           | Doubly Linked List             |
| Access time (get)       | **O(1)** fast           | **O(n)** slow                  |
| Insert/delete at end    | **O(1)** amortized      | **O(1)**                       |
| Insert/delete in middle | **O(n)** (shift needed) | **O(1)** (once node found)     |
| Memory usage            | Less                    | More (stores extra pointers)   |
| Best use case           | Access-heavy operations | Insert/delete-heavy operations |

### Example:

```java
List<Integer> list1 = new ArrayList<>();
List<Integer> list2 = new LinkedList<>();
```

### When to use?

* **ArrayList** → frequent reads
* **LinkedList** → frequent insert/remove in middle

---

# 2. When Would You Prefer Vector Over ArrayList?

`Vector` is **synchronized** → **thread-safe**
`ArrayList` is NOT thread-safe.

You prefer Vector when:
✔ Multiple threads modify the list
✔ You need legacy thread-safe list
✔ You cannot migrate to modern collections

But in modern Java:
❌ Avoid `Vector` → use `CopyOnWriteArrayList` or `Collections.synchronizedList()`

### Example:

```java
Vector<Integer> v = new Vector<>();
```

---

# 3. How Does CopyOnWriteArrayList Work?

`CopyOnWriteArrayList` is a **thread-safe** version of ArrayList.

### How it works?

* Every write operation (add/remove) creates a **new copy** of the list.
* Read operations happen on an **immutable snapshot** of the list.
* No need for synchronization during reads.

### Pros:

✔ Extremely fast reads
✔ Safe for concurrent readers
✔ No ConcurrentModificationException

### Cons:

❌ Very expensive writes (copying whole array)
❌ Not suitable for large write-heavy applications

### Example:

```java
CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();
list.add("A");
list.add("B");

for (String s : list) {   // Safe, no locks
    list.add("C");        // No ConcurrentModificationException
}
```

---

# 4. How Does ArrayList Grow Dynamically?

Internally ArrayList stores elements in a **dynamic array**.

### Default capacity: 10

When size exceeds capacity:

* New capacity = old capacity * **1.5** (`newCapacity = old + old/2`)
* A **new array is created**
* Old elements are copied to new array

### Internal logic (simplified):

```java
int newCapacity = oldCapacity + (oldCapacity >> 1); // 1.5x
```

---

# 5. Time Complexity of ArrayList Operations

| Operation           | Time Complexity    | Reason              |
| ------------------- | ------------------ | ------------------- |
| `add(E e)` at end   | **O(1)** amortized | Occasional resize   |
| `add(index, e)`     | **O(n)**           | Shift elements      |
| `remove(index)`     | **O(n)**           | Shift elements left |
| `remove(object)`    | **O(n)**           | Search + shift      |
| `get(index)`        | **O(1)**           | Direct array access |
| `set(index, value)` | **O(1)**           | Direct array access |
| `contains()`        | **O(n)**           | Linear search       |

---

# ✔ Quick Interview Summary

| Question                | Short Answer                                                     |
| ----------------------- | ---------------------------------------------------------------- |
| ArrayList vs LinkedList | ArrayList faster for access; LinkedList faster for insert/delete |
| When prefer Vector?     | Legacy thread-safe use case                                      |
| CopyOnWriteArrayList    | Creates new array on write; great for read-heavy                 |
| ArrayList growth        | Grows 1.5x on overflow                                           |
| Time complexity         | add O(1), get O(1), remove O(n)                                  |

---

