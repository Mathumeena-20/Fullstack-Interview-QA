# **1. Difference between Comparable and Comparator**

| Feature                 | **Comparable**                  | **Comparator**               |
| ----------------------- | ------------------------------- | ---------------------------- |
| Package                 | `java.lang`                     | `java.util`                  |
| Method                  | `compareTo()`                   | `compare()`                  |
| Modifies class?         | ✔ Yes (implements inside class) | ❌ No (external class)        |
| Sorting logic           | Natural ordering                | Custom ordering              |
| Multiple sorting logic? | ❌ No                            | ✔ Yes                        |
| Use case                | Default sorting                 | Different sorting strategies |

---

# **2. When Do You Use Comparable?**

Use Comparable when:
✔ Class has **natural/default sorting**
✔ Sorting is intrinsic to the object
✔ Only one way to sort is needed (e.g., integers, strings)

### Example:

```java
class Student implements Comparable<Student> {
    int marks;
    public int compareTo(Student other) {
        return this.marks - other.marks;
    }
}
```

---

# **3. When Do You Use Comparator?**

Use Comparator when:
✔ You want different sorting strategies
✔ You don’t want to modify the class
✔ Sorting logic must be external
✔ Sorting based on multiple fields

### Example:

```java
Comparator<Student> sortByName = (s1, s2) -> s1.name.compareTo(s2.name);
```

---

# **4. Can a class have multiple Comparator implementations?**

✔ YES
A class can have unlimited comparator implementations.

Example:

```java
Comparator<Employee> byName = Comparator.comparing(Employee::getName);
Comparator<Employee> bySalary = Comparator.comparing(Employee::getSalary);
Comparator<Employee> byAge = Comparator.comparing(Employee::getAge);
```

Used based on requirement.

---

# **5. Why does compareTo() belong to Comparable?**

Because **Comparable defines the natural ordering** of objects.
`compareTo()` is part of the class’s own contract.

### Example:

String, Integer, Double all implement `Comparable`.

`compareTo()` tells:

* how two objects compare
* when current object is "greater" or "smaller"

---

# **6. Can we override compareTo()?**

✔ Yes, you can override it within the same class
✔ As long as you follow Comparable contract

Example:

```java
@Override
public int compareTo(Student o) {
    return Integer.compare(this.id, o.id);
}
```

---

# **7. How does sorting work using Collections.sort()?**

### Works in 2 ways:

### **1) If objects implement Comparable**

```java
Collections.sort(list);  
```

→ uses `compareTo()` for ordering.

---

### **2) If Comparator is provided**

```java
Collections.sort(list, comparator);
```

→ uses `compare()` from comparator.

---

# **8. What happens if compareTo() is inconsistent with equals()?**

If inconsistent, you get:

### ❌ Unpredictable behavior

### ❌ Sets & Maps (TreeSet, TreeMap) may malfunction

### ❌ Duplicate objects may appear

Example (BAD):

```java
// equals checks id, but compareTo checks age
```

### Rule:

If `compareTo(a, b) == 0`, then `a.equals(b)` SHOULD be true
(This is not mandatory but recommended)

---

# **9. What is Stable Sorting?**

A sorting algorithm is **stable** if it preserves the order of equal elements.

### Example:

Two students with same marks should appear in original order.

Java’s **Collections.sort()** and **Stream.sorted()** are **stable** since Java 7 (TimSort).

---

# **10. How Do You Sort Objects Based on Multiple Fields?**

Using Comparator chaining.

### Example:

Sort Employees by:

1. Department
2. Salary DESC
3. Name

```java
employees.sort(
    Comparator.comparing(Employee::getDept)
              .thenComparing(Comparator.comparing(Employee::getSalary).reversed())
              .thenComparing(Employee::getName)
);
```

This is powerful and used widely in real-world sorting.

---

# ⭐ Complete Example: Comparable + Comparator

### Student Class:

```java
class Student implements Comparable<Student> {
    int id;
    String name;
    int marks;

    Student(int id, String name, int marks) {
        this.id = id;
        this.name = name;
        this.marks = marks;
    }

    // Natural sorting by marks
    public int compareTo(Student s) {
        return Integer.compare(this.marks, s.marks);
    }
}
```

### Custom comparators:

```java
Comparator<Student> byName = Comparator.comparing(s -> s.name);
Comparator<Student> byId   = Comparator.comparingInt(s -> s.id);
```

### Usage:

```java
Collections.sort(list);              // natural sort (marks)
Collections.sort(list, byName);      // sort by name
Collections.sort(list, byId);        // sort by id
```

---

# ✅ Final Interview Summary

| Question                 | Short Answer                        |
| ------------------------ | ----------------------------------- |
| Comparable vs Comparator | Natural ordering vs custom ordering |
| Use Comparable           | When class has single default sort  |
| Use Comparator           | When multiple sort logics needed    |
| Multiple Comparator?     | ✔ Yes                               |
| compareTo belongs to?    | Comparable                          |
| Override compareTo?      | ✔ Yes                               |
| Sorting mechanism        | Uses compareTo or comparator        |
| Inconsistent compareTo?  | Causes undefined behavior           |
| Stable sort              | Preserves equal elements order      |
| Multi-field sort         | Comparator chaining                 |

---

