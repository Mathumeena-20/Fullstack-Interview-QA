# **1. What are Buffers and Channels in Java NIO?**

### ✔ **Buffers**

A **Buffer** is a container for data.
All NIO reads/writes happen **via buffers** (not streams).

Example:

```java
ByteBuffer buffer = ByteBuffer.allocate(1024);
```

### ✔ **Channels**

A **Channel** represents a connection to a resource (file, socket, network).
Channels support **reading + writing + asynchronous operations**.

Example:

```java
FileChannel channel = FileChannel.open(path);
```

In NIO:

```
Channel <-> Buffer  (NOT: Stream -> CPU -> Data)
```

---

# **2. Difference between InputStream/OutputStream and Channels**

| Stream API              | Channel API             |
| ----------------------- | ----------------------- |
| Old blocking I/O        | New NIO I/O             |
| One-way: read OR write  | Two-way: read AND write |
| Slow                    | Fast                    |
| No non-blocking support | Supports non-blocking   |
| Reads byte-by-byte      | Reads via buffers       |
| CPU intensive           | Optimized by OS         |

Stream:

```java
InputStream in = new FileInputStream("a.txt");
```

Channel:

```java
FileChannel ch = FileChannel.open(Paths.get("a.txt"));
```

---

# **3. Difference between blocking IO and non-blocking IO**

| Blocking IO                     | Non-blocking IO                       |
| ------------------------------- | ------------------------------------- |
| Thread waits until data arrives | Thread continues if no data           |
| One thread per connection       | One thread handles many connections   |
| Suitable for small apps         | Suitable for high-performance servers |
| Higher latency                  | Low latency                           |
| Stream-based                    | Channel + Selector based              |

Non-blocking IO is **far more scalable**.

---

# **4. Types of buffers in Java NIO**

Java provides typed buffers:

* `ByteBuffer`
* `CharBuffer`
* `IntBuffer`
* `DoubleBuffer`
* `LongBuffer`
* `ShortBuffer`
* `FloatBuffer`
* `MappedByteBuffer`

`ByteBuffer` is the most common (file I/O, network I/O).

Example:

```java
ByteBuffer buf = ByteBuffer.allocate(1024);
```

---

# **5. Difference between HeapBuffer and DirectBuffer**

| HeapBuffer                       | DirectBuffer                          |
| -------------------------------- | ------------------------------------- |
| Allocated on JVM heap            | Allocated outside JVM (native memory) |
| Backed by byte[] array           | No array → OS-level buffer            |
| Faster to create, slower for I/O | Slower to create, faster for I/O      |
| More GC overhead                 | Less GC overhead                      |
| Best for in-memory operations    | Best for file/network operations      |

Example:

```java
ByteBuffer heap = ByteBuffer.allocate(1024);          // Heap buffer
ByteBuffer direct = ByteBuffer.allocateDirect(1024);  // Direct buffer
```

---

# **6. Buffer Properties: capacity, limit, position, mark**

Every Buffer has:

| Property   | Meaning                  |
| ---------- | ------------------------ |
| `capacity` | Total size of buffer     |
| `position` | Next index to read/write |
| `limit`    | Boundary of valid data   |
| `mark`     | Saved position for reset |

Diagram:

```
0         position        limit           capacity
|-----------|----------------|---------------------|
```

Example:

```java
buffer.put((byte)10);  // position = 1
buffer.flip();         // limit = position; position = 0 (for reading)
```

---

# **7. What is a Channel?**

A Channel is a **bi-directional communication link** that supports:

✔ Read
✔ Write
✔ Seek
✔ Async
✔ Non-blocking IO

Think of it as a **modern replacement for Stream**.

---

# **8. Types of Channels in Java NIO**

Most common Channels:

1. **FileChannel**
2. **SocketChannel**
3. **ServerSocketChannel**
4. **DatagramChannel**
5. **SeekableByteChannel**
6. **AsynchronousFileChannel**
7. **AsynchronousSocketChannel**

---

# **9. Difference between ReadableByteChannel and WritableByteChannel**

| ReadableByteChannel | WritableByteChannel |
| ------------------- | ------------------- |
| Reads into buffer   | Writes from buffer  |
| `read(ByteBuffer)`  | `write(ByteBuffer)` |
| Input channel       | Output channel      |

Example:

```java
channel.read(buffer);  // ReadableByteChannel
channel.write(buffer); // WritableByteChannel
```

---

# **10. What is Selector in Java NIO?**

A **Selector** allows **a single thread** to monitor multiple channels.

Works with non-blocking channels.

Example:

```java
Selector selector = Selector.open();
socketChannel.register(selector, SelectionKey.OP_READ);
```

---

# **11. How does Java NIO support multiplexing?**

Using **Selector**:

✔ One thread handles thousands of sockets
✔ OS notifies the selector when a channel is ready
✔ No need for thread-per-connection

Flow:

```
Selector waits -> Channel ready -> Thread processes -> Back to waiting
```

This is called **IO Multiplexing**.

---

# **12. What is zero-copy in Java NIO?**

Zero-copy = data transferred **directly from OS to hardware**
→ without copying into JVM.

Used via:

```java
FileChannel.transferTo()
FileChannel.transferFrom()
```

Example:

```java
source.transferTo(0, source.size(), destChannel);
```

Benefits:
✔ Fast file transfer
✔ Minimal CPU usage
✔ No buffer copying

Used by: Kafka, Netty, Nginx.

---

# **13. FileChannel vs SocketChannel**

### ✔ FileChannel

* For files
* Supports random access
* Supports zero-copy
* Blocking only (unless async channel used)

### ✔ SocketChannel

* For network sockets
* Supports non-blocking mode
* Works with Selector
* Used for scalable servers

---

# **14. How does non-blocking IO improve performance in servers?**

✔ One thread handles thousands of connections
✔ No blocking on read/write
✔ Less context switching
✔ Better CPU utilization
✔ Less memory usage
✔ Highly scalable (used in Netty, asyncio, Node.js)

Example scenario:

* Chat server
* Websocket server
* Game server

These require non-blocking IO.

---

# **15. Real-world use of NIO in high-performance applications**

### Here are real-world systems using NIO:

✔ **Apache Kafka** − uses zero-copy + NIO for high throughput
✔ **Netty** − asynchronous NIO framework used by many microservices
✔ **Elasticsearch** − uses NIO for network transport
✔ **Akka** − actor-based concurrency system
✔ **Tomcat / Jetty** − asynchronous non-blocking HTTP connectors

### Example project scenario:

We used Java NIO for a **stock trading system**:

* 50,000+ concurrent websocket users
* Non-blocking SocketChannel
* Selector-based event loop
* ByteBuffer for parsing data
* Zero-copy FileChannel.transferTo() for logs

This reduced CPU usage by **40%** and increased throughput significantly.

---

# ⭐ Code Example: Reading a File with FileChannel + ByteBuffer

```java
Path path = Paths.get("data.txt");

try (FileChannel ch = FileChannel.open(path)) {
    ByteBuffer buf = ByteBuffer.allocate(1024);
    while (ch.read(buf) > 0) {
        buf.flip();
        System.out.println(new String(buf.array(), 0, buf.limit()));
        buf.clear();
    }
}
```

---

# ⭐ Final Interview Summary

| Topic                        | Key Points                               |
| ---------------------------- | ---------------------------------------- |
| Buffers                      | Containers for data                      |
| Channels                     | Bi-directional, high-performance I/O     |
| Blocking vs non-blocking     | Non-blocking handles many clients        |
| Buffer types                 | ByteBuffer, CharBuffer, etc.             |
| Heap vs Direct Buffer        | Direct is faster for I/O                 |
| Buffer properties            | position, limit, capacity, mark          |
| Channels types               | FileChannel, SocketChannel, etc.         |
| Selector                     | Multiplexing: one thread → many channels |
| Zero-copy                    | FileChannel.transferTo(), transferFrom() |
| FileChannel vs SocketChannel | File = disk I/O, Socket = network I/O    |
| Non-blocking IO benefits     | Scalable servers, fewer threads          |
| Real-world usage             | Kafka, Netty, trading systems            |

---

