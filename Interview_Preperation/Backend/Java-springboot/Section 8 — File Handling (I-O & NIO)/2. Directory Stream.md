# **1. What is DirectoryStream in Java?**

`DirectoryStream<Path>` is a Java NIO interface used to **iterate through directory contents lazily**, retrieving files **one-by-one** instead of loading all at once.

Example:

```java
try (DirectoryStream<Path> stream = Files.newDirectoryStream(Paths.get("logs"))) {
    for (Path file : stream) {
        System.out.println(file);
    }
}
```

✔ Memory efficient
✔ Avoids loading entire directory into RAM

---

# **2. Difference between DirectoryStream and File.listFiles()**

| Feature                 | DirectoryStream             | File.listFiles()         |
| ----------------------- | --------------------------- | ------------------------ |
| Memory usage            | ✔ Lazy (one file at a time) | ❌ Loads all file objects |
| Suitable for large dirs | ✔ Yes                       | ❌ No, may cause OOM      |
| API                     | NIO                         | Legacy IO                |
| Filtering               | Built-in filter support     | Must filter manually     |
| Returns                 | Iterable<Path>              | File[]                   |

---

# **3. How is DirectoryStream more memory efficient?**

DirectoryStream does **lazy loading**:

✔ Reads only **one entry at a time** from the OS
✔ No need to create large arrays (`File[]`)
✔ Works well for directories with **thousands/millions of files**

Whereas:

```java
File[] files = dir.listFiles();
```

loads *all* files into memory → heavy, slow, risky.

---

# **4. What is DirectoryStream.Filter?**

A functional interface used to filter directory entries.

```java
DirectoryStream.Filter<Path> filter = 
    entry -> Files.isRegularFile(entry);
```

---

# **5. How do you filter files using DirectoryStream?**

Example: list only “*.txt” files.

```java
Path dir = Paths.get("data");
DirectoryStream.Filter<Path> filter = 
    entry -> entry.toString().endsWith(".txt");

try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir, filter)) {
    for (Path p : stream) {
        System.out.println(p);
    }
}
```

You can also use glob patterns:

```java
Files.newDirectoryStream(dir, "*.txt");
```

---

# **6. Can DirectoryStream handle very large directories?**

✔ **Yes.**
Designed specifically for large directory traversal.

Why?

* It does **not** load all file names at once
* It reads entries **as you iterate**

Used in:

* Log directories
* FTP servers
* Photo/video storage folders

---

# **7. What is the use of Files.newDirectoryStream()?**

It creates a `DirectoryStream<Path>` instance.

### Examples:

```java
Files.newDirectoryStream(path);             // all entries
Files.newDirectoryStream(path, "*.csv");    // glob filtering
Files.newDirectoryStream(path, filter);     // custom filter
```

---

# **8. Difference between DirectoryStream and Stream<Path>?**

| Feature        | DirectoryStream           | Stream<Path>               |
| -------------- | ------------------------- | -------------------------- |
| Lazy iteration | ✔ Yes                     | ✔ Yes                      |
| Memory usage   | ✔ Very efficient          | Good                       |
| Auto-close     | ✔ With try-with-resources | ✔ With try-with-resources  |
| Filtering      | Through filter            | Through Stream API         |
| Risk           | Minimal                   | Slightly more overhead     |
| When to use?   | Very large dirs           | Need functional operations |

Example of Stream<Path>:

```java
try (Stream<Path> s = Files.list(dir)) {
    s.filter(Files::isRegularFile).forEach(System.out::println);
}
```

---

# **9. How does lazy loading work in DirectoryStream?**

✔ It opens a **directory handle** in the OS
✔ Each iteration fetches **one entry**
✔ No preloading or caching
✔ Closes directory handle on exit

This is why DirectoryStream never memory-overflows.

---

# **10. What happens if the directory content changes during iteration?**

Behavior depends on OS:

* Most OSes allow the stream to continue
* New files might not appear during iteration
* Deleted files may cause iteration to skip them
* DirectoryStream does **not** guarantee snapshot consistency

Rule:
**DirectoryStream is not fail-safe.**

---

# **11. How do you manage exceptions while using DirectoryStream?**

Wrap inside *try-with-resources*:

```java
try (DirectoryStream<Path> stream = Files.newDirectoryStream(path)) {
    for (Path p : stream) {
        System.out.println(p);
    }
} catch (IOException e) {
    e.printStackTrace();
}
```

✔ Automatically closes the DirectoryStream
✔ Handles IOExceptions cleanly

---

# **12. Is DirectoryStream thread-safe?**

❌ **No.**

Reasons:

* Underlying directory handle cannot be shared safely
* Multiple threads reading same stream → unpredictable behavior

If needed → wrap inside synchronized block or give separate streams.

---

# **13. How do you close DirectoryStream resources?**

✔ Always use try-with-resources:

```java
try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir)) {
    ...
}
```

Because:

* If not closed → OS handle leak
* Long-running applications may run out of handles

---

# **14. How to scan directories recursively?**

### Method 1: Using Files.walk() (recommended)

```java
Files.walk(Paths.get("root"))
     .filter(Files::isRegularFile)
     .forEach(System.out::println);
```

### Method 2: Manual recursion with DirectoryStream

```java
static void scan(Path dir) throws IOException {
    try (DirectoryStream<Path> stream = Files.newDirectoryStream(dir)) {
        for (Path p : stream) {
            if (Files.isDirectory(p)) {
                scan(p);
            } else {
                System.out.println(p);
            }
        }
    }
}
```

---

# **15. Where did you use DirectoryStream in a real project?**

### **Real-World Scenario: Log Processing Microservice**

We built a service that:

* Monitored `/var/log/app/`
* Folder contained **millions of small log files** daily
* `File.listFiles()` caused:
  ❌ OutOfMemoryError
  ❌ Very slow performance

Switched to DirectoryStream:

✔ No memory overflow
✔ Iterated logs efficiently
✔ Close to native OS performance
✔ Supported filtering:

```java
Files.newDirectoryStream(logDir, "*.log")
```

This change reduced memory usage from **1.2 GB → 200 MB**.

---

# ⭐ Final Interview Summary Table

| Question                           | Short Answer                                      |
| ---------------------------------- | ------------------------------------------------- |
| DirectoryStream                    | Lazy iterator for directory contents              |
| vs listFiles                       | ListFiles loads all at once; DirectoryStream lazy |
| Memory efficient                   | Only loads one entry at a time                    |
| DirectoryStream.Filter             | Filters entries during iteration                  |
| Filtering                          | Custom filter or glob pattern                     |
| Large directories                  | Excellent performance                             |
| Files.newDirectoryStream           | Factory method                                    |
| vs Stream<Path>                    | DirectoryStream → ultra-low memory                |
| Lazy loading                       | Fetches entries on demand                         |
| Directory changes during iteration | Not consistent                                    |
| Thread-safe?                       | No                                                |
| Closing                            | Use try-with-resources                            |
| Recursive scan                     | Files.walk or recursion                           |
| Real use case                      | Large directory scanning/log parsing              |

---

