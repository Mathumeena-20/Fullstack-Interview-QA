# **1. What is the Java NIO Files API?**

Java NIO (New I/O) `Files` API (in `java.nio.file.Files`) provides:

✔ Faster, modern file handling
✔ Support for paths, symbolic links, attributes
✔ Atomic operations (safe update/delete)
✔ Support for streams, channels, buffers
✔ Better error reporting

Introduced in **Java 7** as part of NIO.2.

---

# **2. Difference between `Files` and `File` class**

| Feature                   | `File` (Old I/O)       | `Files` + `Path` (NIO)               |
| ------------------------- | ---------------------- | ------------------------------------ |
| Introduced                | Java 1.0               | Java 7                               |
| Thread-safety             | Not consistent         | Better                               |
| Operating system features | Limited                | Supports symbolic links, permissions |
| Exceptions                | Returns boolean (poor) | Throws meaningful exceptions         |
| Copy/move operations      | Manual code            | `Files.copy()`, `Files.move()`       |
| File attributes           | Limited                | POSIX, DOS attributes                |
| Performance               | Slower                 | Faster, buffers/channels             |

Example:

```java
File f = new File("a.txt");
Path p = Paths.get("a.txt");
```

---

# **3. How do you read a file using Files.readAllLines()?**

```java
Path path = Paths.get("data.txt");

List<String> lines = Files.readAllLines(path);

for (String line : lines) {
    System.out.println(line);
}
```

✔ Returns all lines as List<String>
✔ For small/medium files
❌ Not recommended for very large files

---

# **4. Difference between `Paths.get()` and `File`**

`Paths.get("a.txt")` → returns a **Path object**
`new File("a.txt")` → returns a **File object**

✔ `Path` is modern, flexible
✔ Works with `Files` API
✔ Supports symbolic links, normalized paths

Example:

```java
Path p = Paths.get("folder", "a.txt");
```

---

# **5. How do you write data to a file using Files class?**

### Write a string:

```java
Files.write(Paths.get("out.txt"), "Hello".getBytes());
```

### Write list of lines:

```java
List<String> data = List.of("A", "B", "C");
Files.write(Paths.get("out.txt"), data);
```

### With options:

```java
Files.write(Paths.get("log.txt"),
            "More data".getBytes(),
            StandardOpenOption.APPEND);
```

---

# **6. What is Path interface?**

`Path` represents:

✔ A platform-independent file path
✔ A sequence of directories + filename
✔ Immutable
✔ Works with Files API

Example methods:

```java
path.getFileName();
path.getParent();
path.toAbsolutePath();
```

---

# **7. How do you check if a file exists using NIO?**

```java
Path path = Paths.get("data.txt");
boolean exists = Files.exists(path);
```

Or:

```java
Files.notExists(path);
```

---

# **8. How to copy, move and delete files using Files API?**

### ✔ Copy

```java
Files.copy(sourcePath, destPath, StandardCopyOption.REPLACE_EXISTING);
```

### ✔ Move

```java
Files.move(oldPath, newPath, StandardCopyOption.REPLACE_EXISTING);
```

### ✔ Delete

```java
Files.delete(path);          // throws exception if not exist
Files.deleteIfExists(path);  // safe version
```

---

# **9. How do you get file attributes using Files?**

### Basic attributes:

```java
Path p = Paths.get("data.txt");
BasicFileAttributes attrs = Files.readAttributes(p, BasicFileAttributes.class);

System.out.println(attrs.size());
System.out.println(attrs.creationTime());
System.out.println(attrs.lastModifiedTime());
```

### POSIX attributes (Linux/Unix):

```java
PosixFileAttributes posix = Files.readAttributes(p, PosixFileAttributes.class);
```

### DOS attributes (Windows):

```java
DosFileAttributes dos = Files.readAttributes(p, DosFileAttributes.class);
```

---

# **10. Explain StandardOpenOption with examples**

Used for customizing file operations.

| Option            | Meaning                |
| ----------------- | ---------------------- |
| CREATE            | Creates file if absent |
| CREATE_NEW        | Fails if file exists   |
| APPEND            | Writes at end of file  |
| TRUNCATE_EXISTING | Clears file            |
| WRITE             | Enable write           |
| READ              | Enable read            |

Example:

```java
Files.write(Paths.get("log.txt"),
            "message".getBytes(),
            StandardOpenOption.CREATE,
            StandardOpenOption.APPEND);
```

---

# **11. Difference between blocking IO and non-blocking IO**

| Feature         | Blocking IO                | Non-Blocking IO (NIO)        |
| --------------- | -------------------------- | ---------------------------- |
| Thread behavior | Thread waits (blocks)      | Thread continues             |
| Performance     | Slow when many connections | High-performance             |
| Used in         | Simple applications        | Servers, NIO channels        |
| API             | InputStream, Reader        | Channels, Selectors, Buffers |
| Scalability     | Poor                       | Excellent                    |

Example:

* Blocking: `FileInputStream.read()`
* Non-blocking: `FileChannel.read()` + `Selector`

---

# **12. How do you create temporary files and directories?**

### Temp file:

```java
Path temp = Files.createTempFile("prefix_", ".txt");
```

### Temp directory:

```java
Path tempDir = Files.createTempDirectory("myTempDir");
```

✔ OS automatically manages temporary folders

---

# **13. What is an atomic file operation?**

Atomic = **operation fully completes or fully fails** (no partial result).

Files API supports atomic operations like:

```java
Files.move(source, target, StandardCopyOption.ATOMIC_MOVE);
```

Useful for:

* Log rotation
* Safe file updates
* Avoid partial writes after crashes

---

# **14. How do you read large files efficiently using Files?**

Use **BufferedReader** or **Stream API**, not readAllLines.

### Using BufferedReader:

```java
try (BufferedReader br = Files.newBufferedReader(Paths.get("big.txt"))) {
    String line;
    while ((line = br.readLine()) != null) {
        System.out.println(line);
    }
}
```

### Using Streams:

```java
Files.lines(Paths.get("big.txt"))
     .forEach(System.out::println);
```

✔ Streams process line-by-line
✔ Lower memory usage
✔ Efficient for multi-GB files

---

# **15. Real-time use case where NIO Files preferred over traditional IO**

### Use Case: Microservice reading logs or importing CSV data

Reason to use NIO:

✔ Faster than `java.io`
✔ Supports `Files.lines()` for large files
✔ Easy file monitoring using WatchService
✔ Better error handling
✔ Easy file copying/moving/deleting
✔ POSIX permissions needed in cloud deployments

Example:

```java
Files.copy(Paths.get("/data/input.csv"),
           Paths.get("/backup/input.csv"),
           StandardCopyOption.REPLACE_EXISTING);
```

This is much cleaner than old IO copy loops.

---

# ⭐ Final Interview Summary Table

| Question                    | Answer                                     |
| --------------------------- | ------------------------------------------ |
| Java NIO Files API          | Modern, fast, feature-rich file system API |
| Files vs File               | Files+Path > File                          |
| readAllLines                | Returns List<String>                       |
| Paths.get vs File           | Path = modern; File = legacy               |
| Write file                  | Files.write                                |
| Path interface              | Represents file path                       |
| Check exists                | Files.exists                               |
| Copy/move/delete            | Files.copy / move / delete                 |
| File attributes             | BasicFileAttributes etc.                   |
| StandardOpenOption          | APPEND, CREATE, WRITE, etc.                |
| Blocking vs non-blocking IO | Thread blocking vs scalable NIO            |
| Temp files                  | Files.createTempFile                       |
| Atomic operations           | ATOMIC_MOVE                                |
| Read large files            | Streams, newBufferedReader                 |
| Real use case               | Log reading, CSV processing, cloud apps    |

---

