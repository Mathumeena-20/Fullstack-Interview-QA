# **1. Difference between Heap memory and Stack memory**

| Feature       | **Heap**                    | **Stack**                                   |
| ------------- | --------------------------- | ------------------------------------------- |
| Stores        | Objects, instance variables | Method calls, local variables, references   |
| Allocation    | Dynamic (runtime)           | Automatic (per method call)                 |
| Access speed  | Slower                      | Faster                                      |
| Managed by    | Garbage Collector           | JVM per-thread stack                        |
| Lifetime      | Until GC removes object     | Until method finishes                       |
| Thread Safety | Shared across threads       | Each thread has its own stack (thread-safe) |
| Capacity      | Large                       | Smaller, limited                            |

---

# **2. What kind of data is stored in Stack vs Heap?**

### ✔ Stack stores:

* Local variables
* Method parameters
* Return addresses
* References to objects in heap
* Method call frames (stack frames)

### ✔ Heap stores:

* Objects
* Arrays
* Instance variables
* Static class variables (metaspace/permgen for class info)

---

# **3. Why is Stack memory faster than Heap?**

Stack memory is faster because:

* It uses **LIFO (Last-In-First-Out)** ordering
* JVM just *moves a pointer up/down*
* No complex memory lookup
* No need for Garbage Collection

Heap requires:

* Searching for free space
* Possible fragmentation
* Garbage collection

Hence heap access is slower.

---

# **4. What is Stack Overflow and Heap Overflow?**

### **Stack Overflow**

Happens when stack memory is exhausted.

Caused by:

* Deep or infinite recursion
* Excessively large local variables

```java
public void recurse() {
    recurse(); // infinite recursion → StackOverflowError
}
```

### **Heap Overflow / OutOfMemoryError**

Heap memory is full and GC cannot free enough space.

Example:

```java
List<int[]> list = new ArrayList<>();
while (true) list.add(new int[100000]); // OutOfMemoryError: Java heap space
```

---

# **5. How does JVM manage Stack memory per thread?**

* **Each thread gets its own Stack.**
* Stack grows/shrinks with method calls.
* When a new method is called → JVM pushes a **stack frame**.
* When method ends → frame is popped.

This is why stack is **thread-safe by design**.

---

# **6. Where are instance variables stored?**

✔ Instance variables belong to objects → stored in **Heap**.

Example:

```java
class Person {
    int age;         // instance variable → heap
    String name;     // stored in heap
}
```

---

# **7. Where are local variables and method calls stored?**

✔ Local variables → **Stack**

Example:

```java
void test() {
    int x = 10;  // local → stack
    Person p = new Person();  // reference "p" on stack, object on heap
}
```

✔ Method call details (stack frame) also stored on stack.

---

# **8. How does memory allocation happen in Stack vs Heap?**

### **Stack allocation:**

* Happens automatically during method calls
* Very fast → pointer increments

### **Heap allocation:**

* Objects created with `new`
* Allocated by memory manager
* Objects live until garbage collected

Example:

```java
int x = 10;         // stack
Person p = new Person(); // p (ref) in stack, object in heap
```

---

# **9. What is the lifetime of objects stored in Heap?**

Heap objects live until:

✔ No reference points to them
✔ Garbage Collector removes them

Lifetime can be:

* Short-lived (young generation)
* Long-lived (old generation)

Objects **may outlive the method or thread** that created them.

---

# **10. How does Stack memory help in thread safety?**

* Each thread has **its own stack**, not shared
* Local variables in one thread cannot be accessed by another
* Prevents data races automatically

Example:

```java
Thread t1 = new Thread(() -> {
    int x = 5;  // thread-private variable
});

Thread t2 = new Thread(() -> {
    int x = 10; // separate variable for this thread
});
```

No conflict = thread-safe.

Heap is **shared**, so objects need synchronization.

---

# ⭐ Example: Memory Layout Summary

```java
class Car {
    int speed = 100;         // heap
}

void drive() {
    Car c = new Car();       // c (reference) → stack
    int distance = 50;       // stack
    // Car object → heap
}
```

### Stack

```
drive() stack frame:
  c → reference to Car object
  distance = 50
```

### Heap

```
Car object:
  speed = 100
```

---

# ⭐ Final Interview Summary

| Question                 | Short Answer                                   |
| ------------------------ | ---------------------------------------------- |
| Heap vs Stack            | Heap = objects; Stack = method frames & locals |
| What stored in Stack     | Local vars, method calls, references           |
| What stored in Heap      | Objects & instance variables                   |
| Why stack faster         | Simple pointer push/pop                        |
| Stack overflow           | Too deep recursion                             |
| Heap overflow            | OutOfMemoryError (excessive object creation)   |
| Stack per thread         | JVM creates separate stack → thread-safe       |
| Lifetime of heap objects | Until GC removes them                          |
| Memory allocation        | Stack = automatic; Heap = managed by GC        |
| Thread safety            | Stack is thread-private                        |

---

