# **1. What is Garbage Collection in Java?**

Garbage Collection (GC) is the **automatic memory management** process in JVM.

It:

✔ Frees memory by removing unreachable objects
✔ Prevents memory leaks
✔ Keeps heap clean
✔ Runs automatically (no need for `free()` like C/C++)

GC decides what objects are no longer used and reclaims their memory.

---

# **2. Difference between Minor GC and Major GC**

| Feature        | **Minor GC**     | **Major GC**                 |
| -------------- | ---------------- | ---------------------------- |
| Affects        | Young Generation | Old Generation               |
| Pause time     | Short            | Longer pauses                |
| Frequency      | Frequent         | Less frequent                |
| Cost           | Cheap            | Expensive                    |
| Triggered when | Eden space fills | Old Gen fills                |
| Also called    | Young GC         | Old GC / Full GC (sometimes) |

---

# **3. What is Young Generation and Old Generation?**

JVM heap is divided into:

### ⭐ **Young Generation**

* Newly created objects
* Contains **Eden + Survivor spaces**
* Frequent GC → *Minor GC*

### ⭐ **Old Generation**

* Long-lived objects
* Objects that survived several Minor GCs
* Less frequent GC → *Major/Full GC*

Most objects **die young**, so GC in Young Gen is efficient.

---

# **4. What are Eden, Survivor S0 and S1 Spaces?**

Young Gen is divided into:

### ✔ **Eden**

* New objects allocated here
* Most objects die here

### ✔ **Survivor Spaces (S0, S1)**

* Two survivor spaces (S0 and S1)
* Only one is used at a time
* Objects copied between them on each Minor GC

### Memory flow:

```
Eden → S0 → S1 → Old Generation
```

---

# **5. What is a Stop-The-World (STW) event?**

A **Stop-The-World** event pauses *all application threads* so GC can run safely.

During STW:

* No user code runs
* Only GC thread runs

All GC algorithms have some form of STW,
though modern collectors (G1, ZGC) reduce pause times drastically.

---

# **6. How do objects move from Young Gen to Old Gen?**

Object moves to Old Gen when:

### ✔ 1. Object survives multiple Minor GCs

Each object has an **age**, and surviving multiple GCs increases age.
Default threshold ≈ 15 GC cycles.

### ✔ 2. Survivor space is full

* Object is directly promoted to Old Gen.

### ✔ 3. Large objects (arrays, huge objects)

* May be allocated directly in Old Gen.

---

# **7. What is GC Root?**

GC Roots are special references used as **starting points** for reachability.

JVM checks which objects are reachable **from GC Roots**.

### GC Roots include:

* Local variables in **stack**
* Active threads
* Static variables
* JNI references
* System classloader references

If an object is **not reachable from GC Roots**, it is garbage.

---

# **8. How does JVM identify garbage objects?**

JVM uses **reachability analysis** (not reference counting).

### Process:

1. Start from **GC Roots**
2. Traverse all reachable objects
3. Mark reachable objects
4. Unmarked objects = **garbage**
5. GC removes them

This avoids circular dependency issues.

---

# **9. What is Full GC and when does it happen?**

### **Full GC = Cleaning both Young Gen + Old Gen + Metaspace**

Full GC is the **most expensive** type of GC → long pause.

### Triggered when:

* Old Gen is full
* Metaspace is full
* System.gc() called
* Promotion failure (when object cannot fit in Old Gen)
* Allocation failure

Avoid frequent Full GCs → bad for performance.

---

# **10. Types of GC Algorithms (Basics)**

Below is the **Java GC family**:

---

## ⭐ **1. Serial GC**

* Single-threaded GC
* STW for entire GC
* Good for small applications
* Not suitable for multi-core servers

Use:

```
-XX:+UseSerialGC
```

---

## ⭐ **2. Parallel GC (Throughput Collector)**

* Uses **multiple threads** for GC
* Best throughput
* Larger pause times than CMS/G1
* Default in many JVMs before Java 9

Use:

```
-XX:+UseParallelGC
```

---

## ⭐ **3. CMS (Concurrent Mark Sweep)** *(Deprecated)*

* Minimizes pause time
* Does most work concurrently
* Used before G1 was introduced
* More CPU usage
* Fragmentation issues

---

## ⭐ **4. G1 GC (Garbage First)**

* Default GC since Java 9
* Region-based heap
* Predictable low pauses
* Concurrent marking + evacuation
* Good for large heaps (multi-GB)

Use:

```
-XX:+UseG1GC
```

---

## ⭐ **5. ZGC (Z Garbage Collector)**

* Ultra-low pause GC
* Pause times < 10 ms
* Works on multi-terabyte heaps
* Mostly concurrent
* Very modern, best for microservices

Use:

```
-XX:+UseZGC
```

---

# ⭐ Example: Object flow simulation

### Step-by-step:

```java
public void test() {
    Person p = new Person();   // Allocated in Eden
} // p reference disappears → object eligible for GC
```

### GC Flow:

1. Object created in Eden
2. Minor GC occurs → object moves to S0
3. Next GC → moves to S1
4. After multiple moves → promoted to Old Gen
5. When no reference → collected by GC

---

# ⭐ Final Interview Summary

| Topic                | Explanation                            |
| -------------------- | -------------------------------------- |
| Garbage Collection   | Automatic cleanup of unused objects    |
| Minor vs Major GC    | Young Gen GC vs Old Gen GC             |
| Young vs Old Gen     | New objects vs long-lived objects      |
| Eden / S0 / S1       | Lifecycle of new objects               |
| Stop-the-World       | JVM pauses all threads for GC          |
| Promotion            | Object moves Eden → Survivor → Old Gen |
| GC Root              | Starting reference for reachability    |
| How GC finds garbage | Reachability analysis                  |
| Full GC              | Cleans entire heap — expensive         |
| GC algorithms        | Serial, Parallel, CMS, G1, ZGC         |

---
