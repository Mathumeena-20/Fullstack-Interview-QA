# **1. Difference between HashMap and ConcurrentHashMap**

| Feature        | **HashMap**          | **ConcurrentHashMap**               |
| -------------- | -------------------- | ----------------------------------- |
| Thread safety  | ❌ Not thread-safe    | ✔ Thread-safe                       |
| Null key/value | ✔ Allowed            | ❌ Not allowed                       |
| Iterator       | Fail-fast            | Fail-safe                           |
| Locking        | No locking           | Fine-grained locking (bucket-level) |
| Performance    | Fast (single-thread) | Fast (multi-thread)                 |
| Used in        | Single-thread        | Multi-thread, high concurrency      |

### Example:

```java
Map<String, Integer> map1 = new HashMap<>();
Map<String, Integer> map2 = new ConcurrentHashMap<>();
```

---

# **2. What are concurrent collections in Java?**

Collections designed for **multi-threading** with **thread safety + high performance**.

Examples:

### ✔ Maps

* ConcurrentHashMap
* ConcurrentSkipListMap

### ✔ Lists

* CopyOnWriteArrayList

### ✔ Sets

* ConcurrentSkipListSet
* CopyOnWriteArraySet

### ✔ Queues

* BlockingQueue
* ConcurrentLinkedQueue
* LinkedBlockingQueue
* ArrayBlockingQueue

They avoid global locks and prevent `ConcurrentModificationException`.

---

# **3. Difference between CopyOnWriteArrayList and Collections.synchronizedList()**

| Feature              | CopyOnWriteArrayList       | synchronizedList()       |
| -------------------- | -------------------------- | ------------------------ |
| Thread safety        | Lock-free for reads        | Full lock for read/write |
| Read performance     | ✔ Very fast                | ❌ Slower                 |
| Write performance    | ❌ Expensive (creates copy) | Moderate                 |
| Concurrent iteration | No CME                     | Still synchronized       |
| Use case             | Read-heavy                 | Balanced read/write      |

### Example:

```java
List<String> list1 = new CopyOnWriteArrayList<>();
List<String> list2 = Collections.synchronizedList(new ArrayList<>());
```

---

# **4. When should you use BlockingQueue?**

Use **BlockingQueue** when you need:

✔ Producer–consumer pattern
✔ Automatic thread blocking and waking
✔ Thread-safe queue without manual synchronization
✔ Bounded queues to apply back-pressure

Producer waits when queue is **full**,
Consumer waits when queue is **empty**.

---

# **5. Types of BlockingQueue**

### **1. LinkedBlockingQueue**

✔ Unbounded (or large) queue
✔ Used in thread pools

### **2. ArrayBlockingQueue**

✔ Bounded
✔ Faster fixed-size queue

### **3. SynchronousQueue**

✔ No capacity → direct handoff
✔ Used in cached thread pools

### **4. PriorityBlockingQueue**

✔ Orders elements by priority

### **5. DelayQueue**

✔ Elements become available after delay
✔ Used in scheduled tasks

---

# **6. Producer–Consumer Using BlockingQueue**

### Example:

```java
BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(5);

// Producer
new Thread(() -> {
    try {
        for (int i = 1; i <= 10; i++) {
            queue.put(i);
            System.out.println("Produced " + i);
        }
    } catch (Exception e) {}
}).start();

// Consumer
new Thread(() -> {
    try {
        while (true) {
            Integer val = queue.take();
            System.out.println("Consumed " + val);
        }
    } catch (Exception e) {}
}).start();
```

✔ No need for synchronized
✔ No need for wait()/notify()

---

# **7. What is Skip List?**

A **Skip List** is a data structure that:

✔ Allows O(log n) insertion, deletion, and search
✔ Has multiple linked lists layered on top of each other
✔ Used in **ConcurrentSkipListMap** and **ConcurrentSkipListSet**

It is a concurrent-friendly alternative to Red-Black Trees.

---

# **8. Difference between ConcurrentSkipListMap and TreeMap**

| Feature        | TreeMap        | ConcurrentSkipListMap               |
| -------------- | -------------- | ----------------------------------- |
| Thread-safe    | ❌ No           | ✔ Yes                               |
| Null keys?     | ❌ No           | ❌ No                                |
| Performance    | O(log n)       | O(log n), optimized for concurrency |
| Data structure | Red-Black Tree | Skip List                           |
| Iterator       | Fail-fast      | Fail-safe                           |
| Use case       | Single-thread  | Multi-thread sorted map             |

---

# **9. How do concurrent collections avoid locking issues?**

### Techniques used:

### ✔ Fine-grained locking

* Lock only a small portion (bucket), not entire structure
* Example: ConcurrentHashMap

### ✔ Lock-free algorithms (CAS)

* Uses Compare-And-Swap to update values without locking
* Example: ConcurrentLinkedQueue

### ✔ Copy-on-write

* Creates snapshot for iteration
* Example: CopyOnWriteArrayList

### ✔ Segmentation / bucket-level isolation

* Reduces lock contention
* Example: ConcurrentHashMap (Java 8)

These mechanisms keep collections **thread-safe but fast**.

---

# **10. What is a non-blocking algorithm?**

A **non-blocking algorithm** allows threads to operate without locking, meaning:

✔ Threads don't block each other
✔ Uses **CAS (Compare-And-Swap)**
✔ Prevents deadlock, starvation
✔ High performance

### Example (Atomic increment):

```java
AtomicInteger count = new AtomicInteger(0);
count.incrementAndGet();  // lock-free
```

Used in:

* ConcurrentHashMap
* ConcurrentLinkedQueue
* AtomicInteger, AtomicLong

---

# ⭐ Final Interview Summary Table

| Question                                 | Short Answer                                     |
| ---------------------------------------- | ------------------------------------------------ |
| HashMap vs ConcurrentHashMap             | CHM is thread-safe using fine-grained locking    |
| Concurrent collections                   | Thread-safe, high-performance                    |
| CopyOnWriteArrayList vs synchronizedList | Copy-on-write is better for reads                |
| BlockingQueue use                        | Producer-consumer, thread coordination           |
| Types of BlockingQueue                   | Array, Linked, Synchronous, Priority, DelayQueue |
| Producer-consumer                        | Uses put() / take()                              |
| Skip list                                | Multi-level linked list → O(log n)               |
| ConcurrentSkipListMap vs TreeMap         | CHM is concurrent; TreeMap is not                |
| Avoid locking issues                     | CAS + fine-grained locks + copy-on-write         |
| Non-blocking algorithm                   | No locking, CAS-based                            |

---

