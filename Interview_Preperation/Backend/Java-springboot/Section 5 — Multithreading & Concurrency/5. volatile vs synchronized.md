# **1. What is the purpose of the `volatile` keyword?**

`volatile` guarantees:

### ✔ **Memory visibility**

When a variable is marked volatile:

* Writes to it are **immediately visible** to other threads.
* Value is read directly from **main memory**, not CPU cache.

### ✔ **Prevents instruction reordering**

### Example:

```java
volatile boolean flag = true;

Thread t1 = new Thread(() -> {
    while (flag) { }
});
```

Without volatile, thread t1 might cache `flag` and never see updates.

---

# **2. Difference between `volatile` and `synchronized`**

| Feature                   | **volatile** | **synchronized**             |
| ------------------------- | ------------ | ---------------------------- |
| Memory visibility         | ✔ Yes        | ✔ Yes                        |
| Atomicity                 | ❌ No         | ✔ Yes                        |
| Mutual exclusion          | ❌ No         | ✔ Yes (one thread at a time) |
| Locks used                | No           | Yes                          |
| Blocks?                   | Non-blocking | Blocking                     |
| Performance               | Faster       | Slower                       |
| Prevents race conditions? | ❌ No         | ✔ Yes                        |

**volatile = visibility only**
**synchronized = visibility + atomicity + mutual exclusion**

---

# **3. Does volatile guarantee atomicity?**

❌ NO.

Atomicity means the operation is **completed fully without interruption**.

Example of **non-atomic** operation:

```java
volatile int count = 0;
count++;  // NOT atomic (read-modify-write)
```

`volatile` does NOT protect `count++`.

---

# **4. What is memory visibility problem?**

Threads use CPU caches.
If thread A writes to a variable, thread B **may not see updated value**.

Example:

```java
boolean flag = false;

Thread A: flag = true;    // update
Thread B: while(!flag) {} // may loop forever (reads from cache)
```

Memory visibility problem solved by:
✔ volatile
✔ synchronized
✔ final
✔ atomic variables

---

# **5. Explain happens-before relationship**

“Happens-before” is the rule defining **visibility guarantees** in Java memory model.

Examples of happens-before:

1. **Write to volatile variable → happens-before → read of same variable**
2. **Unlock monitor → happens-before → lock monitor**
3. **Thread.start() → happens-before → actions inside thread**
4. **Actions inside thread → happens-before → thread.join()**

So volatile ensures:

```
write(x) happens-before read(x)
```

---

# **6. Can volatile fix race conditions?**

❌ NO.

Race condition happens when multiple threads modify shared data.

Example:

```java
volatile int count = 0;

Thread 1: count++;
Thread 2: count++;
```

Still wrong because:

```
count++ = read + increment + write  (3 operations)
```

volatile does NOT make it atomic.

✔ Use synchronized or AtomicInteger

---

# **7. Performance difference between synchronized and volatile**

| Operation    | Performance                                  |
| ------------ | -------------------------------------------- |
| volatile     | Very fast, no locking                        |
| synchronized | Slower (lock acquisition, context switching) |

But synchronized offers:

* Mutual exclusion
* Atomicity
* Happens-before

Use volatile only when no atomicity is required.

---

# **8. Can we use both volatile and synchronized together?**

✔ YES, but rarely needed.

Example of correct usage:

* volatile ensures visibility
* synchronized ensures atomicity

But normally synchronized alone is enough.

---

# **9. Explain double-checked locking with volatile**

Used in **Singleton design pattern** to avoid expensive synchronization.

### Why volatile is needed?

Without volatile, instruction reordering may cause partially constructed object to be visible.

### Correct Implementation:

```java
class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {              // 1st check (no locking)
            synchronized (Singleton.class) {
                if (instance == null) {      // 2nd check (with locking)
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

✔ volatile prevents half-constructed object
✔ double-checked locking improves performance

---

# **10. When should you prefer volatile over synchronized?**

Use `volatile` when:

✔ Only **one thread writes**, others read
✔ No compound operations (no count++, no object mutation)
✔ Flag variables
✔ Status indicators
✔ Configuration updates
✔ “stop” or “shutdown” signals

### Example: Stopping a thread safely

```java
volatile boolean running = true;

Thread worker = new Thread(() -> {
    while (running) {
        // work
    }
});

// stop it safely
running = false;
```

Do NOT use volatile when:
❌ multiple threads update variable
❌ atomic operations needed
❌ complex business logic
❌ object mutation occurs

---

# ⭐ Final Interview Summary

| Question                  | Short Answer                               |
| ------------------------- | ------------------------------------------ |
| Purpose of volatile       | Visibility + prevent reordering            |
| volatile vs synchronized  | Visibility vs visibility+atomicity+locking |
| Atomicity?                | ❌ No                                       |
| Memory visibility problem | Thread doesn't see latest value            |
| Happens-before            | Guarantees visibility order                |
| Fix race conditions?      | ❌ No                                       |
| Performance               | volatile is faster                         |
| Use together?             | ✔ Yes, rarely                              |
| Double-checked locking    | Needs volatile to avoid reordering         |
| Prefer volatile when      | Simple, single-writer, flag variables      |

---

