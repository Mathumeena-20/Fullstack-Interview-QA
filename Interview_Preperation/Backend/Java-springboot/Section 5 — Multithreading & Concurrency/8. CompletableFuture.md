# **1. What is CompletableFuture?**

`CompletableFuture` is an advanced Future in Java 8 that supports:

✔ Asynchronous programming
✔ Non-blocking operations
✔ Callback chaining
✔ Combining multiple async tasks
✔ Exception handling
✔ Manually completing futures

It brings **Promises** / **async-await style** programming to Java.

---

# **2. Difference between Future and CompletableFuture**

| Feature               | Future  | CompletableFuture                 |
| --------------------- | ------- | --------------------------------- |
| Async execution       | ✔ Yes   | ✔ Yes                             |
| Non-blocking callback | ❌ No    | ✔ Yes (`thenApply`, `thenAccept`) |
| Exception handling    | ❌ No    | ✔ Yes (`exceptionally()`)         |
| Manual completion     | ❌ No    | ✔ Yes (`complete()`)              |
| Combining futures     | ❌ No    | ✔ Yes (`thenCombine`, `allOf`)    |
| Chaining tasks        | ❌ No    | ✔ Yes                             |
| Timeout utilities     | Limited | Rich                              |

CompletableFuture is **Future + Callbacks + Composition**.

---

# **3. What is asynchronous programming?**

Asynchronous programming allows:

✔ Tasks to run in background threads
✔ Main thread continues without blocking
✔ Better throughput in microservices & IO-heavy applications

### Example (sync):

```java
int result = longOperation(); // blocks
```

### Example (async):

```java
CompletableFuture<Integer> future = CompletableFuture.supplyAsync(() -> longOperation());
```

---

# **4. What is supplyAsync() and runAsync()?**

Both run tasks asynchronously.

### **1) supplyAsync()**

* Runs task **with return value**
* Uses ForkJoinPool by default

```java
CompletableFuture<Integer> future =
        CompletableFuture.supplyAsync(() -> 10 + 20);
```

---

### **2) runAsync()**

* Runs task **without returning anything**

```java
CompletableFuture<Void> future =
        CompletableFuture.runAsync(() -> System.out.println("Task running"));
```

---

# **5. Difference between thenApply(), thenAccept(), and thenRun()**

| Method           | Input          | Output         | Used for             |
| ---------------- | -------------- | -------------- | -------------------- |
| **thenApply()**  | Takes input    | Returns output | Transform result     |
| **thenAccept()** | Takes input    | Returns void   | Consume result       |
| **thenRun()**    | Takes no input | Returns void   | Run after completion |

### Example:

```java
CompletableFuture.supplyAsync(() -> 10)
    .thenApply(n -> n * 2)      // returns 20
    .thenAccept(System.out::println) // prints
    .thenRun(() -> System.out.println("Done"));
```

---

# **6. Difference between thenCompose() and thenCombine()**

| Feature    | thenCompose()               | thenCombine()                   |
| ---------- | --------------------------- | ------------------------------- |
| Purpose    | Chain dependent async tasks | Combine independent async tasks |
| Similar to | FlatMap                     | Join of two futures             |
| Input      | Future inside future        | Two completed futures           |
| Output     | One future                  | Combined result                 |

### **thenCompose() example (dependent operations)**

Fetch user → fetch account:

```java
CompletableFuture<String> result =
    getUser()
        .thenCompose(user -> getAccount(user));
```

---

### **thenCombine() example (parallel operations)**

Fetch price and discount in parallel:

```java
CompletableFuture<Double> finalPrice =
    priceFuture.thenCombine(discountFuture,
        (price, discount) -> price - discount);
```

---

# **7. How to handle exceptions using exceptionally()?**

`exceptionally()` provides fallback logic.

### Example:

```java
CompletableFuture<Integer> future =
    CompletableFuture.supplyAsync(() -> 10 / 0)
        .exceptionally(ex -> {
            System.out.println("Error: " + ex);
            return 0;  // fallback
        });
```

---

# **8. What is allOf() and anyOf()?**

### ✔ **allOf()**

Waits until **all** futures complete.

```java
CompletableFuture<Void> all =
    CompletableFuture.allOf(f1, f2, f3);
```

### ✔ **anyOf()**

Returns result of **first completed** future.

```java
CompletableFuture<Object> any =
    CompletableFuture.anyOf(f1, f2, f3);
```

---

# **9. How is thread pool selected in CompletableFuture?**

* By default → **ForkJoinPool.commonPool()**
* For custom pool → pass Executor:

```java
ExecutorService pool = Executors.newFixedThreadPool(10);

CompletableFuture.supplyAsync(() -> task(), pool);
```

✔ Use custom pool in microservices
✔ Avoid blocking operations in commonPool

---

# **10. Real-time use cases of CompletableFuture in microservices**

### ✔ 1. Parallel API calls

```java
CompletableFuture<String> user = getUser();
CompletableFuture<String> orders = getOrders(userId);

return user.thenCombine(orders, (u, o) -> merge(u, o));
```

---

### ✔ 2. Aggregating results from multiple microservices

Order Service → Payment Service → Inventory Service

### ✔ 3. Timeout handling for slow services

```java
future.orTimeout(2, TimeUnit.SECONDS);
```

---

### ✔ 4. Async logging / audit trails

### ✔ 5. Non-blocking database queries (reactive DB)

### ✔ 6. Circuit-breaker fallback logic

Using exceptionally / handle

### ✔ 7. Parallel data processing (E-commerce, analytics)

CompletableFuture helps microservices achieve **better scalability, low latency, and non-blocking IO**.

---

# ⭐ Complete Example — Chain async tasks

```java
ExecutorService pool = Executors.newFixedThreadPool(5);

CompletableFuture<Integer> future =
    CompletableFuture.supplyAsync(() -> 10, pool)
        .thenApply(n -> n * 2)
        .exceptionally(ex -> 0);

System.out.println(future.get()); // 20
pool.shutdown();
```

---

# ⭐ Final Interview Summary

| Topic                              | Short Answer                                        |
| ---------------------------------- | --------------------------------------------------- |
| CompletableFuture                  | Advanced Future with async chaining                 |
| Future vs CompletableFuture        | CF supports callbacks + composition                 |
| Async programming                  | Non-blocking background execution                   |
| supplyAsync vs runAsync            | With return vs without return                       |
| thenApply vs thenAccept vs thenRun | Transform vs consume vs run                         |
| thenCompose vs thenCombine         | Chain dependent vs combine independent              |
| exceptionally                      | Exception fallback                                  |
| allOf vs anyOf                     | Wait all vs first one                               |
| Thread pool                        | ForkJoin unless custom pool provided                |
| Microservice use                   | Parallel API calls, aggregation, fallback, timeouts |

---

