# **1. What are the different states in the Java thread lifecycle?**

Java defines **6 thread states** (from `Thread.State` enum):

1. **NEW** → Thread created but not started
2. **RUNNABLE** → Running OR ready-to-run
3. **BLOCKED** → Waiting to acquire a lock
4. **WAITING** → Waiting indefinitely for another thread’s action
5. **TIMED_WAITING** → Waiting for a specified time
6. **TERMINATED** → Thread has completed execution

### Quick diagram:

```
NEW → RUNNABLE → WAITING / TIMED_WAITING / BLOCKED → RUNNABLE → TERMINATED
```

---

# **2. Difference between WAITING and TIMED_WAITING**

| WAITING                         | TIMED_WAITING                                |
| ------------------------------- | -------------------------------------------- |
| Waits **indefinitely**          | Waits for **fixed time**                     |
| Moves only when notified        | Moves after timeout or notify                |
| Methods: wait(), join(), park() | sleep(), wait(time), join(time), parkNanos() |

### Examples:

```java
obj.wait();          // WAITING
Thread.sleep(1000);  // TIMED_WAITING
```

---

# **3. What happens when start() is called on a thread internally?**

Steps:

1. JVM creates a **new OS-level thread**
2. Thread moves from **NEW → RUNNABLE**
3. Schedules thread using CPU scheduler
4. Calls thread’s `run()` method

Note:
`start()` → creates a new thread
`run()` → executes in current thread, **does NOT start a new thread**

---

# **4. Difference between sleep() and wait()**

| sleep()                      | wait()                                 |
| ---------------------------- | -------------------------------------- |
| Belongs to Thread class      | Belongs to Object class                |
| Does NOT release lock        | Releases lock                          |
| Used for timing              | Used for inter-thread communication    |
| Always resumes after timeout | Resumes only after notify or notifyAll |

### Example:

```java
Thread.sleep(1000);  // Does not release monitor lock
obj.wait();          // Releases lock
```

---

# **5. What is yield() and how does it work?**

`yield()` hints to the scheduler:

✔ Thread is willing to pause
✔ Give other threads a chance

But **scheduler may ignore this**.
It does NOT release any locks.

### Example:

```java
Thread.yield();
```

---

# **6. Can a thread be restarted after termination?**

❌ No.

Once thread state = **TERMINATED**, calling `start()` again throws:

```
IllegalThreadStateException
```

You must create a **new thread object**.

---

# **7. When does a thread enter the BLOCKED state?**

A thread becomes BLOCKED when:

✔ It tries to enter a synchronized block
✔ But another thread holds the lock

### Example:

```java
synchronized(obj) { 
    // Thread A holds lock
}

Thread B tries:
synchronized(obj) { } // Thread B → BLOCKED
```

---

# **8. How does JVM perform context switching?**

JVM uses OS-level scheduling:

1. Each thread gets a **time slice**
2. CPU saves current thread’s state (registers, PC)
3. Loads another thread’s state
4. Switches execution

Context switching depends on:

* CPU scheduler
* Priority
* JVM implementation
* OS preemption

Threads do NOT control context switching.

---

# **9. Difference between user thread and daemon thread**

| User Thread                           | Daemon Thread                  |
| ------------------------------------- | ------------------------------ |
| Prevent JVM from shutting down        | Does NOT prevent JVM shutdown  |
| Created by program                    | Usually background tasks       |
| Examples: main thread, worker threads | GC, background cleanup threads |

### Making a daemon thread:

```java
Thread t = new Thread(task);
t.setDaemon(true);
t.start();
```

---

# **10. What causes thread starvation?**

Thread starvation happens when:

✔ A thread never gets CPU time
✔ Or cannot acquire a lock

Causes:

* High thread priority imbalance
* Locks being held too long
* Synchronized blocks causing wait
* Heavy contention for resources
* Executor with limited threads

Example:

```java
synchronized(obj) {
    while(true) { }  // lock never released
}
// Other threads → starvation
```

---

# ⭐ CODE EXAMPLES

## Simple thread example

```java
class MyThread extends Thread {
    public void run() {
        System.out.println("Thread running: " + Thread.currentThread().getName());
    }
}

public class Test {
    public static void main(String[] args) {
        MyThread t = new MyThread();
        t.start(); // start lifecycle
    }
}
```

---

# ⭐ Final Interview Summary

| Concept                  | Explanation                                                |
| ------------------------ | ---------------------------------------------------------- |
| Thread states            | NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED |
| WAITING vs TIMED_WAITING | Indefinite wait vs timed wait                              |
| start() internal         | Creates new thread + calls run()                           |
| sleep vs wait            | sleep doesn't release lock; wait releases                  |
| yield                    | Suggest scheduler to pause                                 |
| Restart thread?          | ❌ No                                                       |
| BLOCKED                  | Trying to acquire lock                                     |
| Context switching        | OS-level thread scheduler                                  |
| User vs daemon           | User keeps JVM alive                                       |
| Starvation               | Low-priority / never-acquire lock                          |

---

