# **1. Difference between implementing Runnable and extending Thread**

| Feature               | **Runnable**                               | **Thread**                               |
| --------------------- | ------------------------------------------ | ---------------------------------------- |
| How used?             | `class X implements Runnable`              | `class X extends Thread`                 |
| Multiple inheritance? | ‚úî Allowed (class can extend another class) | ‚ùå Not allowed (single inheritance issue) |
| Reusability           | Runnable can be shared among threads       | Thread object cannot be reused           |
| Design                | Separates job (task) from worker (thread)  | Task + thread mixed together             |
| Memory                | Lightweight                                | Heavier (thread object created)          |

### Example:

```java
class MyTask implements Runnable {
    public void run() { System.out.println("Task running"); }
}
```

versus

```java
class MyThread extends Thread {
    public void run() { System.out.println("Thread running"); }
}
```

---

# **2. Why is Runnable preferred over Thread?**

‚úî Allows a class to extend another class
‚úî Better object-oriented design (task is separate from thread)
‚úî Shared Runnable instance can be executed by multiple threads
‚úî Works with ExecutorService
‚úî More flexible and reusable

Runnable separates:

* **What to run** (task)
* **How to run** (Thread scheduling)

---

# **3. Can a class extend both Thread and another class?**

‚ùå No.

Because Java supports **single inheritance**, so:

```java
class A extends Thread, B   // INVALID
```

But using Runnable:

```java
class A extends B implements Runnable  // VALID
```

That's why Runnable is preferred.

---

# **4. What happens if you call run() instead of start()?**

Calling `run()`:

‚ùå Does NOT create a new thread
‚úî Executes in the **current thread**

```java
Thread t = new Thread(() -> System.out.println(Thread.currentThread().getName()));

t.run();   // runs in main thread
t.start(); // runs in new thread
```

Interviewers love this question.

---

# **5. Is Runnable a Functional Interface?**

‚úî YES.

Runnable has **exactly one abstract method**:

```java
void run();
```

Therefore it is a functional interface.

---

# **6. Can lambda be used with Runnable?**

‚úî Yes, because Runnable is a functional interface.

### Example:

```java
Runnable task = () -> System.out.println("Running via lambda");
new Thread(task).start();
```

---

# **7. Can we reuse a thread object?**

‚ùå No.

Once a thread finishes (TERMINATED), calling `start()` again throws:

```
IllegalThreadStateException
```

If you want to run again ‚Üí **create new thread object**.

---

# **8. How to return value from a thread?**

Runnable **cannot** return values.
Use **Callable** with **Future / ExecutorService**.

### Example:

```java
Callable<Integer> task = () -> {
    return 10 + 20;
};

ExecutorService ex = Executors.newSingleThreadExecutor();
Future<Integer> f = ex.submit(task);
System.out.println(f.get()); // returns value
```

---

# **9. What happens if multiple threads call the same Runnable instance?**

All threads run the **same run() method** on the **same shared object**.

‚úî They share instance variables
‚úî Can cause race conditions if not synchronized

### Example:

```java
class Counter implements Runnable {
    int count = 0;
    public void run() {
        for (int i = 0; i < 1000; i++) count++;
    }
}

Counter c = new Counter();
new Thread(c).start();
new Thread(c).start();
```

Here:

* Two threads modify `count` ‚Üí race condition
  Use **synchronization** or **AtomicInteger**.

---

# **10. Real-world scenarios where Runnable is preferred**

### üíº Real-world examples:

1. **Web servers / Thread pools**

   * You submit tasks, not create threads manually.
   * Uses Runnable/Callable.

2. **Background tasks**

   * Logging, file monitoring, DB polling.

3. **Long-running worker tasks**

   * Producer-consumer, BlockingQueue workers.

4. **UI event handling (Android, Swing)**

   * Every event uses Runnable.

5. **Asynchronous job scheduling**

   * ScheduledExecutorService tasks.

### Why Runnable is preferred?

Because **Thread creation is expensive**, Runnable lets ExecutorService reuse threads.

---

# ‚≠ê Quick Summary Table

| Question                         | Answer                                                |
| -------------------------------- | ----------------------------------------------------- |
| Runnable vs Thread               | Runnable for tasks, Thread for thread control         |
| Why Runnable?                    | Multiple inheritance, reusable, supports thread pools |
| Calling run()                    | Runs in same thread                                   |
| Callable vs Runnable             | Callable returns values, Runnable does not            |
| Thread restart                   | ‚ùå Cannot restart once terminated                      |
| Same Runnable instance           | Shared state ‚Üí race conditions                        |
| Runnable = Functional Interface? | ‚úî Yes                                                 |
| Lambda allowed?                  | ‚úî Yes                                                 |
| Thread cannot extend two classes | Because of single inheritance                         |

---

