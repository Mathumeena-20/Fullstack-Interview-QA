# **1. Difference between `synchronized` and `Lock` interface**

| Feature               | `synchronized`    | `Lock` (ReentrantLock, etc.)          |
| --------------------- | ----------------- | ------------------------------------- |
| Type                  | JVM keyword       | Java API (java.util.concurrent.locks) |
| Flexibility           | ❌ Limited         | ✔ Highly flexible                     |
| Try to acquire lock?  | ❌ No              | ✔ `tryLock()`                         |
| Interrupt lock?       | ❌ No              | ✔ `lockInterruptibly()`               |
| Fairness              | ❌ No fairness     | ✔ Fair lock available                 |
| Condition variables   | ❌ Not supported   | ✔ `Condition` (multiple wait sets)    |
| Manual unlock needed? | No (auto release) | Yes → `unlock()` must be called       |
| Deadlock recovery     | No                | More control                          |
| Performance           | Good              | Better under contention               |

### Summary

Use `synchronized` for **simple locking**,
Use `Lock` for **advanced locking features**.

---

# **2. What is ReentrantLock?**

`ReentrantLock` is a **concrete implementation of Lock**, allowing:

✔ Thread can acquire the same lock multiple times (reentrancy)
✔ Fair & unfair locking
✔ TryLock
✔ Condition variables
✔ Interruptible locking

### Example:

```java
ReentrantLock lock = new ReentrantLock();

lock.lock();
try {
    System.out.println("Critical section");
} finally {
    lock.unlock();
}
```

---

# **3. Difference between fair and unfair lock**

| Lock Type                 | Behavior                                         |
| ------------------------- | ------------------------------------------------ |
| **Fair lock**             | Longest-waiting thread gets lock first           |
| **Unfair lock (default)** | Thread can “jump the queue” → better performance |

### Example:

```java
ReentrantLock fairLock = new ReentrantLock(true);   // fair
ReentrantLock unfairLock = new ReentrantLock(false); // unfair (default)
```

✔ Fair lock prevents starvation
✔ Unfair lock gives highest throughput

---

# **4. What is a Semaphore?**

A **Semaphore** is a synchronization tool that controls access to shared resources using **permits**.

Types:

* **Binary semaphore** → works like a mutex
* **Counting semaphore** → multiple permits

### Example: Only 3 threads allowed at a time

```java
Semaphore sem = new Semaphore(3);

sem.acquire();
try {
    // critical section
} finally {
    sem.release();
}
```

---

# **5. Difference between Mutex and Semaphore**

| Mutex                     | Semaphore                             |
| ------------------------- | ------------------------------------- |
| Only 1 permit             | Multiple permits                      |
| Owner thread must release | Any thread can release                |
| Prevents multiple entry   | Controls number of concurrent entries |
| Binary                    | Binary or Counting                    |

Mutex = special case of a semaphore with **1 permit**.

---

# **6. What is ReadWriteLock?**

`ReadWriteLock` provides **two locks**:

1. **Read Lock** → Multiple threads can read simultaneously
2. **Write Lock** → Only one writer allowed

### Example:

```java
ReadWriteLock rw = new ReentrantReadWriteLock();
rw.readLock().lock();
// multiple readers allowed
rw.readLock().unlock();

rw.writeLock().lock();
// exclusive writer
rw.writeLock().unlock();
```

Used in caching, databases, configuration reads.

---

# **7. Advantages of Lock over synchronized**

✔ interruptible lock acquisition
✔ tryLock() → attempt without blocking
✔ timed lock `tryLock(time)`
✔ fairness policy
✔ multiple condition variables
✔ better performance during contention
✔ explicit lock control

`synchronized` is simpler but less flexible.

---

# **8. What is TryLock?**

`tryLock()` attempts to acquire lock:

### 1. **Without waiting**

```java
if (lock.tryLock()) {
    try { } finally { lock.unlock(); }
} else {
    System.out.println("Lock not available");
}
```

### 2. **With timeout**

```java
if (lock.tryLock(2, TimeUnit.SECONDS)) { ... }
```

Useful to avoid deadlocks.

---

# **9. How does Lock handle interruption?**

Use:

```java
lock.lockInterruptibly();
```

If thread is waiting for lock and someone interrupts it, the thread stops waiting.

### Example:

```java
try {
    lock.lockInterruptibly();
} catch (InterruptedException e) {
    System.out.println("Interrupted while waiting for lock");
}
```

`synchronized` CANNOT be interrupted while waiting.

---

# **10. Real-world use case for Semaphore**

✔ **Limiting concurrent access** to a resource:

### Examples:

* Limit DB connections (max 10)
* Restrict API call rate
* Control access to printers, hardware
* Thread pool design
* Parking lot (fixed number of slots)

### Example: Max 3 users in the system

```java
Semaphore sem = new Semaphore(3);

public void login() throws InterruptedException {
    sem.acquire();
    try {
        System.out.println("User logged in");
    } finally {
        sem.release();
    }
}
```

---

# ⭐ Final Interview Summary

| Question             | Key Answer                                                 |
| -------------------- | ---------------------------------------------------------- |
| synchronized vs Lock | Lock = advanced features, tryLock, fairness, interruptible |
| ReentrantLock        | Supports reentrancy + fairness                             |
| fair vs unfair       | fairness reduces starvation; unfair improves performance   |
| Semaphore            | Controls permits for resource access                       |
| Mutex vs Semaphore   | Mutex = 1 permit, Semaphore = multiple                     |
| ReadWriteLock        | Allows many readers, one writer                            |
| Advantages of Lock   | tryLock, fairness, condition vars                          |
| tryLock              | Acquire lock without blocking                              |
| Lock interruption    | lockInterruptibly()                                        |
| Semaphore real use   | Limit concurrent access                                    |

---

