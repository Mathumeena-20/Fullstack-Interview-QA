
# **1. Difference between Runnable and Callable**

| Feature                   | **Runnable**             | **Callable**         |
| ------------------------- | ------------------------ | -------------------- |
| Method                    | `run()`                  | `call()`             |
| Returns value             | ❌ No                     | ✔ Yes                |
| Throws checked exceptions | ❌ No                     | ✔ Yes                |
| Lambda supported          | ✔ Yes                    | ✔ Yes                |
| Used with                 | Thread / ExecutorService | ExecutorService only |

### Example:

```java
Runnable r = () -> System.out.println("Running...");

Callable<Integer> c = () -> 10 + 20;
```

---

# **2. What is a Future?**

`Future` represents the **result of an asynchronous computation**.

You get Future when you submit a **Callable** or **Runnable** to ExecutorService.

✔ Check task status
✔ Get result
✔ Cancel task

### Example:

```java
Future<Integer> f = executor.submit(() -> 10 + 20);
```

---

# **3. How do you get result from Future?**

Using:

```java
f.get();
```

This is a **blocking call** → waits until task finishes.

### Example:

```java
Integer result = f.get();
System.out.println(result); // 30
```

---

# **4. Difference between get() and get(timeout)**

| Method               | Behavior                                                            |
| -------------------- | ------------------------------------------------------------------- |
| `get()`              | Waits indefinitely (blocks forever)                                 |
| `get(timeout, unit)` | Waits for given duration, throws `TimeoutException` if time elapses |

### Example:

```java
f.get(2, TimeUnit.SECONDS); // throws TimeoutException if task not done
```

---

# **5. What is blocking vs non-blocking call?**

### **Blocking**

Thread **waits** until the operation completes.
Example:

```java
f.get();  // blocks
Thread.sleep(1000);
```

### **Non-blocking**

Thread continues immediately without waiting.
Example:

```java
f.isDone(); // non-blocking
f.cancel(true);
```

---

# **6. How do you cancel a running task?**

Using:

```java
f.cancel(true);
```

Arguments:

* `true` → interrupts the thread
* `false` → waits for running task to finish

### Example:

```java
Future<?> f = executor.submit(longTask);
f.cancel(true);
```

---

# **7. Difference between invokeAll() and invokeAny()**

## ✔ `invokeAll()`

* Submits **multiple Callables**
* Returns **List<Future>**
* Waits until *all* tasks complete

```java
List<Future<Integer>> results = executor.invokeAll(listOfCallables);
```

---

## ✔ `invokeAny()`

* Submits multiple Callables
* Returns result of **first successfully completed** task
* Cancels remaining tasks

```java
Integer result = executor.invokeAny(listOfCallables);
```

---

# **8. Explain Timeout Handling in Future**

Timeout prevents a task from blocking forever.

### Example:

```java
try {
    Integer result = future.get(1, TimeUnit.SECONDS);
} catch (TimeoutException e) {
    System.out.println("Task timed out!");
    future.cancel(true);
}
```

✔ Prevents deadlocks
✔ Lets you cancel long-running tasks

---

# **9. What is CompletionService?**

`CompletionService` combines:

* ExecutorService
* A queue for completed tasks

### Why useful?

✔ Retrieve results **as soon as each task finishes**
✔ Not in submission order
✔ Ideal for parallel processing

### Example:

```java
CompletionService<Integer> cs =
    new ExecutorCompletionService<>(executor);

cs.submit(() -> 5);
cs.submit(() -> 10);

Future<Integer> f = cs.take(); // returns first completed
System.out.println(f.get());
```

---

# **10. How is Callable useful in real applications?**

Used when you need **results** from background tasks.

### Real-world use cases:

✔ Fetch data from DB
✔ Call external REST APIs
✔ Asynchronous file processing
✔ Complex calculations
✔ Batch processing
✔ Parallel search in large collections
✔ Financial transactions & trading systems

### Example:

```java
Callable<Order> fetchOrder = () -> orderService.getOrderFromDB(orderId);
Future<Order> order = executor.submit(fetchOrder);
```

---

# ⭐ Complete Example — Runnable vs Callable

```java
ExecutorService executor = Executors.newFixedThreadPool(3);

Runnable task1 = () -> System.out.println("Runnable running...");
Callable<Integer> task2 = () -> 42;

// Runnable → no result
executor.execute(task1);

// Callable → returns Future<Integer>
Future<Integer> f = executor.submit(task2);
System.out.println(f.get()); // 42

executor.shutdown();
```

---

# ⭐ Final Interview Summary

| Question                 | Key Answer                                   |
| ------------------------ | -------------------------------------------- |
| Runnable vs Callable     | Callable can return value + throw exceptions |
| What is Future?          | Represents async computation                 |
| get() vs get(timeout)    | Infinite wait vs timed wait                  |
| Blocking vs Non-blocking | Waits vs immediate return                    |
| Cancel task              | future.cancel(true)                          |
| invokeAll()              | Wait for all tasks                           |
| invokeAny()              | First completed task                         |
| Timeout handling         | Prevents infinite wait                       |
| CompletionService        | Fetch completed tasks immediately            |
| Callable uses            | DB calls, API calls, parallel tasks          |

---
