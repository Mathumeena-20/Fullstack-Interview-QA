# **1. How do you create a custom exception in Java?**

Create a class that extends either:

* `Exception` → checked exception
* `RuntimeException` → unchecked exception

### Example:

```java
public class InvalidUserException extends RuntimeException {
    public InvalidUserException(String message) {
        super(message);
    }
}
```

Usage:

```java
throw new InvalidUserException("User ID is invalid");
```

---

# **2. Difference between extending Exception and RuntimeException**

| Feature                     | `Exception`               | `RuntimeException`                             |
| --------------------------- | ------------------------- | ---------------------------------------------- |
| Type                        | Checked                   | Unchecked                                      |
| Must declare with `throws`? | ✔ Yes                     | ❌ No                                           |
| Must be handled explicitly? | ✔ Yes                     | ❌ No                                           |
| Used for                    | Recoverable issues        | Programming errors                             |
| Examples                    | IOException, SQLException | NullPointerException, IllegalArgumentException |

✔ Use checked exception when caller is expected to handle the problem
✔ Use runtime exception when caller cannot fix the problem (e.g., invalid input)

---

# **3. When should you create a custom exception?**

Create a custom exception when:

✔ You need meaningful domain-specific error
✔ You want to differentiate specific cases
✔ You need extra metadata (error code, HTTP status, etc.)
✔ You want clean and centralized business error handling

**Examples:**

* `InsufficientBalanceException`
* `InvalidJwtTokenException`
* `RecordNotFoundException`

---

# **4. How do you pass custom messages to your exception?**

Use constructor and `super()`:

```java
public class BalanceException extends Exception {
    public BalanceException(String msg) {
        super(msg);
    }
}
```

Usage:

```java
throw new BalanceException("Balance below minimum requirement");
```

---

# **5. Can custom exceptions be made serializable?**

✔ Yes.
All Throwable classes are already Serializable.

But if you add custom fields, you should provide:

```java
private static final long serialVersionUID = 1L;
```

Example:

```java
public class UserNotFoundException extends RuntimeException implements Serializable {
    private static final long serialVersionUID = 1L;
}
```

---

# **6. Can you override the fillInStackTrace()?**

✔ Yes, and widely used for performance optimization.

Example:

```java
@Override
public synchronized Throwable fillInStackTrace() {
    return this; // skip expensive stack trace creation
}
```

Useful when exceptions are thrown frequently (e.g., validations).

---

# **7. Best practices while creating custom exceptions**

### ✔ Use meaningful names

`OrderNotFoundException` > `OrderException`

### ✔ Keep them lightweight

Avoid storing large objects inside exceptions.

### ✔ Provide multiple constructors

```java
public MyException(String msg, Throwable cause);
public MyException(Throwable cause);
public MyException(String msg);
public MyException();
```

### ✔ Include error codes

For REST APIs.

### ✔ Use RuntimeException unless caller MUST handle it

### ✔ Avoid unnecessary hierarchy

Do NOT create too many exceptions.

---

# **8. What is exception chaining?**

Exception chaining stores the original cause inside the new exception.

Example:

```java
try {
    saveToDatabase();
} catch (SQLException e) {
    throw new DataAccessException("Database error", e);
}
```

Retrieve original:

```java
e.getCause();
```

✔ Helps debugging the real root cause
✔ Essential in layered applications

---

# **9. How do you handle custom exceptions in service layers?**

### ✔ In Service Layer

Throw custom exceptions for business failures.

```java
if (user == null)
    throw new UserNotFoundException("User not found");
```

### ✔ In Controller (Spring Boot)

Use `@ControllerAdvice` for centralized handling:

```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(UserNotFoundException.class)
    public ResponseEntity<?> handleUserNotFound(UserNotFoundException ex) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND)
                             .body(ex.getMessage());
    }
}
```

✔ Clean API responses
✔ No try-catch clutter in service methods

---

# **10. Real project scenario where you used custom exception**

### **Scenario: E-commerce Payment System**

Business rule:

* Payment should fail if CVV is invalid
* Should return an error code BACK to client

Custom exception:

```java
public class InvalidPaymentException extends RuntimeException {
    private final String errorCode;

    public InvalidPaymentException(String msg, String errorCode) {
        super(msg);
        this.errorCode = errorCode;
    }

    public String getErrorCode() {
        return errorCode;
    }
}
```

Usage in service:

```java
if (!isValidCVV(card.getCvv())) {
    throw new InvalidPaymentException("Invalid CVV", "PAY-002");
}
```

Controller Advice:

```java
@ExceptionHandler(InvalidPaymentException.class)
public ResponseEntity<?> handleInvalidPayment(InvalidPaymentException ex) {
    return ResponseEntity.badRequest()
        .body(Map.of("message", ex.getMessage(), "code", ex.getErrorCode()));
}
```

✔ Clean
✔ Domain-specific
✔ Proper response for client
✔ Easy debugging

---

# ⭐ Full Example: Proper Custom Exception Class

```java
public class ResourceNotFoundException extends RuntimeException {

    private static final long serialVersionUID = 1L;
    private final String resourceName;
    private final String field;
    private final Object value;

    public ResourceNotFoundException(String resourceName, String field, Object value) {
        super(String.format("%s not found with %s : '%s'", resourceName, field, value));
        this.resourceName = resourceName;
        this.field = field;
        this.value = value;
    }
}
```

Usage:

```java
if (user == null)
    throw new ResourceNotFoundException("User", "id", userId);
```

---

# ⭐ Final Interview Summary

| Question                  | Short Answer                                        |
| ------------------------- | --------------------------------------------------- |
| Create custom exception   | Extend Exception/RuntimeException                   |
| Difference                | Checked vs unchecked                                |
| When                      | Domain-specific errors                              |
| Pass message              | Constructor → super(msg)                            |
| Serializable?             | Yes                                                 |
| Override fillInStackTrace | For performance                                     |
| Best practices            | Meaningful name, multiple constructors              |
| Exception chaining        | new Ex("msg", cause)                                |
| Service handling          | Throw exception → handle via @ControllerAdvice      |
| Real scenario             | Payment validation, entity not found, invalid token |

---

