# **1. Difference between checked and unchecked exceptions**

| Feature                      | Checked Exception                        | Unchecked Exception                            |
| ---------------------------- | ---------------------------------------- | ---------------------------------------------- |
| Parent class                 | `Exception` (excluding RuntimeException) | `RuntimeException` + `Error`                   |
| Must handle using try/catch? | ✔ Yes                                    | ❌ No                                           |
| Must declare using `throws`? | ✔ Yes                                    | ❌ No                                           |
| When they occur              | Expected, recoverable issues             | Programming bugs, unexpected failures          |
| Examples                     | IOException, SQLException                | NullPointerException, IllegalArgumentException |
| Compile-time checking        | ✔ Yes                                    | ❌ No                                           |

---

# **2. Why did Java designers introduce checked exceptions?**

Java designers introduced checked exceptions because:

✔ They wanted **robust programs**
✔ They wanted developers to **explicitly handle recoverable errors** (file not found, DB issues)
✔ Compile-time checking reduces runtime crashes
✔ Encourages writing **error-handling logic** early

In early Java (1990s), reliability > speed.

---

# **3. Examples of checked and unchecked exceptions**

### ✔ Checked exceptions

* `IOException`
* `SQLException`
* `FileNotFoundException`
* `ParseException`
* `ClassNotFoundException`

### ✔ Unchecked exceptions (RuntimeException)

* `NullPointerException`
* `IllegalArgumentException`
* `IndexOutOfBoundsException`
* `ArithmeticException`
* `ClassCastException`

Example code:

```java
// Checked
try {
    new FileInputStream("abc.txt");
} catch (FileNotFoundException e) { }

// Unchecked
int x = 10 / 0;  // ArithmeticException
```

---

# **4. Why RuntimeException is unchecked?**

Because **programming errors should not be forced to handle**.

Examples:

* Null pointer
* Wrong arguments
* Logic errors
* Array index errors

Handling them doesn’t fix the logic, so Java does not force try/catch.

---

# **5. Can we catch unchecked exceptions?**

✔ **YES, we can catch them**—but not required.

Example:

```java
try {
    int x = 1 / 0;
} catch (ArithmeticException e) {
    System.out.println("Caught");
}
```

But usually unnecessary, unless:

* Cleaning up
* Logging

---

# **6. Does JVM force handling checked exceptions?**

✔ **Yes.**
If code may throw a checked exception:

* You MUST use **try-catch**, OR
* Declare using **throws**.

Example:

```java
public void read() throws IOException {
    FileReader fr = new FileReader("test.txt");
}
```

If not handled → compile-time error.

---

# **7. When should you use checked exception?**

Use checked exceptions when:

✔ The caller can **recover**
✔ The condition is **not due to programming mistake**
✔ External resources involved
✔ You want caller to **be aware** of potential failure

Examples:

* File not found
* Network unavailable
* Database connection errors
* Business validations that require corrective action

---

# **8. When should you prefer unchecked exception?**

Use unchecked exceptions when:

✔ Error is due to **programmer mistake**
✔ Caller cannot fix the problem
✔ Making code cleaner (no boilerplate try/catch)
✔ For validation errors
✔ For domain errors in microservices

Examples:

* Invalid method arguments
* Illegal state
* Null pointer
* Index out of bounds

In Spring Boot, most business exceptions are **unchecked**.

---

# **9. How exceptions affect transaction management?**

Relevant in Spring:

### ✔ RuntimeException → Triggers Automatic Rollback

Default Spring behavior:

```
@Transactional 
throws RuntimeException => rollback
```

### ✔ Checked Exception → Does NOT Rollback by Default

Spring assumes checked exceptions are recoverable.

To force rollback:

```java
@Transactional(rollbackFor = Exception.class)
```

### Summary

| Exception Type    | Rollback?      |
| ----------------- | -------------- |
| RuntimeException  | ✔ Yes          |
| Error             | ✔ Yes          |
| Checked Exception | ❌ No (default) |

---

# **10. How do microservices handle checked vs unchecked exceptions?**

### ✔ 1. Microservices rarely use checked exceptions

Why?

* They pollute method signatures
* Harder to manage across layers
* JSON error responses must be uniform
* REST APIs prefer **error codes, not checked exceptions**

### ✔ 2. Business errors → Unchecked exceptions

Example:

```java
throw new InvalidOrderException("Order ID invalid");
```

Handled by:

* GlobalExceptionHandler (`@ControllerAdvice`)

### ✔ 3. Infrastructure errors (DB, network) usually wrapped

Example:

```java
catch(SQLException e) {
    throw new DatabaseException("DB failure", e);
}
```

### ✔ 4. Error translation into standard REST responses:

* HTTP 400 → Validation errors
* HTTP 401 → Auth failures
* HTTP 404 → Resource not found
* HTTP 500 → System errors

Frameworks like Spring Boot convert unchecked exceptions → JSON error responses.

---

# ⭐ Full Example: Custom Unchecked Business Exception in Microservice

```java
public class OrderNotFoundException extends RuntimeException {
    public OrderNotFoundException(String msg) { super(msg); }
}
```

Service:

```java
public Order getOrder(int id) {
    return repo.findById(id)
        .orElseThrow(() -> new OrderNotFoundException("Order not found: " + id));
}
```

Global handler:

```java
@ExceptionHandler(OrderNotFoundException.class)
public ResponseEntity<?> handleException(OrderNotFoundException ex) {
    return ResponseEntity.status(HttpStatus.NOT_FOUND)
        .body(Map.of("error", ex.getMessage()));
}
```

---

# ⭐ Final Interview Summary

| Topic                       | Short Answer                                       |
| --------------------------- | -------------------------------------------------- |
| Checked vs unchecked        | Checked must be handled; unchecked don’t           |
| Why checked exist           | Force handling recoverable errors                  |
| RuntimeException unchecked? | Programming errors shouldn’t be forced             |
| Catch unchecked?            | Yes, optional                                      |
| JVM force checked?          | Yes                                                |
| Use checked                 | Recoverable external issues                        |
| Use unchecked               | Business logic, validation, programming errors     |
| Transactions                | RuntimeException → rollback; Checked → no rollback |
| Microservices               | Prefer unchecked + @ControllerAdvice               |

---

