# 1. What is a Functional Interface?

A **functional interface** is an interface that contains **exactly one abstract method**.

It can have:
✔ Any number of default methods
✔ Any number of static methods
✔ One abstract method only

### Example:

```java
@FunctionalInterface
interface MyFunc {
    void show();
}
```

---

# 2. What is `@FunctionalInterface` Annotation?

It is used to **mark an interface as functional** and ensure the compiler checks that:

* It has only **one abstract method**
* You don’t accidentally add another abstract method

### Example:

```java
@FunctionalInterface
interface Printer {
    void print(String msg);
}
```

If you add another abstract method → compile-time error.

---

# 3. Can a Functional Interface Have Multiple Methods?

❌ **Multiple abstract methods? No.**
✅ **Multiple default or static methods? Yes.**

### Example:

```java
@FunctionalInterface
interface A {
    void show();          // Only one abstract method

    default void test() {}    // allowed
    static void display() {}  // allowed
}
```

---

# 4. Examples of Built-in Functional Interfaces (Java 8)

## 4.1 Predicate<T>

Represents a boolean condition.

### Example:

```java
Predicate<Integer> isEven = n -> n % 2 == 0;
System.out.println(isEven.test(10)); // true
```

---

## 4.2 Function<T, R>

Takes input T and returns R.

### Example:

```java
Function<String, Integer> length = s -> s.length();
System.out.println(length.apply("Java"));  // 4
```

---

## 4.3 Consumer<T>

Consumes input but returns nothing.

### Example:

```java
Consumer<String> c = msg -> System.out.println(msg);
c.accept("Hello");
```

---

## 4.4 Supplier<R>

Supplies/returns a value with no input.

### Example:

```java
Supplier<Double> randomValue = () -> Math.random();
System.out.println(randomValue.get());
```

---

# 5. Difference Between Function and Consumer

| Feature | Function  | Consumer   |
| ------- | --------- | ---------- |
| Input   | Yes       | Yes        |
| Output  | Yes       | No         |
| Method  | `apply()` | `accept()` |

### Example:

```java
Function<Integer, Integer> square = n -> n*n;
Consumer<Integer> print = n -> System.out.println(n);
```

---

# 6. What Are Primitive Functional Interfaces?

Java provides special versions for primitive types to avoid **autoboxing overhead**.

Examples:

* `IntPredicate`
* `LongPredicate`
* `DoublePredicate`
* `IntFunction<R>`
* `IntSupplier`
* `IntConsumer`

### Example:

```java
IntPredicate isPositive = n -> n > 0;
System.out.println(isPositive.test(5));  // true
```

---

# 7. What Are Custom Functional Interfaces?

Interfaces created by developers with exactly one abstract method.

### Example:

```java
@FunctionalInterface
interface Calculator {
    int add(int a, int b);
}

Calculator c = (a, b) -> a + b;
System.out.println(c.add(10, 20)); // 30
```

---

# 8. Why Default Methods Don’t Break Functional Interfaces?

Because a functional interface requires only **one abstract method**.

Default and static methods **are not abstract**, so they **do not count**.

### Example:

```java
@FunctionalInterface
interface Test {
    void show();    // abstract

    default void m1() {}   // not abstract
}
```

---

# 9. How Do Method References Relate to Functional Interfaces?

A method reference provides a **shortcut to implement** a functional interface using:

* `Class::staticMethod`
* `object::instanceMethod`
* `Class::new`  (constructor reference)

### Example:

```java
@FunctionalInterface
interface Message {
    void print(String msg);
}

// Method Reference
Message m = System.out::println;

m.print("Hello");
```

---

# 10. Can You Extend a Functional Interface?

Yes, but **only if the child interface does NOT introduce new abstract methods**.

### Valid Example:

```java
@FunctionalInterface
interface A {
    void show();
}

@FunctionalInterface
interface B extends A {
    // No new abstract method → OK
}
```

### Invalid Example:

```java
interface A {
    void show();
}

interface B extends A {
    void test();   // new abstract method ❌ breaks functional interface
}
```

---

# ✅ Final Summary Table

| Question                | Short Answer                            |
| ----------------------- | --------------------------------------- |
| Functional interface    | Exactly 1 abstract method               |
| @FunctionalInterface    | Compiler enforcement                    |
| Multiple methods?       | Only 1 abstract; defaults allowed       |
| Built-in types          | Predicate, Function, Consumer, Supplier |
| Function vs Consumer    | Function returns; Consumer doesn't      |
| Primitive FI            | int/long/double optimized variants      |
| Custom FI               | User-defined with 1 abstract method     |
| Default methods impact? | Do NOT affect FI rule                   |
| Method reference        | Short form to implement FI              |
| Extending FI            | Allowed (no new abstract methods)       |

---
