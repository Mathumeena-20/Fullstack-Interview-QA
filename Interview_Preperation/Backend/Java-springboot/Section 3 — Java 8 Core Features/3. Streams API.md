# 1. What is Stream in Java 8?

A **Stream** is a sequence of data (objects) that supports **functional-style operations** (map, filter, reduce).

### Key points:

* Does **not store data** → works on data from collections/arrays
* Does **not modify original collection**
* Supports **pipeline processing**
* Supports **lazy evaluation**

### Example:

```java
List<Integer> list = List.of(1, 2, 3, 4);

list.stream()
    .filter(n -> n % 2 == 0)
    .forEach(System.out::println);
```

---

# 2. Difference Between Stream and Collection

| Stream                  | Collection            |
| ----------------------- | --------------------- |
| Used for processing     | Used for storing data |
| Cannot be reused        | Can be reused         |
| Lazy evaluation         | Eager evaluation      |
| Functional operations   | CRUD operations       |
| No modification allowed | Allows modification   |
| Can be infinite         | Must be finite        |

---

# 3. Intermediate vs Terminal Operations

### Intermediate Operations

* Return a **new stream**
* Lazy (not executed immediately)
* Examples: `filter()`, `map()`, `sorted()`, `distinct()`, `limit()`

### Terminal Operations

* Produce result
* Trigger **pipeline execution**
* Examples: `forEach()`, `collect()`, `reduce()`, `count()`

### Example:

```java
list.stream()
    .filter(n -> n > 10)     // intermediate
    .sorted()                // intermediate
    .forEach(System.out::println);   // terminal
```

---

# 4. What is Lazy Evaluation?

Stream operations are processed **only when a terminal operation is called**.

### Example:

```java
Stream<Integer> s = list.stream().filter(n -> {
    System.out.println("Filtering: " + n);
    return n % 2 == 0;
});

System.out.println("No output yet");

s.forEach(System.out::println);   // executes filter here
```

---

# 5. Difference Between `map()` & `flatMap()`

### `map()`

Transforms each element → one value.
1 input → 1 output.

### Example:

```java
List<String> names = List.of("John", "Joe");

List<Integer> lengths = 
    names.stream().map(String::length).toList();
```

---

### `flatMap()`

Transforms each element → **multiple values**, then flattens them.

### Example:

```java
List<List<Integer>> list = List.of(
    List.of(1,2),
    List.of(3,4)
);

List<Integer> flat = 
    list.stream()
        .flatMap(l -> l.stream())
        .toList();
```

Output:

```
1 2 3 4
```

---

# 6. What is a Parallel Stream? When to Avoid It?

### Parallel Stream:

A stream that splits data into multiple threads for faster processing.

```java
list.parallelStream().forEach(System.out::println);
```

### When to avoid:

❌ Small data sets
❌ Complex objects
❌ Stateful operations
❌ Thread-unsafe code
❌ When order matters

---

# 7. Common Stream Operations

## 1. filter()

Keeps only elements matching condition.

```java
list.stream().filter(n -> n > 10);
```

---

## 2. sorted()

Sorts elements.

```java
list.stream().sorted();
```

---

## 3. limit()

Returns first N elements.

```java
list.stream().limit(3);
```

---

## 4. distinct()

Removes duplicates.

```java
list.stream().distinct();
```

---

# 8. Difference Between forEach() and forEachOrdered()

| forEach()                       | forEachOrdered()           |
| ------------------------------- | -------------------------- |
| Order not guaranteed (parallel) | Guarantees encounter order |
| Faster                          | Slightly slower            |
| Used for parallel streams       | Used when order matters    |

### Example:

```java
list.parallelStream().forEach(System.out::println);        // unordered
list.parallelStream().forEachOrdered(System.out::println); // ordered
```

---

# 9. What is Collectors Class?

A utility class that provides methods to **collect stream results** into:

* List
* Set
* Map
* Grouping
* Partitioning
* Joining Strings

Example:

```java
List<Integer> result = 
    list.stream().filter(n -> n > 5).collect(Collectors.toList());
```

---

# 10. groupingBy() & partitioningBy()

## groupingBy()

Groups data based on classification function.

### Example:

```java
Map<Integer, List<Integer>> map =
    list.stream().collect(Collectors.groupingBy(n -> n % 2));
```

Output:

```
0 → [even numbers]
1 → [odd numbers]
```

---

## partitioningBy()

Splits data into only **two groups**: true and false.

### Example:

```java
Map<Boolean, List<Integer>> map =
    list.stream().collect(Collectors.partitioningBy(n -> n > 10));
```

---

# 11. What is reduce()?

`reduce()` combines stream elements to produce a **single result**.

### Example: Sum of numbers

```java
int sum = list.stream()
    .reduce(0, (a, b) -> a + b);
```

### Example: Maximum value

```java
int max = list.stream().reduce(Integer::max).get();
```

---

# 12. How Streams Improve Readability & Performance?

### ✔ Readability

* No loops
* Functional programming style
* Cleaner code

### ✔ Performance

* Lazy evaluation
* Parallel execution
* Pipeline optimizations
* Avoids unnecessary operations

### Example (Readable & Efficient):

```java
List<String> result =
    names.stream()
         .filter(n -> n.startsWith("A"))
         .map(String::toUpperCase)
         .sorted()
         .toList();
```

---

# ✅ Final Summary

| Concept         | Key Explanation               |
| --------------- | ----------------------------- |
| Stream          | For processing data           |
| map vs flatMap  | 1-to-1 vs 1-to-many           |
| Lazy evaluation | Executes only on terminal ops |
| parallelStream  | Multi-threaded, but risky     |
| reduce          | Combine into single result    |
| groupingBy      | Multi-group                   |
| partitioningBy  | True/False                    |

---

