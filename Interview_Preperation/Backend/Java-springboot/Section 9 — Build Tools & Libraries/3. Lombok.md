# ⭐ 1. What is Lombok and why do we use it?

**Lombok** is a Java library that generates boilerplate code **at compile time** using annotations.

We use it to avoid writing repetitive code like:

✔ Getters
✔ Setters
✔ Constructors
✔ equals(), hashCode()
✔ toString()
✔ Builder pattern

Example without Lombok:

```java
public class User {
    private String name;
    private int age;

    public User() {}
    public User(String name, int age) { ... }

    public String getName() { ... }
    public void setName(String name) { ... }
}
```

With Lombok:

```java
@Data
public class User {
    private String name;
    private int age;
}
```

❇ Reduces hundreds of lines → a few annotations.

---

# ⭐ 2. How does Lombok reduce boilerplate code?

Lombok uses **annotation processing** to automatically generate code during compilation.

Examples:

* `@Getter` → generates getter methods
* `@Setter` → generates setter methods
* `@Builder` → creates builder pattern
* `@Data` → getters + setters + equals + hashCode + toString

---

# ⭐ 3. What is annotation processing?

Annotation processing is a **compile-time mechanism** where tools analyze annotations and generate additional code.

Lombok uses the `javax.annotation.processing` API to insert:

✔ Methods
✔ Constructors
✔ Builders
✔ Logging fields

into the **compiled .class file**, not into the source code.

The developer writes less code but gets full functionality.

---

# ⭐ 4. Common Lombok annotations you used (with examples)

### ✔ @Getter and @Setter

```java
@Getter
@Setter
public class Employee {
    private int id;
    private String name;
}
```

### ✔ @Data (includes Getter, Setter, Equals, HashCode, ToString)

```java
@Data
public class Book {
    private String title;
    private double price;
}
```

### ✔ @Builder

```java
@Builder
public class Car {
    private String model;
    private int year;
}
```

Usage:

```java
Car c = Car.builder().model("BMW").year(2024).build();
```

### ✔ @AllArgsConstructor / @NoArgsConstructor

```java
@AllArgsConstructor
@NoArgsConstructor
public class Student {
    private String name;
    private int age;
}
```

---

# ⭐ 5. Difference between @Data and @Value

| @Data                           | @Value                         |
| ------------------------------- | ------------------------------ |
| Mutable class                   | Immutable class                |
| Generates setters               | No setters                     |
| Fields are not final            | All fields are `private final` |
| equals/hashCode based on fields | Same, but immutable            |
| Used for POJO                   | Used for value objects (DTOs)  |

Example:

```java
@Value
public class Address {
    String city;
    String country;
}
```

Immutable object → thread-safe & safe for caching.

---

# ⭐ 6. Difference between @Builder and @SuperBuilder

| @Builder                              | @SuperBuilder                              |
| ------------------------------------- | ------------------------------------------ |
| Works for single class                | Works for inheritance                      |
| Cannot build subclass + parent fields | Can build subclass including parent fields |

Example:

### Problem with @Builder:

```java
class A { int id; }
class B extends A { String name; }
```

`@Builder` doesn't support inheritance.

### Working example with @SuperBuilder:

```java
@SuperBuilder
class A { int id; }

@SuperBuilder
class B extends A { String name; }
```

Usage:

```java
B b = B.builder().id(1).name("John").build();
```

---

# ⭐ 7. How Lombok integrates with IDE?

IDEs (IntelliJ, Eclipse, VS Code) use:

✔ Lombok plugin
✔ Annotation processor enabled

The IDE must understand Lombok-generated code for:

* Autocomplete
* Error checking
* Navigation

In IntelliJ:

```
Settings → Build Tools → Annotation processors → Enable
Settings → Plugins → Lombok → Install
```

---

# ⭐ 8. Common problems with Lombok

1. **IDE not configured → missing methods errors**
2. **Debugging difficult** (generated code not visible)
3. **Conflicts with other annotation processors**
4. **Lombok-generated equals()/hashCode() cause recursion**
5. **Cannot serialize builder-only classes easily**
6. **Version mismatch with Java 17+**

---

# ⭐ 9. How to debug Lombok-generated code?

### Method 1: Use **Delombok**

Run:

```
./gradlew delombok
```

or in IntelliJ:

```
Tools → Lombok → Delombok
```

This shows the **actual generated code**.

### Method 2: Inspect compiled `.class` file using:

* IntelliJ “Decompiled class” view
* javap command

```
javap -c MyClass
```

---

# ⭐ 10. Why some companies avoid Lombok?

### ✔ 1. Debugging difficulty

Generated code is not visible → harder to diagnose issues.

### ✔ 2. Vendor lock-in

Code depends on Lombok; switching away is painful.

### ✔ 3. Build issues

Annotation processing conflicts in some projects.

### ✔ 4. Reduced transparency

Developers may not understand what’s happening behind the scenes.

### ✔ 5. Reflection libraries break

Frameworks that rely on default constructors or pure Java code may face issues.

### ✔ 6. Learning curve

New developers may not understand Lombok annotations quickly.

### ✔ 7. Security concerns

Generated equals()/hashCode() or toString() may expose sensitive fields.

---

# ⭐ Example Class Using Lombok (All Concepts)

```java
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Employee {
    private String name;
    private int salary;

    private transient String password;  // Will not appear in toString()
}
```

### Generated methods include:

* getName(), setName()
* getSalary(), setSalary()
* equals(), hashCode()
* toString()
* Builder pattern
* Constructors

---

# ⭐ Summary for Interview Revision

| Question                  | Short Answer                                       |
| ------------------------- | -------------------------------------------------- |
| Lombok                    | Reduces boilerplate using annotations              |
| How reduce code           | Generates getters, setters, constructors, builders |
| Annotation processing     | Compile-time code generation                       |
| Common annotations        | @Data, @Getter, @Setter, @Builder                  |
| @Data vs @Value           | Mutable vs immutable                               |
| @Builder vs @SuperBuilder | Single class vs inheritance support                |
| IDE integration           | Plugin + annotation processors                     |
| Common problems           | Debugging, version issues, vendor lock             |
| Debug Lombok              | Delombok, decompiled class                         |
| Why avoid Lombok?         | Debug issues, hidden code, lock-in                 |

---

