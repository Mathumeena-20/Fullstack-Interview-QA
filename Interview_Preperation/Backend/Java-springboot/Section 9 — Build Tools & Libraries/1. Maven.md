# **1. What is the Java NIO Files API?**

The **Java NIO Files API (java.nio.file.Files)** is a modern file-handling API introduced in **Java 7** that provides:

✔ High-performance file operations
✔ Better error handling (throws meaningful exceptions)
✔ Advanced features: symbolic links, file attributes, atomic moves
✔ Support for **Path** instead of legacy `File`
✔ Easy copy, move, delete, walk directory trees

---

# **2. Difference between Files and File class**

| Feature             | `java.io.File`        | `java.nio.file.Files`              |
| ------------------- | --------------------- | ---------------------------------- |
| API age             | Legacy (Java 1.0)     | Modern (Java 7+)                   |
| Error handling      | Boolean result (poor) | Throws IOException                 |
| Features            | Limited               | Very rich (copy, move, attributes) |
| Symbolic links      | No real support       | Full support                       |
| Directory traversal | Manual                | walkFileTree(), list(), walk()     |
| Performance         | Slower                | Faster + optimized                 |

---

# **3. How do you read a file using Files.readAllLines()?**

```java
Path path = Paths.get("data.txt");

List<String> lines = Files.readAllLines(path);

for (String line : lines) {
    System.out.println(line);
}
```

✔ Returns entire file as List<String>
⚠️ Avoid for large files (loads whole file in memory)

---

# **4. Difference between Paths.get() and File**

| Paths.get()        | new File()                |
| ------------------ | ------------------------- |
| Returns a **Path** | Returns a **File** object |
| Used with NIO      | Used with legacy IO       |
| More powerful      | Fewer capabilities        |
| Immutable Path     | Mutable File              |

Example:

```java
Path path = Paths.get("data.txt");
File file = new File("data.txt");
```

---

# **5. How do you write data to a file using Files class?**

### Write bytes:

```java
Files.write(Paths.get("output.txt"), "Hello world".getBytes());
```

### Write list of strings:

```java
List<String> lines = List.of("A", "B", "C");
Files.write(Paths.get("output.txt"), lines);
```

### Append to a file:

```java
Files.write(Paths.get("log.txt"),
            "New line\n".getBytes(),
            StandardOpenOption.APPEND);
```

---

# **6. What is Path interface?**

`java.nio.file.Path` represents a file system path.

✔ Better abstraction than `File`
✔ Immutable
✔ Supports path operations

Example:

```java
Path p = Paths.get("folder", "file.txt");

System.out.println(p.getFileName());
System.out.println(p.toAbsolutePath());
System.out.println(p.getParent());
```

---

# **7. How do you check if a file exists using NIO?**

```java
Path path = Paths.get("config.json");

if (Files.exists(path)) {
    System.out.println("File exists");
}
```

---

# **8. How to copy, move and delete files using Files API?**

### Copy:

```java
Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);
```

### Move:

```java
Files.move(oldPath, newPath, StandardCopyOption.REPLACE_EXISTING);
```

### Delete:

```java
Files.delete(path);             // throws exception if not found
Files.deleteIfExists(path);     // safe version
```

---

# **9. How do you get file attributes using Files?**

### Basic attributes:

```java
Path p = Paths.get("data.txt");

BasicFileAttributes attrs = Files.readAttributes(p, BasicFileAttributes.class);

System.out.println(attrs.size());
System.out.println(attrs.creationTime());
System.out.println(attrs.lastModifiedTime());
```

### DOS attributes:

```java
DosFileAttributes dos = Files.readAttributes(p, DosFileAttributes.class);
```

### POSIX attributes (Linux/Unix):

```java
PosixFileAttributes posix = Files.readAttributes(p, PosixFileAttributes.class);
```

---

# **10. Explain StandardOpenOption with examples**

Options that control file opening behavior:

| Option            | Meaning                   |
| ----------------- | ------------------------- |
| CREATE            | Create file if missing    |
| CREATE_NEW        | Fail if file exists       |
| APPEND            | Write at end of file      |
| WRITE             | Enable write mode         |
| READ              | Enable read mode          |
| TRUNCATE_EXISTING | Clear file before writing |

Example:

```java
Files.write(Paths.get("app.log"),
            "Log Entry\n".getBytes(),
            StandardOpenOption.CREATE,
            StandardOpenOption.APPEND);
```

---

# **11. Difference between blocking IO and non-blocking IO**

| Feature         | Blocking IO                        | Non-blocking IO (NIO)   |
| --------------- | ---------------------------------- | ----------------------- |
| Thread behavior | Thread waits                       | Thread continues        |
| Scalability     | Low                                | High                    |
| APIs            | Streams (InputStream/OutputStream) | Channels + Selectors    |
| Best for        | Simple apps                        | High throughput servers |
| Performance     | Slower                             | Faster                  |

Example:

* Blocking: `FileInputStream.read()`
* Non-blocking: `FileChannel.read(buffer)`

---

# **12. How do you create temporary files and directories?**

### Temporary file:

```java
Path temp = Files.createTempFile("prefix_", ".tmp");
```

### Temporary directory:

```java
Path tempDir = Files.createTempDirectory("myTmpDir_");
```

✔ OS deletes them automatically (depending on environment)

---

# **13. What is an atomic file operation?**

An operation that is **either fully completed or not done at all**.

Example using `ATOMIC_MOVE`:

```java
Files.move(tempFile, finalFile, StandardCopyOption.ATOMIC_MOVE);
```

Used to prevent:
✔ Partial writes
✔ Corrupted files
✔ Crash-related failures

---

# **14. How do you read large files efficiently using Files?**

Avoid `readAllLines()`.
Use:

### **BufferedReader (Efficient)**:

```java
try (BufferedReader br = Files.newBufferedReader(path)) {
    String line;
    while ((line = br.readLine()) != null) {
        // process line
    }
}
```

### **Files.lines() (stream-based)**:

```java
Files.lines(path).forEach(System.out::println);
```

### **FileChannel + ByteBuffer (most efficient)**:

```java
try (FileChannel fc = FileChannel.open(path)) {
    ByteBuffer buffer = ByteBuffer.allocate(1024);
    while (fc.read(buffer) > 0) {
        buffer.flip();
        System.out.println(new String(buffer.array(), 0, buffer.remaining()));
        buffer.clear();
    }
}
```

---

# **15. Real-time use case where you preferred NIO Files over traditional IO**

### **Scenario: Processing 10GB log files in a microservice**

Traditional IO:

* Slow
* Byte-by-byte
* High CPU usage
* Hard to handle millions of lines

NIO advantages:
✔ Efficient buffered read
✔ Supports file streaming
✔ Zero-copy using FileChannel
✔ Can monitor folder using WatchService
✔ Retrieve creation time / last modified quickly

```java
Files.lines(Paths.get("logs/app.log"))
     .filter(l -> l.contains("ERROR"))
     .forEach(System.out::println);
```

Result:
✔ Processed GBs of logs with **low memory usage**
✔ Achieved **3x faster performance** than old IO

---

# ⭐ Final Interview Summary Table

| Topic                    | Short Answer                             |
| ------------------------ | ---------------------------------------- |
| NIO Files API            | Modern high-performance file API         |
| Files vs File            | Files = powerful, File = legacy          |
| readAllLines             | Loads all lines (small files only)       |
| Paths.get vs File        | Path is newer, immutable                 |
| Write                    | Files.write                              |
| Path interface           | Represents filesystem path               |
| File exists              | Files.exists                             |
| Copy/move/delete         | Files.copy/move/delete                   |
| File attributes          | BasicFileAttributes, DOS, POSIX          |
| StandardOpenOption       | CREATE, APPEND, WRITE, etc.              |
| Blocking vs non-blocking | NIO is scalable                          |
| Temp files               | createTempFile()                         |
| Atomic operation         | ATOMIC_MOVE                              |
| Large file reading       | BufferedReader, Files.lines, FileChannel |
| Real use case            | Fast log processing, file streaming      |

---

