# **1. Difference between Maven and Gradle**

| Feature               | Maven                         | Gradle                                    |
| --------------------- | ----------------------------- | ----------------------------------------- |
| Build language        | XML (pom.xml)                 | DSL (Groovy/Kotlin)                       |
| Performance           | Slower                        | Faster (incremental + parallel + caching) |
| Flexibility           | Convention over configuration | Highly customizable                       |
| Build speed           | Linear                        | Incremental + cache                       |
| Dependency management | Stable                        | Advanced resolution                       |
| Multi-project support | Good                          | Excellent                                 |
| Scripts               | Static                        | Programmable                              |
| Build cache           | No                            | Yes                                       |

---

# **2. What is Gradle and why is it faster than Maven?**

Gradle is a **modern, flexible build automation tool** supporting Java, Kotlin, Groovy, Android, Scala, etc.

### ✔ Why faster?

1. **Incremental builds** → only changed tasks run
2. **Build caching** → reuse outputs from previous builds
3. **Parallel execution** → tasks run in parallel
4. **Daemon process** → Gradle stays in memory
5. **Efficient dependency resolution**

Result:
**40–90% faster than Maven in most projects.**

---

# **3. Explain Gradle build lifecycle**

Gradle build lifecycle has **3 phases**:

### **1. Initialization**

* Identifies all projects
* Sets up multi-project structure

### **2. Configuration**

* Evaluates all `build.gradle` files
* Configures tasks

### **3. Execution**

* Runs requested tasks
* e.g., `./gradlew build`, `./gradlew test`

---

# **4. What is build.gradle?**

`build.gradle` is the main build script written in **Groovy DSL** (Kotlin DSL = `build.gradle.kts`).

It defines:

* Plugins
* Dependencies
* Repositories
* Tasks
* Build logic

Example:

```groovy
plugins {
    id 'java'
}

dependencies {
    implementation 'com.google.guava:guava:32.0'
}
```

---

# **5. Difference between Groovy DSL and Kotlin DSL**

| Groovy DSL                 | Kotlin DSL          |
| -------------------------- | ------------------- |
| Dynamic language           | Statically typed    |
| Filename: `build.gradle`   | `build.gradle.kts`  |
| More concise               | Better IDE support  |
| Used in Android by default | Faster autocomplete |

Both are functionally identical.

---

# **6. How do dependencies work in Gradle?**

Inside `dependencies` block:

```groovy
dependencies {
    implementation 'org.slf4j:slf4j-api:2.0.9'
    testImplementation 'junit:junit:4.13.2'
}
```

Gradle resolves dependencies using:

* Maven Central
* JCenter
* Local repositories

---

# **7. What is Gradle Wrapper?**

Gradle Wrapper = `gradlew` and `gradlew.bat` + wrapper files.

✔ Allows project to use a **fixed Gradle version**
✔ No need to install Gradle manually
✔ Ensures build reproducibility

Run using:

```
./gradlew build
```

---

# **8. Difference between implementation and api configuration**

| Keyword            | Visibility                    | Use Case                             |
| ------------------ | ----------------------------- | ------------------------------------ |
| **implementation** | Internal to module            | Consumers do NOT see transitive deps |
| **api**            | Exposed to downstream modules | Required by consumers                |

Example:

```groovy
dependencies {
    implementation 'com.google.guava:guava:32.0'   // internal
    api 'org.apache.commons:commons-lang3:3.12.0'  // exposed
}
```

---

# **9. How does Gradle support incremental builds?**

Gradle tracks:

* Inputs (source, config)
* Outputs (compiled classes)

If nothing changed → **task is UP-TO-DATE**, so skipped.

Example:

```
> Task :compileJava UP-TO-DATE
```

✔ Saves time
✔ Only re-runs changed parts
✔ Works for large projects

---

# **10. What is a Gradle task?**

A **task** is a unit of work in Gradle.

Examples:

* compileJava
* test
* clean
* jar
* custom tasks

Run using:

```
./gradlew test
```

---

# **11. How do you create a custom task in Gradle?**

Groovy DSL:

```groovy
task hello {
    doLast {
        println "Hello from Gradle!"
    }
}
```

Kotlin DSL:

```kotlin
tasks.register("hello") {
    doLast {
        println("Hello from Gradle!")
    }
}
```

Run:

```
./gradlew hello
```

---

# **12. What is a multi-project build in Gradle?**

It is a project that contains multiple modules:

```
root/
  settings.gradle
  module1/
    build.gradle
  module2/
    build.gradle
```

In settings.gradle:

```groovy
include 'module1', 'module2'
```

✔ Dependency sharing
✔ Faster multi-module builds
✔ Used in microservices & monorepos

---

# **13. How do you skip tests in Gradle?**

### Command line:

```
./gradlew build -x test
```

### In build.gradle:

```groovy
test {
    enabled = false
}
```

---

# **14. What is a plugin in Gradle?**

A plugin adds new capabilities (tasks, configurations).

Examples:

* Java plugin
* Application plugin
* Spring Boot plugin
* Kotlin plugin
* Android plugin

Groovy DSL:

```groovy
plugins {
    id 'java'
    id 'application'
}
```

---

# **15. How does Gradle handle dependency version conflicts?**

Gradle follows **conflict resolution strategies**:

### ✔ 1. Default Strategy: “Newest version wins”

Example:

* Module requires: log4j:2.12
* Another requires: log4j:2.18
  → Gradle picks log4j:2.18

### ✔ 2. You can force a version:

```groovy
configurations.all {
    resolutionStrategy {
        force 'log4j:log4j:1.2.17'
    }
}
```

### ✔ 3. Reject versions:

```groovy
resolutionStrategy {
    rejectVersionIf { it.candidate.version.contains("beta") }
}
```

### ✔ 4. Dependency locking

Ensures consistent versions across builds.

---

# ⭐ Full Summary Table

| Question              | Short Answer                        |
| --------------------- | ----------------------------------- |
| Maven vs Gradle       | Gradle faster, flexible, groovy DSL |
| Why Gradle fast?      | Incremental, cache, parallel        |
| Gradle lifecycle      | Init → Config → Execute             |
| build.gradle          | Build script                        |
| Groovy vs Kotlin DSL  | Dynamic vs statically typed         |
| Dependency mechanism  | Under dependencies block            |
| Wrapper               | Ensures fixed Gradle version        |
| implementation vs api | Internal vs exported deps           |
| Incremental build     | Skips unchanged tasks               |
| Task                  | Unit of work                        |
| Custom task           | Using task {}                       |
| Multi-project         | Multiple modules                    |
| Skip tests            | `-x test`                           |
| Plugin                | Adds build features                 |
| Version conflicts     | Newest version, force, reject       |

---
