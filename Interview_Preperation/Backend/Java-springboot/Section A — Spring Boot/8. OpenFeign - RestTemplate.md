# üîµ **RESTTEMPLATE (Legacy HTTP Client)**

---

# ‚≠ê 1. What is RestTemplate?

`RestTemplate` is a **synchronous** (blocking) HTTP client provided by Spring.

Used for:
‚úî Calling external REST APIs
‚úî Microservice-to-microservice communication
‚úî Simple GET/POST/PUT/DELETE requests

Example:

```java
RestTemplate rest = new RestTemplate();
String response = rest.getForObject("https://api.example.com/data", String.class);
```

‚ö†Ô∏è **RestTemplate is deprecated** for future versions.
Spring recommends **WebClient**.

---

# ‚≠ê 2. Difference between RestTemplate and WebClient

| Feature      | RestTemplate           | WebClient                  |
| ------------ | ---------------------- | -------------------------- |
| Model        | Blocking               | **Non-blocking**, reactive |
| Performance  | Limited                | High-performance           |
| For          | Simple apps            | Microservices, concurrency |
| Thread usage | One thread per request | Event-loop / fewer threads |
| Supported    | Deprecated             | Recommended                |

Use **WebClient** for:

* High load
* Streaming
* Reactive APIs
* Non-blocking services

---

# ‚≠ê 3. How do you configure timeout in RestTemplate?

```java
@Bean
public RestTemplate restTemplate() {
    HttpComponentsClientHttpRequestFactory factory =
            new HttpComponentsClientHttpRequestFactory();
    factory.setConnectTimeout(3000);
    factory.setReadTimeout(5000);

    return new RestTemplate(factory);
}
```

‚úî connectTimeout ‚Üí time to connect
‚úî readTimeout ‚Üí waiting for server response

---

# ‚≠ê 4. How to handle errors in RestTemplate?

### Option 1 ‚Äî Custom ErrorHandler

```java
restTemplate.setErrorHandler(new ResponseErrorHandler() {
    @Override
    public boolean hasError(ClientHttpResponse response) {
        return response.getStatusCode().isError();
    }

    @Override
    public void handleError(ClientHttpResponse response) throws IOException {
        System.out.println("Error code: " + response.getStatusCode());
    }
});
```

### Option 2 ‚Äî Handle using try‚Ä¶catch

```java
try {
    ResponseEntity<String> res = rest.getForEntity(url, String.class);
} catch (HttpClientErrorException ex) {
    // 4xx error
} catch (HttpServerErrorException ex) {
    // 5xx error
}
```

---

# üîµ **OPENFEIGN (Declarative REST Client)**

---

# ‚≠ê 5. What is OpenFeign?

**OpenFeign** is a **declarative HTTP client** created by Netflix and used by Spring Cloud.

It allows calling REST APIs by **writing only an interface**, not code.

Example:

```java
@FeignClient(name = "user-service")
public interface UserClient {
    @GetMapping("/users/{id}")
    User getUser(@PathVariable Long id);
}
```

Spring auto-generates the implementation.

---

# ‚≠ê 6. How does Feign work internally?

1. Spring scans `@FeignClient` interfaces
2. Creates a **dynamic proxy** implementation
3. Proxy builds an HTTP request using:

   * URL mapping
   * Method signature
   * Parameters
4. Uses **RestTemplate/WebClient/Apache client** internally
5. Executes HTTP request
6. Converts JSON to POJO using Jackson

Supports:
‚úî Load balancing (with Spring Cloud LoadBalancer)
‚úî Retry
‚úî Circuit breaker (Resilience4j)

---

# ‚≠ê 7. How do you enable Feign client in Spring Boot?

Add dependency:

```xml
<dependency>
  <groupId>org.springframework.cloud</groupId>
  <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```

Add to main class:

```java
@EnableFeignClients
@SpringBootApplication
public class MyApp { }
```

Create a Feign client:

```java
@FeignClient(name = "orders")
public interface OrderClient {
    @GetMapping("/orders/{id}")
    Order getOrder(@PathVariable Long id);
}
```

---

# ‚≠ê 8. How do you add headers to Feign request?

### Option 1 ‚Äî Using @RequestHeader

```java
@FeignClient(name = "auth-service")
public interface AuthClient {
    @GetMapping("/validate")
    User validate(@RequestHeader("Authorization") String token);
}
```

### Option 2 ‚Äî Feign RequestInterceptor (recommended)

```java
@Bean
public RequestInterceptor authInterceptor() {
    return request -> {
        request.header("Authorization", "Bearer xyz");
    };
}
```

Best for:
‚úî Adding JWT tokens
‚úî Adding trace IDs
‚úî Multi-tenant headers

---

# ‚≠ê 9. How do you configure Feign timeout?

Add config class:

```java
@Configuration
public class FeignConfig {

    @Bean
    public Request.Options options() {
        return new Request.Options(3000, 5000); // connect, read timeout
    }
}
```

Use it:

```java
@FeignClient(name = "orders", configuration = FeignConfig.class)
public interface OrderClient { }
```

---

# ‚≠ê 10. Feign vs RestTemplate vs WebClient

| Feature        | RestTemplate | WebClient        | Feign         |
| -------------- | ------------ | ---------------- | ------------- |
| Style          | Imperative   | Reactive         | Declarative   |
| Blocking       | ‚úî Yes        | ‚ùå No             | ‚úî Yes         |
| Best for       | Simple calls | High concurrency | Microservices |
| Load Balancing | Manual       | Manual           | **Automatic** |
| Ease of use    | Medium       | Medium           | **Very easy** |
| Production use | Legacy       | Modern           | Microservices |

### Summary:

* Use **WebClient** for reactive/non-blocking systems
* Use **Feign** for microservices calling other microservices
* Avoid new RestTemplate usage

---

# üîµ **Complete Example**

### Feign Client

```java
@FeignClient(name = "payment-service", url = "http://localhost:8082")
public interface PaymentClient {

    @PostMapping("/pay")
    PaymentResponse pay(@RequestBody PaymentRequest request);
}
```

### Controller

```java
@RestController
public class OrderController {

    @Autowired
    private PaymentClient paymentClient;

    @PostMapping("/order")
    public OrderResponse placeOrder(@RequestBody OrderRequest req) {
        PaymentResponse pay = paymentClient.pay(new PaymentRequest(req.getAmount()));
        return new OrderResponse("SUCCESS", pay.getStatus());
    }
}
```

---

# ‚≠ê FINAL INTERVIEW SUMMARY

### **RestTemplate**

‚úî Synchronous, blocking
‚úî Timeouts via HttpComponents
‚úî Error handling using ErrorHandler
‚úî Deprecated + replaced by WebClient

### **OpenFeign**

‚úî Declarative REST client
‚úî Interface-based
‚úî Dynamic proxy
‚úî Easy headers + timeout
‚úî Great for microservices

### **Comparisons**

* RestTemplate = simple legacy HTTP client
* WebClient = modern reactive
* Feign = declarative microservice client

---

