# ‚≠ê 1. What is Spring Data JPA?

**Spring Data JPA** is a Spring module that simplifies database operations using **JPA (Java Persistence API)**.

It provides:

‚úî Prebuilt repositories
‚úî Auto-implemented queries
‚úî Pagination & sorting
‚úî Transaction management
‚úî Less boilerplate code

Example:

```java
public interface UserRepository extends JpaRepository<User, Long> { }
```

Spring generates all CRUD methods automatically.

---

# ‚≠ê 2. Difference between JPA and Hibernate

| Feature       | **JPA**         | **Hibernate**     |
| ------------- | --------------- | ----------------- |
| Type          | Specification   | Implementation    |
| Who provides? | Oracle/Java EE  | Hibernate team    |
| What it does? | Defines API     | Actual ORM engine |
| Example       | `EntityManager` | `Session`         |

**Hibernate implements JPA.**

---

# ‚≠ê 3. What is an Entity?

An **Entity** represents a table in the database.

Example:

```java
@Entity
@Table(name = "users")
public class User {
    @Id
    private Long id;

    private String name;
}
```

‚úî Each instance = one row
‚úî Fields = columns

---

# ‚≠ê 4. What is a Repository?

Repository is a Java interface that provides data-access operations.

Example:

```java
public interface UserRepository extends JpaRepository<User, Long> { }
```

Spring Data JPA automatically implements CRUD methods.

---

# ‚≠ê 5. Difference between CrudRepository and JpaRepository

| CrudRepository        | JpaRepository                       |
| --------------------- | ----------------------------------- |
| Basic CRUD            | CRUD + pagination + sorting         |
| findOne, save, delete | More powerful methods               |
| Minimal API           | Full JPA features                   |
| No batch operations   | flush(), saveAll(), deleteInBatch() |

Recommendation:
üëâ Use **JpaRepository** for real projects.

---

# ‚≠ê 6. What is @Transactional?

`@Transactional` manages database transactions.

‚úî Begins a transaction
‚úî Commits on success
‚úî Rolls back on exception

Example:

```java
@Transactional
public void transferMoney() { ... }
```

Reasons to use:

* Ensures data consistency
* Prevents partial updates
* Required for lazy loading

---

# ‚≠ê 7. What is LAZY and EAGER loading?

### **LAZY (default for @OneToMany, ManyToMany)**

Only loads data **when accessed**.

Example:

```java
@OneToMany(fetch = FetchType.LAZY)
private List<Order> orders;
```

‚úî Better performance
‚ùå Can cause LazyInitializationException if accessed outside transaction

### **EAGER**

Loads related data **immediately**.

```java
@ManyToOne(fetch = FetchType.EAGER)
private Customer customer;
```

‚úî Simple
‚ùå Slower, loads unnecessary data

---

# ‚≠ê 8. What is JPQL?

**JPQL (Java Persistence Query Language)** is an object-oriented query language.

It uses **entity names and fields**, not table names.

Example:

```java
@Query("SELECT u FROM User u WHERE u.name = :name")
List<User> findByName(String name);
```

---

# ‚≠ê 9. What is paging and sorting?

Spring provides built-in pagination and sorting.

Example:

```java
Page<User> page = repo.findAll(PageRequest.of(0, 10));
```

Sorting:

```java
List<User> list = repo.findAll(Sort.by("name").ascending());
```

---

# ‚≠ê 10. What are projections?

Projections allow fetching **partial fields** instead of entire entity.

Example: Interface Projection

```java
public interface UserView {
    String getName();
}
```

Repository:

```java
List<UserView> findBy();
```

‚úî Saves performance
‚úî Reduces data load

---

# ‚≠ê 11. What is the N+1 problem?

Occurs when:

* First query loads all parent records (**N** records)
* For each record, another query loads child records (**N additional queries**)

Example:

```
SELECT * FROM users;    -- 1 query
SELECT * FROM orders where user_id = ?;   -- repeated N times
```

Total queries = **N + 1**

---

# ‚≠ê 12. How do you solve N+1 issues?

‚úî Use **JOIN FETCH**

```java
@Query("SELECT u FROM User u JOIN FETCH u.orders")
List<User> findAllUsersWithOrders();
```

‚úî Use **EntityGraph**

```java
@EntityGraph(attributePaths = {"orders"})
List<User> findAll();
```

‚úî Change to **EAGER loading** (not recommended globally)
‚úî Use **batch size**

```java
@BatchSize(size = 10)
```

---

# ‚≠ê 13. Difference between native query and JPQL

| JPQL                 | Native Query             |
| -------------------- | ------------------------ |
| Works on Entities    | Works on Tables          |
| Database Independent | Database dependent       |
| Portable             | Not portable             |
| Uses entity fields   | Uses actual column names |

Example ‚Äî JPQL:

```java
@Query("SELECT u FROM User u")
```

Example ‚Äî Native:

```java
@Query(value = "SELECT * FROM users", nativeQuery = true)
```

---

# ‚≠ê 14. What is dirty checking?

Dirty checking = Hibernate automatically updates changes to an entity before transaction commit.

Example:

```java
@Transactional
public void updateUser() {
    User u = repo.findById(1L).get();
    u.setName("Updated Name");  // no save() needed
}
```

Hibernate detects changes ‚Üí issues UPDATE query.

---

# ‚≠ê 15. How do you define composite primary key?

Two ways:

### **1. @IdClass**

```java
@Entity
@IdClass(OrderId.class)
public class Order {
    @Id private Long userId;
    @Id private Long productId;
}
```

### **2. @EmbeddedId**

(Recommended)

```java
@Embeddable
public class OrderId {
    private Long userId;
    private Long productId;
}

@Entity
public class Order {
    @EmbeddedId
    private OrderId id;
}
```

‚úî Better design
‚úî Clear structure

---

# ‚≠ê Final Interview Summary

| Topic                 | Quick Explanation                      |
| --------------------- | -------------------------------------- |
| Spring Data JPA       | Simplifies DB access with repositories |
| JPA vs Hibernate      | API vs implementation                  |
| Entity                | Class mapped to table                  |
| Repository            | Interface for DB access                |
| Crud vs JpaRepository | Basic CRUD vs full JPA features        |
| @Transactional        | Manages DB transaction                 |
| LAZY vs EAGER         | When to load relationships             |
| JPQL                  | Object-based queries                   |
| Paging & sorting      | PageRequest, Sort                      |
| Projections           | Partial field fetch                    |
| N+1 problem           | Too many queries                       |
| Fix N+1               | JOIN FETCH / EntityGraph               |
| Native vs JPQL        | Table vs entity fields                 |
| Dirty checking        | Auto-update of modified entities       |
| Composite key         | @IdClass / @EmbeddedId                 |

---

