# üîµ **1. What is @ControllerAdvice?**

`@ControllerAdvice` is a **global exception handler** in Spring that applies to **all controllers** in the application.

It is used to:

‚úî Handle exceptions globally
‚úî Format custom error responses
‚úî Capture validation errors
‚úî Add global model attributes (for MVC)

Acts like a **centralized error-handling layer**.

### Example:

```java
@ControllerAdvice
public class GlobalExceptionHandler {
}
```

---

# üîµ **2. Difference between @ExceptionHandler and Global Handler**

| Feature  | `@ExceptionHandler`           | `@ControllerAdvice`            |
| -------- | ----------------------------- | ------------------------------ |
| Scope    | Applies to **one controller** | Applies to **all controllers** |
| Location | Inside controller class       | In separate global class       |
| Use case | Controller-specific errors    | Project-wide error handling    |

Example local handler:

```java
@ExceptionHandler(UserNotFoundException.class)
public ResponseEntity<?> handleUserNotFound(UserNotFoundException ex) { ... }
```

Global handler uses same annotation but inside `@ControllerAdvice`.

---

# üîµ **3. How do you return custom error response?**

Create a custom error model:

```java
@Data
@AllArgsConstructor
public class ErrorResponse {
    private String message;
    private String path;
    private Instant timestamp;
    private int status;
}
```

Global handler:

```java
@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(UserNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleUserNotFound(
            UserNotFoundException ex,
            HttpServletRequest request) {

        ErrorResponse error = new ErrorResponse(
                ex.getMessage(),
                request.getRequestURI(),
                Instant.now(),
                HttpStatus.NOT_FOUND.value()
        );

        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(error);
    }
}
```

Response:

```json
{
  "message": "User not found",
  "path": "/users/10",
  "timestamp": "2025-11-29T10:33:22",
  "status": 404
}
```

---

# üîµ **4. How do you handle validation errors globally?**

Handle `MethodArgumentNotValidException`.

```java
@ExceptionHandler(MethodArgumentNotValidException.class)
public ResponseEntity<?> handleValidationErrors(MethodArgumentNotValidException ex) {

    Map<String, String> errors = new HashMap<>();
    ex.getBindingResult().getFieldErrors()
            .forEach(err -> errors.put(err.getField(), err.getDefaultMessage()));

    return ResponseEntity.badRequest().body(errors);
}
```

Sample response:

```json
{
  "email": "must be a valid email",
  "password": "must be at least 8 characters"
}
```

---

# üîµ **5. Difference between checked and unchecked exception handling in Spring**

| Checked Exception                                          | Unchecked Exception                         |
| ---------------------------------------------------------- | ------------------------------------------- |
| Extends `Exception`                                        | Extends `RuntimeException`                  |
| Must be handled with try/catch or throws                   | Optional handling                           |
| Example: `IOException`                                     | Example: `NullPointerException`             |
| Spring converts checked exceptions into `RuntimeException` | Spring recommends custom runtime exceptions |

Spring best practice:
‚úî Use unchecked (`RuntimeException`) for business errors.

---

# üîµ **6. How do you return HTTP status codes using exceptions?**

### Option 1 ‚Äî Use `@ResponseStatus`

```java
@ResponseStatus(HttpStatus.NOT_FOUND)
public class UserNotFoundException extends RuntimeException { }
```

### Option 2 ‚Äî Use ResponseEntity in handler

```java
return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(error);
```

### Option 3 ‚Äî Throw ResponseStatusException

```java
throw new ResponseStatusException(HttpStatus.NOT_FOUND, "User Not Found");
```

---

# üîµ **7. How do you log exceptions globally?**

In GlobalExceptionHandler:

```java
private final Logger log = LoggerFactory.getLogger(GlobalExceptionHandler.class);

@ExceptionHandler(Exception.class)
public ResponseEntity<?> handleAll(Exception ex, HttpServletRequest request) {
    log.error("Exception at path {} : {}", request.getRequestURI(), ex.getMessage(), ex);
    return ResponseEntity.status(500).body("Internal Error");
}
```

Uses:
‚úî ERROR level for real failures
‚úî WARN level for client-side issues

---

# üîµ **8. Can you have multiple ControllerAdvice?**

‚úî **Yes**, you can create multiple `@ControllerAdvice` classes.

Control scope:

### Apply to only specific packages:

```java
@ControllerAdvice(basePackages = "com.app.user")
```

### Apply only to specific annotations:

```java
@ControllerAdvice(annotations = RestController.class)
```

Spring merges all global handlers.

---

# üîµ **9. Best practices for exception handling in REST APIs**

‚úî Use `@ControllerAdvice` for global handling
‚úî Use **custom exceptions** for business errors
‚úî Use **meaningful HTTP status codes**
‚úî Never return raw exceptions to clients
‚úî Add correlation ID using MDC (for logs)
‚úî Hide internal system details
‚úî Log full stack trace only in server logs
‚úî Send clean JSON error responses
‚úî Distinguish between:

* 4xx errors ‚Üí Client fault
* 5xx errors ‚Üí Server fault

---

# üîµ **10. Example of production-level exception handling**

### Custom exception

```java
public class ResourceNotFoundException extends RuntimeException {
    public ResourceNotFoundException(String message) {
        super(message);
    }
}
```

### Global handler

```java
@Slf4j
@ControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleNotFound(
            ResourceNotFoundException ex,
            HttpServletRequest request) {

        log.warn("Resource not found: {}", ex.getMessage());

        ErrorResponse response = new ErrorResponse(
                ex.getMessage(),
                request.getRequestURI(),
                Instant.now(),
                HttpStatus.NOT_FOUND.value()
        );
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(response);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGeneral(
            Exception ex, HttpServletRequest request) {

        log.error("Server error", ex);

        ErrorResponse response = new ErrorResponse(
                "Internal server error",
                request.getRequestURI(),
                Instant.now(),
                500
        );
        return ResponseEntity.status(500).body(response);
    }
}
```

### Error model

```java
@Data
@AllArgsConstructor
public class ErrorResponse {
    private String message;
    private String path;
    private Instant timestamp;
    private int status;
}
```

---

# ‚≠ê FINAL INTERVIEW SUMMARY

| Topic                     | Key Point                                     |
| ------------------------- | --------------------------------------------- |
| @ControllerAdvice         | Global exception handler                      |
| @ExceptionHandler         | Method-level catch                            |
| Custom error response     | Use DTO + ResponseEntity                      |
| Validation errors         | Handle `MethodArgumentNotValidException`      |
| Checked vs unchecked      | Spring prefers unchecked business exceptions  |
| Return HTTP codes         | Use ResponseEntity or @ResponseStatus         |
| Logging                   | log.error() inside global handler             |
| Multiple ControllerAdvice | Allowed and recommended                       |
| Best practices            | Meaningful status codes, hide internal errors |
| Production example        | Custom ErrorResponse + global handler         |

---

