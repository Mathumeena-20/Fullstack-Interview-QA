# ⭐ 1. What is Bean Validation (JSR 380)?

**JSR 380** (Bean Validation 2.0) is the official Java specification for **validating Java objects** using annotations.

Spring Boot supports it via:

✔ `hibernate-validator` (default provider)
✔ `@Valid` / `@Validated`
✔ Automatic validation for request bodies, fields, beans

Example:

```java
public class User {

    @NotNull
    private String name;

    @Email
    private String email;
}
```

JSR 380 ensures **input correctness** before business logic executes.

---

# ⭐ 2. Difference between @Valid and @Validated

| Annotation     | Purpose                                         |
| -------------- | ----------------------------------------------- |
| **@Valid**     | Standard JSR-380 validation, no groups          |
| **@Validated** | Spring-specific, supports **validation groups** |

### Example

```java
@PostMapping("/add")
public ResponseEntity<?> add(@Valid @RequestBody User user) { }
```

Using groups:

```java
@PostMapping("/update")
public void update(@Validated(Update.class) @RequestBody User user) { }
```

Use:

* **@Valid** for simple validation
* **@Validated** when groups are needed

---

# ⭐ 3. Common validation annotations

| Annotation                | Meaning                                     |
| ------------------------- | ------------------------------------------- |
| **@NotNull**              | Must not be null                            |
| **@NotBlank**             | Must not be empty + must contain characters |
| **@NotEmpty**             | Must not be empty (collection/string)       |
| **@Size(min, max)**       | Length/size constraints                     |
| **@Email**                | Valid email format                          |
| **@Min / @Max**           | Number constraints                          |
| **@Positive / @Negative** | Numeric sign checks                         |
| **@Pattern**              | Regex validation                            |

Example:

```java
public class RegisterRequest {

    @NotBlank
    private String username;

    @Email
    private String email;

    @Size(min = 8, max = 16)
    private String password;
}
```

---

# ⭐ 4. How do you create custom validators?

### Step 1 — Create annotation

```java
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Constraint(validatedBy = AgeValidator.class)
public @interface ValidAge {
    String message() default "Invalid age";
    Class<?>[] groups() default {};
    Class<? extends Payload>[] payload() default {};
}
```

### Step 2 — Create validator class

```java
public class AgeValidator implements ConstraintValidator<ValidAge, Integer> {

    public boolean isValid(Integer age, ConstraintValidatorContext ctx) {
        return age != null && age > 18 && age < 60;
    }
}
```

Use:

```java
@ValidAge
private Integer age;
```

---

# ⭐ 5. What are validation groups?

Groups allow performing **different validation rules** for different operations.

Example:

```java
public interface Create {}
public interface Update {}
```

Entity:

```java
public class Product {

    @NotNull(groups = Update.class)
    private Long id;

    @NotBlank(groups = {Create.class, Update.class})
    private String name;
}
```

Controller:

```java
@PostMapping("/create")
public void create(@Validated(Create.class) @RequestBody Product p) { }
```

Used for:

* create vs update
* admin vs user validations

---

# ⭐ 6. Where does validation happen in Spring?

Validation occurs at:

✔ Controller level
✔ Before method execution
✔ Inside `HandlerMethodArgumentResolver`
✔ Uses `MethodValidationPostProcessor` for method-level validation

Examples:

* `@Valid @RequestBody`
* `@Valid` on model attributes
* `@Validated` on service methods

---

# ⭐ 7. How to validate path variables and request parameters?

Path variable validation:

```java
@GetMapping("/user/{id}")
public User get(@PathVariable @Min(1) Long id) { }
```

Request parameter validation:

```java
@GetMapping("/search")
public List<User> search(@RequestParam @Size(min = 3) String keyword) { }
```

Enable parameter validation:

```java
@Configuration
public class ValidationConfig {
    @Bean
    MethodValidationPostProcessor processor() {
        return new MethodValidationPostProcessor();
    }
}
```

---

# ⭐ 8. How do you return custom validation messages?

### Option 1 — Add message in annotation

```java
@NotBlank(message = "Username is required")
```

### Option 2 — Use `messages.properties`

```
username.notblank=Username cannot be empty
```

Entity:

```java
@NotBlank(message = "{username.notblank}")
private String username;
```

### Option 3 — Global Exception Handler

```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<?> handle(MethodArgumentNotValidException ex) {

        Map<String, String> errors = new HashMap<>();
        ex.getFieldErrors().forEach(err ->
            errors.put(err.getField(), err.getDefaultMessage()));

        return ResponseEntity.badRequest().body(errors);
    }
}
```

---

# ⭐ 9. Difference between server-side and client-side validation

| Type                       | Location            | Pros             | Cons                          |
| -------------------------- | ------------------- | ---------------- | ----------------------------- |
| **Client-side validation** | Browser (JS, HTML5) | Faster           | Can be bypassed               |
| **Server-side validation** | Backend Java code   | Secure, reliable | Slower, requires backend call |

Spring validation = **strict server-side validation**.

---

# ⭐ 10. What happens if validation fails?

If a request body is invalid:

Spring throws:

* `MethodArgumentNotValidException` (for @RequestBody)
* `ConstraintViolationException` (for @RequestParam / @PathVariable)

Default response:

```json
{
  "timestamp": "...",
  "status": 400,
  "errors": [
    "email must be valid",
    "name cannot be blank"
  ]
}
```

You can customize this using a global exception handler (shown above).

---

# ⭐ Example — Full Working Controller

```java
@PostMapping("/register")
public ResponseEntity<?> register(@Valid @RequestBody RegisterRequest request) {
    return ResponseEntity.ok("Success");
}
```

Example DTO:

```java
public class RegisterRequest {

    @NotBlank(message = "Name cannot be empty")
    private String name;

    @Email(message = "Invalid email format")
    private String email;

    @Size(min = 8, max = 16, message = "Password length must be 8-16")
    private String password;
}
```

---

# ⭐ Final Interview Summary

| Topic                  | Short Explanation                                   |
| ---------------------- | --------------------------------------------------- |
| Bean Validation        | Java standard for validating objects                |
| @Valid                 | Standard validation                                 |
| @Validated             | Supports groups                                     |
| Common annotations     | @NotNull, @Email, @Size                             |
| Custom validators      | Use @Constraint + ConstraintValidator               |
| Validation groups      | Different rules for different operations            |
| Validation takes place | Controller → before method runs                     |
| Validate path/params   | Use @Valid + constraint annotations                 |
| Custom messages        | message.properties or @RestControllerAdvice         |
| Validation fails       | Throws MethodArgumentNotValid / ConstraintViolation |

---

