# ⭐ 1. What is Dependency Injection?

**Dependency Injection (DI)** is a design pattern where **objects receive their dependencies from the Spring container**, rather than creating them manually using `new`.

Example **without DI**:

```java
public class OrderService {
    private EmailService email = new EmailService(); // hard-coded dependency
}
```

Example **with DI**:

```java
@Service
public class OrderService {

    private final EmailService email;

    public OrderService(EmailService email) {  // dependency injected
        this.email = email;
    }
}
```

✔ Loose coupling
✔ Better testability
✔ Easy to change dependencies
✔ Inversion of Control (IoC)

---

# ⭐ 2. Difference between Field Injection, Constructor Injection, Setter Injection

| Type                      | Example                                | Pros                       | Cons                              |
| ------------------------- | -------------------------------------- | -------------------------- | --------------------------------- |
| **Field Injection**       | `@Autowired private UserService user;` | Simple                     | ❌ Hard to test, ❌ not recommended |
| **Constructor Injection** | `public A(UserService u)`              | ✔ Recommended, ✔ immutable | More boilerplate                  |
| **Setter Injection**      | `setUserService()`                     | Optional dependencies      | Mutable after construction        |

### Field Injection

```java
@Autowired
private UserService service;
```

### Constructor Injection (Recommended)

```java
private final UserService service;

public UserController(UserService service) {
    this.service = service;
}
```

### Setter Injection

```java
@Autowired
public void setService(UserService service) { this.service = service; }
```

---

# ⭐ 3. Why is constructor injection recommended?

✔ Makes fields **immutable**
✔ Ensures dependency is **not null**
✔ Enables **unit testing** easily
✔ Supports **circular dependency detection**
✔ Allows using `final` fields
✔ Recommended by Spring and industry standards

---

# ⭐ 4. What is @Autowired and how does it work?

`@Autowired` tells Spring to **inject the required bean** automatically.

Spring finds the bean by:

1. **Type** (primary)
2. **Qualifier** (if provided)
3. **Name** (fallback)

Example:

```java
@Service
public class PaymentService {

    @Autowired
    private EmailService emailService;
}
```

With constructor injection:

```java
@Autowired
public PaymentService(EmailService email) {
    this.email = email;
}
```

From Spring 4.3+, you can remove `@Autowired` if the class has **only 1 constructor**.

---

# ⭐ 5. Difference between @Component, @Service, @Repository, @Bean

| Annotation                        | Purpose                                      |
| --------------------------------- | -------------------------------------------- |
| **@Component**                    | Generic Spring bean                          |
| **@Service**                      | Business logic service layer                 |
| **@Repository**                   | DAO layer, auto-translation of DB exceptions |
| **@Controller / @RestController** | Web controllers                              |
| **@Bean**                         | Create bean manually inside @Configuration   |

### Example:

```java
@Component
class Utility { }

@Service
class UserService { }

@Repository
class UserRepository { }

@Configuration
class AppConfig {
    @Bean
    public EmailService emailService() {
        return new EmailService();
    }
}
```

---

# ⭐ 6. What are Spring beans?

Spring beans are **objects created, managed, and injected by Spring IoC container**.

Lifecycle managed by Spring:

* Creation
* Initialization
* Dependency injection
* Destruction

Beans are defined with:

* `@Component`, `@Service`, `@Repository`, etc.
* `@Bean` method inside configuration class

---

# ⭐ 7. Bean lifecycle in Spring

Full lifecycle:

1. **Instantiate**
2. **Populate Dependencies**
3. Call **BeanNameAware**
4. Call **BeanFactoryAware**
5. Call **ApplicationContextAware**
6. Call **@PostConstruct**
7. Call **InitializingBean.afterPropertiesSet()**
8. Use bean
9. Call **@PreDestroy**
10. Call **DisposableBean.destroy()**

Example:

```java
@PostConstruct
public void init() { }

@PreDestroy
public void cleanup() { }
```

---

# ⭐ 8. What is @Lazy?

`@Lazy` delays bean creation until it is actually requested.

### Example:

```java
@Service
@Lazy
public class HeavyReportGenerator { }
```

Spring normally loads singletons at startup.
With `@Lazy`, the bean is created **on first use**, improving startup time.

---

# ⭐ 9. What is circular dependency and how to resolve it?

### Circular dependency happens when:

A → B → A

Example:

```java
@Service
class A {
    @Autowired B b;
}

@Service
class B {
    @Autowired A a;
}
```

Spring cannot decide which bean to create first → **BeanCurrentlyInCreationException**

### Solutions:

✔ Use **constructor injection?** → Detects circular dependency early
✔ Use **setter injection**
✔ Use **@Lazy**
✔ Refactor architecture (best solution)
✔ Introduce an interface
✔ Avoid cyclic dependencies entirely

---

# ⭐ 10. How does Spring manage singleton beans?

Spring maintains a **singleton bean registry** inside the ApplicationContext:

* Bean created **only once** at startup
* Stored in **Singleton Bean Cache** (HashMap)
* All injections receive **same instance**

Diagram:

```
[ApplicationContext]
       |
       |-- beanMap: { "orderService" : OrderService@123 }
```

To get same instance:

```java
OrderService o1 = context.getBean(OrderService.class);
OrderService o2 = context.getBean(OrderService.class);
```

✔ o1 == o2 → true
✔ Thread-safe
✔ Efficient memory usage

---

# ⭐ Final Interview Summary

| Topic                          | Short Explanation                             |
| ------------------------------ | --------------------------------------------- |
| Dependency Injection           | Spring injects required objects automatically |
| Field vs Constructor vs Setter | Constructor best (immutable, testable)        |
| @Autowired                     | Injects bean by type                          |
| @Component etc.                | Stereotype annotations                        |
| Bean                           | Object managed by Spring IoC                  |
| Bean lifecycle                 | init → inject → run → destroy                 |
| @Lazy                          | Lazy initialization                           |
| Circular dependency            | A→B→A; fix using setters/architecture         |
| Singleton beans                | One instance per container                    |

---

grams
