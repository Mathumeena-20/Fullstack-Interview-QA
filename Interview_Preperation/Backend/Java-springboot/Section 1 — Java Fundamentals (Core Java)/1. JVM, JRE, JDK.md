## 1. Difference between JVM, JRE, and JDK

Hereâ€™s the same **interview-style â€œmethod answerâ€** format for **JDK, JRE and JVM** like in your screenshot:

---

### âœ… Difference between JDK, JRE and JVM

| Component | Full Form                | Purpose                                                   | Contains                                                         |
| --------- | ------------------------ | --------------------------------------------------------- | ---------------------------------------------------------------- |
| **JDK**   | Java Development Kit     | Used to **develop, compile, debug and run** Java programs | JRE + Development tools like `javac`, `javadoc`, `jar`, debugger |
| **JRE**   | Java Runtime Environment | Used to **run** Java programs                             | JVM + Core Java libraries + Supporting files                     |
| **JVM**   | Java Virtual Machine     | Used to **execute** Java bytecode                         | Converts bytecode â†’ Machine code & manages memory, GC, threads   |

---
### Simple View:

* **JDK â†’ JRE â†’ JVM**

### Example:

If you want to **run a Java program**, you need **JRE**.
If you want to **develop Java programs**, you need **JDK**.

---

## 2. JVM Architecture

JVM mainly has **3 parts**:

### A. Class Loader Subsystem

Loads `.class` files into memory.

**Types of Class Loaders:**

1. **Bootstrap ClassLoader** â€“ loads core Java classes (rt.jar)
2. **Extension ClassLoader** â€“ loads classes from `lib/ext`
3. **Application ClassLoader** â€“ loads classpath classes

Process:

* Loading
* Linking (Verification, Preparation, Resolution)
* Initialization

---

### B. Runtime Data Area

Memory areas used by JVM:

| Area                    | Purpose                                 |
| ----------------------- | --------------------------------------- |
| **Method Area**         | Stores class metadata, static variables |
| **Heap**                | Stores objects                          |
| **Stack**               | Stores local variables, method calls    |
| **PC Register**         | Keeps track of current instruction      |
| **Native Method Stack** | For native (C/C++) methods              |

Diagram flow:

```
Class Loader â†’ Runtime Data Area â†’ Execution Engine
```

---

### C. Execution Engine

Executes the bytecode.

Components:

* **Interpreter** â€“ reads & executes line by line
* **JIT Compiler** â€“ compiles frequently used code to machine code
* **Garbage Collector** â€“ cleans unused objects

---

## 3. Steps in Java Program Execution

Example program:

```java
public class Hello {
    public static void main(String[] args) {
        System.out.println("Hello JVM");
    }
}
```

Steps:

1. Write code â†’ `Hello.java`
2. Compile:

   ```
   javac Hello.java
   ```

   â†’ produces `Hello.class` (bytecode)
3. Run:

   ```
   java Hello
   ```
4. JVM loads class using ClassLoader
5. Bytecode verifier checks code
6. Execution Engine runs code

---

## 4. What is a ClassLoader?

ClassLoader loads classes dynamically at runtime.

Types:

* **Bootstrap**
* **Extension**
* **Application**
* **User-defined ClassLoader**

Example:

```java
ClassLoader loader = Hello.class.getClassLoader();
System.out.println(loader);
```

---

## 5. What is Bytecode & Platform Independence?

* Bytecode is the **.class file** generated by compiler.
* Java is platform independent because:

  * You compile once â†’ Bytecode
  * Run anywhere on JVM

> JVM is platform dependent, but Bytecode is not.

---

## 6. HotSpot JVM vs Other JVMs

| Feature      | HotSpot JVM    | Other JVMs      |
| ------------ | -------------- | --------------- |
| Performance  | High           | Moderate        |
| Optimization | Advanced JIT   | Basic           |
| Used by      | Oracle/OpenJDK | IBM J9, GraalVM |

HotSpot dynamically optimizes code for frequently executed parts.

---

## 7. What is JIT (Just-In-Time) Compilation?

Interpreter executes code line by line.
JIT compiles "hot code" into machine code for faster execution.

ðŸ‘‰ Increases performance drastically.

---

## 8. Metaspace vs PermGen

| Feature     | PermGen        | Metaspace                   |
| ----------- | -------------- | --------------------------- |
| Introduced  | Before Java 8  | From Java 8                 |
| Memory Type | Fixed in JVM   | Dynamic, uses native memory |
| Stores      | Class metadata | Class metadata              |

---

## 9. How JVM Handles Memory Allocation

Heap is divided into:

* **Young Generation**

  * Eden
  * Survivor (S0, S1)
* **Old Generation**
* **Metaspace**

Flow:

1. Object created â†’ Eden
2. Survives GC â†’ Survivor
3. Survives multiple GC â†’ Old Gen

---

## 10. What happens when you run `javac` and `java`?

### `javac`

```
javac Hello.java
```

* Converts Java source code â†’ Bytecode (`.class` file)

### `java`

```
java Hello
```

* Loads class into JVM
* Starts execution from `main()`

---

