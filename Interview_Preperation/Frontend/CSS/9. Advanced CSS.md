# âœ… **1. What is a Stacking Context?**

A **stacking context** is a 3D layer in the browser where elements are stacked along the **z-axis** (front/back).

Inside a stacking context:

* Child elements are stacked **only relative to each other**
* They **cannot overlap** elements from a different stacking context unless the parent context allows it

### A new stacking context is created by:

* `position: relative|absolute|fixed|sticky` **with z-index not auto**
* `opacity < 1`
* `transform`, `filter`, `perspective`
* `isolation: isolate`
* `mix-blend-mode`
* `will-change: transform`
* `z-index` on flex/grid items (in some cases)

### Example

```css
.parent {
  position: relative;
  z-index: 10;   /* creates stacking context */
}
.child {
  z-index: 9999; /* still cannot escape parentâ€™s stacking context */
}
```

Even though `child` has a huge z-index, it cannot overlap elements outside its parentâ€™s context.

---

# âœ… **2. How does `isolation: isolate` work?**

`isolation: isolate` **forces the element to become a new stacking context**, even if it normally wouldnâ€™t.

### Why?

To prevent blending/overlapping issues when children use:

* mix-blend-mode
* opacity
* transforms

### Example

```css
.container {
  isolation: isolate;
}
```

Now, `.container` behaves like a "barrier", stopping childrenâ€™s stacking and blending effects from leaking outside.

---

# âœ… **3. What is CSS Containment (`contain` property)?**

The `contain` property gives the browser hints to **limit layout, paint, and size calculations** to a specific element.

This improves performance in large applications.

### Types of containment:

| Value              | Meaning                                        |
| ------------------ | ---------------------------------------------- |
| `contain: layout`  | Prevents layout changes from affecting outside |
| `contain: paint`   | Prevents element from painting outside its box |
| `contain: size`    | Element size is independent of children        |
| `contain: content` | Combines size + layout + style + paint         |
| `contain: strict`  | Strongest containment (layout + paint + size)  |

### Example

```css
.card {
  contain: content; /* Makes the card fully isolated */
}
```

Good for:

* Virtualized lists
* Reusable card components
* Large dashboards

---

# âœ… **4. Logical Properties vs Physical Properties**

Logical properties adapt to **writing direction** (LTR, RTL, vertical writing).

### **Physical properties (fixed directions):**

* `margin-left`
* `padding-right`
* `border-top`
* `width`

These assume a **left-to-right** document.

---

### **Logical properties (direction-aware):**

* `margin-inline-start`, `margin-inline-end`
* `padding-block-start`, `padding-block-end`
* `border-inline-start`
* `inline-size` (instead of width)
* `block-size` (instead of height)

### Example

#### Old (physical):

```css
.box {
  margin-left: 20px;
}
```

#### New (logical):

```css
.box {
  margin-inline-start: 20px;
}
```

If the language switches to RTL (Arabic/Hebrew), the margin automatically flips.

---

# âœ… **5. Explain the `clamp()` function**

`clamp(min, preferred, max)` picks a value between a **minimum** and **maximum**, allowing fluid responsive sizing.

### Example

```css
.title {
  font-size: clamp(1rem, 2vw, 2.5rem);
}
```

Meaning:

* Never smaller than **1rem**
* Never larger than **2.5rem**
* Between them, grow based on **2vw** (dynamic)

âœ” Perfect for responsive typography
âœ” No media queries needed

---

# âœ… **6. What are CSS Subgrid and Container Queries?**

---

## **A) CSS Subgrid**

Subgrid allows **child grids** to inherit column/row tracks from the parent grid.

### Example

```css
.parent {
  display: grid;
  grid-template-columns: 200px 1fr 1fr;
}

.child {
  display: grid;
  grid-template-columns: subgrid; /* share parent columns */
}
```

Benefits:

* Perfect alignment between nested components
* Layout consistency
* No need to manually repeat column definitions

---

## **B) Container Queries**

Container queries let components adapt based on **their container size**, not the viewport.

This solves problems where components break inside smaller spaces (sidebars, cards, widgets).

### Example

```css
.card-container {
  container-type: inline-size;
  container-name: card;
}

@container card (min-width: 400px) {
  .card {
    flex-direction: row;
  }
}
```

Now, the card switches layout when **its parent**, not the screen, gets wide.

âœ” More modular
âœ” Component-driven responsive design

---

# ðŸŽ¯ **Quick Summary Table**

| Concept                   | Meaning                                           |
| ------------------------- | ------------------------------------------------- |
| Stacking context          | z-axis stacking layer for elements                |
| isolation: isolate        | Forces a new stacking context                     |
| contain                   | Limits layout/paint/sizing to improve performance |
| Logical vs Physical props | Direction-aware vs fixed-direction CSS            |
| clamp()                   | Responsive value between min â†’ ideal â†’ max        |
| Subgrid                   | Nested grid inherits tracks from parent           |
| Container Queries         | Styles change based on container size             |

---

