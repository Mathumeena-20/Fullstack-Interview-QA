# ✅ **1. Difference Between `localStorage`, `sessionStorage`, and Cookies**

| Feature         | localStorage                               | sessionStorage                     | Cookies                              |
| --------------- | ------------------------------------------ | ---------------------------------- | ------------------------------------ |
| Persistence     | **Never expires** (until manually cleared) | Clears when **tab/browser closes** | Can have an **expiration date**      |
| Capacity        | ~5–10MB                                    | ~5MB                               | ~4KB                                 |
| Sent to Server? | ❌ No                                       | ❌ No                               | ✔ Yes (sent with every HTTP request) |
| Access          | JavaScript                                 | JavaScript                         | JS + Server                          |
| Use Cases       | Large client-side data (theme, cart)       | Temporary tab-specific data        | Authentication, preferences          |

---

## **localStorage Example**

```javascript
localStorage.setItem("theme", "dark");
console.log(localStorage.getItem("theme")); // dark
```

---

## **sessionStorage Example**

```javascript
sessionStorage.setItem("token", "abc123");
```

Closes when tab closes.

---

## **Cookie Example**

```javascript
document.cookie = "username=Mathu; expires=Fri, 31 Dec 2025; path=/";
```

---

## ✔ Interview Summary

* **localStorage** → long-term storage
* **sessionStorage** → per-tab storage
* **cookies** → small data sent to server (used for login/auth)

---

# ✅ **2. How Does the Browser Handle HTML Parsing Errors?**

### Browsers are **very forgiving**.

They automatically fix errors using a process called **error correction**.

### Examples of common fixes:

### ✔ Missing closing tags

HTML:

```html
<p>Hello
```

Browser automatically closes `</p>`.

---

### ✔ Misnested tags

HTML:

```html
<b><i>Text</b></i>
```

Browser repairs it to:

```html
<b><i>Text</i></b>
```

---

### ✔ Unclosed `<html>`, `<head>`, `<body>`

Browsers implicitly add them.

### ✔ Invalid tags

Unknown tags are ignored but kept in DOM.

---

## ✔ Interview takeaway:

> Browsers use an internal **HTML parser** with built-in error recovery rules to ensure pages still render, even with broken HTML.

---

# ✅ **3. Difference Between `<script>` in `<head>` vs `<body>`**

## **Script in `<head>`**

```html
<head>
  <script src="app.js"></script>
</head>
```

* Blocks HTML rendering until script loads
* Slower page load
* DOM may not be ready → need `DOMContentLoaded` or `defer`

Used for:

* Critical scripts
* Above-the-fold logic

---

## **Script at end of `<body>`**

```html
<body>
  ...
  <script src="app.js"></script>
</body>
```

* Loads after HTML
* Faster page rendering
* DOM is already available
* Recommended for most scripts

---

## Modern BEST Practice

Use `defer` if script can run after HTML loads:

```html
<script src="app.js" defer></script>
```

---

# ✔ Interview Summary:

* **head scripts block rendering**
* **body scripts load after content**
* Prefer **defer** for non-blocking load

---

# ✅ **4. What is Content Security Policy (CSP)?**

### **Definition**

CSP is a browser security feature that restricts what resources a webpage can load.

Protects against:

* Cross-Site Scripting (XSS)
* Data injection
* Unsanctioned scripts

---

### Example CSP header:

```
Content-Security-Policy: default-src 'self'; img-src https:;
```

Meaning:

* Load everything only from the **same domain**
* Images can load from HTTPS sources

---

### Example using `<meta>`:

```html
<meta http-equiv="Content-Security-Policy" content="script-src 'self'">
```

This prevents any external script from running.

---

## ✔ Interview Summary:

> CSP allows website owners to control which scripts, images, or styles can load, making the site safer against XSS attacks.

---

# ✅ **5. What is Shadow DOM? What is its purpose?**

### **Shadow DOM** is a way to create **encapsulated DOM trees** inside elements.

Used by:

* Web components
* Frameworks (Angular, React, Lit, Polymer)
* Browsers (e.g., `<video>` has internal shadow DOM)

### **Purpose:**

1. **Encapsulation**

   * Styles inside shadow DOM do NOT leak out
   * Outside styles do NOT affect shadow DOM

2. **Reusable components**

   * Create custom elements without style conflicts

3. **Scoped styling**

   * Makes custom components predictable

---

### Example: Creating Shadow DOM

```html
<div id="box"></div>

<script>
  const div = document.getElementById("box");

  const shadow = div.attachShadow({ mode: "open" });

  shadow.innerHTML = `
    <style>
      p { color: red; }
    </style>
    <p>This is inside shadow DOM</p>
  `;
</script>
```

### Output:

* Paragraph inside shadow DOM is **red**
* External CSS **cannot override** it

---

