
# âœ… **18. Explain destructuring with an example**

**Destructuring** lets you **extract values from arrays or properties from objects** into variables easily.

---

### âœ” **Object Destructuring**

```js
const user = { name: "Mathu", age: 24 };

const { name, age } = user;

console.log(name); // Mathu
console.log(age);  // 24
```

---

### âœ” **Array Destructuring**

```js
const nums = [10, 20, 30];

const [a, b] = nums;

console.log(a); // 10
console.log(b); // 20
```

---

### âœ” **Renaming variables**

```js
const { name: userName } = user;
console.log(userName);
```

---

### âœ” **Default values**

```js
const { city = "Unknown" } = user;
```

---

# ðŸ”¥ Why destructuring is useful?

* Cleaner code
* Avoids repetitive `obj.property`
* Makes function arguments more readable

---

# âœ… **19. What is the spread operator used for?**

The **spread operator (`...`)** is used to:

### âœ” **Copy arrays/objects**

```js
const arr1 = [1, 2, 3];
const arr2 = [...arr1];

console.log(arr2); // [1,2,3]
```

---

### âœ” **Merge arrays**

```js
const x = [1, 2];
const y = [3, 4];

const merged = [...x, ...y];
console.log(merged); // [1,2,3,4]
```

---

### âœ” **Copy objects**

```js
const user = { a: 1, b: 2 };
const copy = { ...user };
```

---

### âœ” **Merge objects**

```js
const user = { name: "A" };
const info = { age: 25 };

const combined = { ...user, ...info };
```

---

### âœ” **Expand arguments**

```js
function add(a, b, c) {
  return a + b + c;
}

const nums = [1, 2, 3];

console.log(add(...nums)); // 6
```

---

# âœ… **20. Difference between `map`, `filter`, `reduce`**

| Method       | Purpose                      | Returns                         | When to use          |
| ------------ | ---------------------------- | ------------------------------- | -------------------- |
| **map()**    | Transform each element       | New array (same length)         | Modify values        |
| **filter()** | Select matching elements     | New array (â‰¤ length)            | Apply conditions     |
| **reduce()** | Accumulate into single value | **Anything** (number, obj, arr) | Summations, grouping |

---

### âœ” **map example**

```js
const nums = [1, 2, 3];
const doubled = nums.map(n => n * 2);

console.log(doubled); // [2,4,6]
```

---

### âœ” **filter example**

```js
const nums = [1, 2, 3, 4];
const evens = nums.filter(n => n % 2 === 0);

console.log(evens); // [2,4]
```

---

### âœ” **reduce example**

Sum of array:

```js
const nums = [1, 2, 3];

const total = nums.reduce((acc, curr) => acc + curr, 0);

console.log(total); // 6
```

Reduce can also build objects:

```js
const chars = ["a", "b", "a"];

const count = chars.reduce((acc, curr) => {
  acc[curr] = (acc[curr] || 0) + 1;
  return acc;
}, {});

console.log(count); // { a: 2, b: 1 }
```

---

# âœ… **21. What is a generator function?**

A **generator function** is a special function that can be **paused and resumed**, using the `yield` keyword.

It returns an **iterator**.

### Syntax:

```js
function* generatorFunction() {
  yield 1;
  yield 2;
  yield 3;
}
```

---

### Example:

```js
const gen = generatorFunction();

console.log(gen.next()); // { value: 1, done: false }
console.log(gen.next()); // { value: 2, done: false }
console.log(gen.next()); // { value: 3, done: false }
console.log(gen.next()); // { value: undefined, done: true }
```

---

### Uses:

* Custom iterators
* Infinite sequences
* Async flow control

---

# âœ… **22. What is a Symbol? Why is it used?**

A **Symbol** is a **unique and immutable** value.
Even if two Symbols have the same description, they are always **different**.

### Example:

```js
const id1 = Symbol("id");
const id2 = Symbol("id");

console.log(id1 === id2); // false
```

---

### âœ” **Use-case: Unique object keys**

Prevent accidental key collisions.

```js
const user = {
  name: "Mathu",
  [Symbol("id")]: 123
};
```

The Symbol-keyed property is not visible in normal loops:

```js
for (let key in user) {
  console.log(key); // name
}
```

---

# âœ… **23. What are default parameters?**

Default parameters allow a function to use **fallback values** when no argument is passed.

### Example:

```js
function greet(name = "Guest") {
  console.log("Hello " + name);
}

greet();        // Hello Guest
greet("Mathu"); // Hello Mathu
```

---

# Real use-case:

```js
function multiply(a, b = 1) {
  return a * b;
}

console.log(multiply(5));    // 5
console.log(multiply(5, 2)); // 10
```

---

# âœ… **24. What are template literals?**

Template literals use **backticks** instead of quotes, allowing:

âœ” Expression interpolation
âœ” Multi-line strings
âœ” Embedded expressions

---

### Example: Interpolation

```js
const name = "Mathu";
console.log(`Hello, ${name}!`);
```

---

### Example: Multi-line string

```js
const msg = `
Line 1
Line 2
Line 3
`;
console.log(msg);
```

---

### Example: Expression calculation

```js
console.log(`2 + 3 = ${2 + 3}`);
```

---

