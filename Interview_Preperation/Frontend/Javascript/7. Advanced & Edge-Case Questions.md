Here are **clear, interview-ready explanations + examples** for questions **46â€“50**.
These are **advanced concepts** that impress interviewers.

---

# âœ… **46. Why is JavaScript single-threaded but still asynchronous?**

### âœ” JavaScript is single-threaded because:

It uses **one call stack**, meaning **only one piece of code executes at a time**.
This avoids:

* Race conditions
* Complex locking
* Data corruption

Great for UI programming.

---

# âœ” But how is JS asynchronous if it runs in one thread?

Because JavaScript relies on:

1. **Web APIs** â†’ timers, fetch, events, DOM
2. **Callback queue**
3. **Microtask queue**
4. **Event loop**

These run **outside** the main JS thread and notify JS when to execute callbacks.

---

### âœ” Example

```js
console.log("A");

setTimeout(() => console.log("B"), 1000); // runs asynchronously

console.log("C");
```

### Output:

```
A
C
B
```

JS did not block for 1 second â€” the browser handled the timer in background.

---

### **Summary**

* JavaScript executes code in one thread
* Browser handles async operations
* Event loop schedules callbacks when ready

---

# âœ… **47. What is a memory leak in JS? Give real examples.**

A memory leak happens when a program keeps memory **alive unintentionally**, preventing garbage collection.

---

# âœ” **Common real examples**

## **1. Global variables**

```js
function bad() {
  leaked = "I am global!"; // missing 'let' or 'var'
}
```

â†’ `leaked` stays in memory forever.

---

## **2. Unremoved event listeners**

```js
const btn = document.getElementById("btn");

function handle() {
  console.log("Clicked");
}

btn.addEventListener("click", handle);

// Not removed when button removed â†’ leak!
```

---

## **3. Closures that retain unnecessary references**

```js
function heavy() {
  const big = new Array(1000000).fill("*");
  return function () {
    console.log("Hello");
  };
}

const fn = heavy(); // big stays in memory!
```

---

## **4. Set/Map storing objects without clearing**

```js
const cache = new Map();

function storeUser(user) {
  cache.set(user.id, user); // never removed
}
```

---

## **5. Timers not cleared**

```js
setInterval(() => console.log("running"), 1000);
// If never cleared â†’ memory leak
```

---

# ğŸ¯ Summary: Memory leaks come from

* Unreleased references
* Event listeners
* Closures
* Cached objects
* Timers

---

# âœ… **48. Explain `call()`, `apply()`, `bind()` with examples**

These methods **manually set `this`** for a function.

---

# âœ” **call()**

Calls a function **immediately** with `this` + arguments.

### Example:

```js
function greet(a, b) {
  console.log(this.name, a, b);
}

const user = { name: "Mathu" };

greet.call(user, "Hello", "World");
```

---

# âœ” **apply()**

Same as call, but arguments passed **as an array**.

### Example:

```js
greet.apply(user, ["Hello", "World"]);
```

---

# âœ” **bind()**

Returns a **new function** with a fixed `this`.
Does NOT run immediately.

### Example:

```js
const fn = greet.bind(user, "Hello");
fn("World");
```

---

# ğŸ’¡ Summary

| Method  | Runs immediately? | How args are passed |
| ------- | ----------------- | ------------------- |
| call()  | âœ” Yes             | Individually        |
| apply() | âœ” Yes             | Array               |
| bind()  | âŒ No              | Individually        |

---

# âœ… **49. What are WeakMap and WeakSet? Why useful?**

### âœ” WeakMap

A map where **keys must be objects**, and references to those keys are **weak**.

If an object has no other references, it is **garbage-collected** even if in WeakMap.

### Example:

```js
let obj = { name: "Mathu" };

const wm = new WeakMap();
wm.set(obj, "secret");

obj = null; // object is garbage-collected automatically
```

---

### âœ” WeakSet

A set that stores **only objects**, also weak references.

---

# ğŸ¯ Why are they useful?

## **Use case 1: Memory-efficient caches**

```js
const cache = new WeakMap();

function process(obj) {
  if (!cache.has(obj)) {
    cache.set(obj, expensiveComputation(obj));
  }
  return cache.get(obj);
}
```

When `obj` is no longer used â†’ auto GC removes it from cache.

---

## **Use case 2: Private object data**

```js
const privateData = new WeakMap();

class User {
  constructor(name) {
    privateData.set(this, { name });
  }
  getName() {
    return privateData.get(this).name;
  }
}
```

---

### âœ” WeakMap & WeakSet limitations:

* NOT iterable
* Cannot be checked with size
* Keys must be objects

---

# ğŸ’¬ Summary

WeakMap/WeakSet help avoid **memory leaks**.

---

# âœ… **50. What is tail call optimization? Does JS support it?**

### âœ” What is TCO?

Tail call optimization is when the **last action in a function is a call to another function**, allowing the engine to **reuse the current stack frame**, preventing stack overflow.

---

### âœ” Example (tail call)

```js
function factorial(n, acc = 1) {
  if (n === 1) return acc;
  return factorial(n - 1, n * acc); // tail call
}
```

The call to `factorial` is the **last operation** â†’ eligible for TCO.

---

### âœ” Does JavaScript support TCO?

**Officially: Yes, ES6 supports Tail Call Optimization in strict mode.**
Butâ€¦

ğŸ‘‰ **Only Safari implements real TCO.
Chrome, Firefox, Node.js do NOT support it** due to debugging complexity.

---

### âœ” Non-tail call (not optimized)

```js
function fact(n) {
  return n * fact(n - 1); // multiply happens AFTER function returns
}
```

This can cause **stack overflow** for large numbers.

---

# ğŸ¯ Summary:

* TCO avoids stack overflow
* Only works in strict mode
* Only Safari implements it
* The tail call must be the last statement

---

