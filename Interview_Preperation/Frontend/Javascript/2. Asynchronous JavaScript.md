Here are **clear, interview-ready answers with examples** for all **Async JavaScript Questions (11â€“17)**.

---

# âœ… **11. Explain the Event Loop**

### **The Event Loop controls how JavaScript handles asynchronous operations.**

JavaScript is **single-threaded**, so it executes one task at a time on the **call stack**.

### **Flow of execution:**

1. **Call Stack**
   Executes synchronous code.

2. **Web APIs**
   Handle async tasks like `setTimeout`, `fetch`, DOM events.

3. **Task Queues**

   * **Microtask Queue** â†’ Handles Promises, queueMicrotask
   * **Macrotask Queue** â†’ Handles setTimeout, setInterval, DOM events, etc.

4. **Event Loop**
   Repeatedly checks:

   * If call stack is empty â†’ push **microtasks first**
   * If microtasks done â†’ push **macrotasks**

âœ” **Microtasks always run before macrotasks**

---

### **Example**

```js
console.log("A");

setTimeout(() => console.log("B"), 0);

Promise.resolve().then(() => console.log("C"));

console.log("D");
```

### **Output**

```
A
D
C   â† microtask
B   â† macrotask
```

---

# âœ… **12. Difference between Microtask & Macrotask**

| Type          | What it handles                            | Priority                         |
| ------------- | ------------------------------------------ | -------------------------------- |
| **Microtask** | Promises, queueMicrotask, MutationObserver | **High** (runs before UI update) |
| **Macrotask** | setTimeout, setInterval, I/O, events       | Lower                            |

### **Example**

```js
setTimeout(() => console.log("Macrotask"), 0);

Promise.resolve().then(() => console.log("Microtask"));
```

### **Output**

```
Microtask
Macrotask
```

---

# âœ… **13. What does async/await do internally?**

`async/await` is **syntax sugar over Promises**.

### Internally:

* `async` function **always returns a Promise**
* `await` **pauses** execution until the Promise:

  * **resolves** â†’ returns its value
  * **rejects** â†’ throws error

### Example

```js
async function getData() {
  console.log("1");

  const data = await Promise.resolve("2");

  console.log(data);
  console.log("3");
}

getData();
```

### Output

```
1
2
3
```

### Same internal behavior using Promises

```js
function getData() {
  console.log("1");

  return Promise.resolve("2").then(data => {
    console.log(data);
    console.log("3");
  });
}
```

---

# âœ… **14. What is a Promise chain?**

A **Promise chain** is created when each `.then()` **returns another Promise**, passing results down the chain.

### Example

```js
Promise.resolve(1)
  .then(num => {
    console.log(num); // 1
    return num + 1;
  })
  .then(num => {
    console.log(num); // 2
    return num + 1;
  })
  .then(num => {
    console.log(num); // 3
  });
```

### Key rule

âœ” You **must return** inside `.then()` to pass the result.

---

# âœ… **15. What happens if you donâ€™t handle Promise rejection?**

If a Promise is rejected and **not handled**, JavaScript throws:

### **UnhandledPromiseRejectionWarning** (Node)

### **unhandledrejection** event (Browser)

Example:

```js
Promise.reject("Error!!");
```

Console warning:

```
UnhandledPromiseRejection: Error!!
```

### Proper handling:

```js
Promise.reject("Error").catch(err => console.log(err));
```

Or in async/await:

```js
async function test() {
  try {
    await Promise.reject("Oops");
  } catch (e) {
    console.log(e);
  }
}
```

---

# âœ… **16. How do you run promises in parallel?**

### âœ” **1. `Promise.all()`**

Stops immediately when **one fails**.

```js
Promise.all([
  fetch("/a"),
  fetch("/b"),
  fetch("/c")
])
.then(console.log)
.catch(console.error);
```

---

### âœ” **2. `Promise.allSettled()`**

Waits for **all to finish**, even failures.

```js
Promise.allSettled([
  fetch("/a"),
  fetch("/b"),
  Promise.reject("fail")
]).then(console.log);
```

---

### âœ” **3. `Promise.race()`**

Returns **first settled Promise** (resolve/reject).

---

### âœ” **4. `Promise.any()`**

Returns **first resolved** (ignores rejections).

---

# âœ… **17. Why is `setTimeout(fn, 0)` not immediate?**

Because it becomes a **macrotask**, which must wait:

1. **Call stack must be empty**
2. **Microtasks must finish**

### Example

```js
setTimeout(() => console.log("Timeout"), 0);

Promise.resolve().then(() => console.log("Promise"));

console.log("Sync");
```

### Output

```
Sync
Promise
Timeout
```

`setTimeout` never runs before microtasks.

---

# ğŸ Want the next set?

I can prepare the next topics:

### âœ” ES6+ Concepts

### âœ” DOM & Browser Questions

### âœ” Real Business JS Problems with Solutions

### âœ” 50â€“100 Advanced Interview Questions

Tell me:
**â€œGive next 10 with solutionsâ€**
