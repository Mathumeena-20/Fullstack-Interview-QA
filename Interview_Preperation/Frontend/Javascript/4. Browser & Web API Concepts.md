Here are **clear, interview-ready explanations with examples** for questions **25–30**.

---

# ✅ **25. Difference between `localStorage`, `sessionStorage`, and `cookies`**

| Feature             | localStorage           | sessionStorage         | cookies                         |
| ------------------- | ---------------------- | ---------------------- | ------------------------------- |
| **Lifetime**        | Until manually cleared | Until tab is closed    | Based on expiry date            |
| **Storage limit**   | ~5–10 MB               | ~5 MB                  | ~4 KB                           |
| **Sent to server?** | ❌ No                   | ❌ No                   | ✅ Yes (sent with every request) |
| **Use case**        | Long-term data         | Per-tab temporary data | Auth, tracking                  |

---

### ✔ Example: localStorage

```js
localStorage.setItem("token", "abc123");
console.log(localStorage.getItem("token"));
```

---

### ✔ Example: sessionStorage

```js
sessionStorage.setItem("page", "home");
```

Closes when tab closes.

---

### ✔ Example: Cookies

```js
document.cookie = "user=Mathu; max-age=3600";
```

---

### **Real-world usage**

* `localStorage` → remember user preferences, themes
* `sessionStorage` → store wizard form step in a tab
* `cookies` → authentication tokens (HTTP-only cookies)

---

# ✅ **26. What is CORS? Why does it happen?**

**CORS (Cross-Origin Resource Sharing)** is a browser security mechanism that **restricts HTTP requests** from one origin to another.

### **Same-origin = same domain + protocol + port**

If frontend at:

```
https://example.com
```

tries to call:

```
https://api.other.com
```

Browser checks CORS headers.

---

### ✔ Why it happens?

To prevent **malicious websites** from reading data from another website without permission.

---

### ✔ Example of server allowing CORS

Backend response must include:

```http
Access-Control-Allow-Origin: *
```

(or a specific domain)

---

### ✔ Example using Express.js

```js
app.use((req, res, next) => {
  res.setHeader("Access-Control-Allow-Origin", "https://myapp.com");
  next();
});
```

---

# ✅ **27. Debounce vs Throttle (very important)**

Both optimize high-frequency events.

---

## **Debounce**

Executes a function **after a delay**, **but resets timer** if called again.

### ✔ Use case:

* Search box API call
* Auto-save
* Window resize events

### Example

```js
function debounce(fn, delay) {
  let timer;
  return function (...args) {
    clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, args), delay);
  }
}
```

Usage:

```js
const search = debounce(() => console.log("API CALL"), 300);
input.addEventListener("input", search);
```

---

## **Throttle**

Executes a function **at most once** in a fixed interval.

### ✔ Use case:

* Scroll events
* Resize events
* Button spam prevention

### Example

```js
function throttle(fn, delay) {
  let last = 0;
  return function (...args) {
    const now = Date.now();
    if (now - last >= delay) {
      fn.apply(this, args);
      last = now;
    }
  }
}
```

Usage:

```js
const handleScroll = throttle(() => console.log("Scrolling..."), 500);
window.addEventListener("scroll", handleScroll);
```

---

# ✅ **28. Why do we use `event.preventDefault()` and `event.stopPropagation()`?**

## ✔ `event.preventDefault()`

Prevents **default browser action**.

### Example:

```html
<a href="https://google.com" id="link">Click</a>
<script>
document.getElementById("link").addEventListener("click", e => {
  e.preventDefault(); // prevents navigation
  console.log("Link click blocked!");
});
</script>
```

---

## ✔ `event.stopPropagation()`

Stops event from **bubbling** up the DOM.

### Example:

```html
<div id="parent">
  <button id="child">Click</button>
</div>

<script>
parent.addEventListener("click", () => console.log("Parent clicked"));
child.addEventListener("click", e => {
  e.stopPropagation(); // stops bubble
  console.log("Child clicked");
});
</script>
```

### Output:

```
Child clicked
```

Parent does NOT fire.

---

# ✅ **29. What are Web Workers?**

Web Workers allow JavaScript to run code in a **background thread** (separate from main UI thread).

Used for **heavy CPU tasks** to avoid blocking UI.

---

### ✔ Example: Creating a worker

#### worker.js

```js
self.onmessage = function(e) {
  const result = e.data * 2;
  self.postMessage(result);
}
```

#### main.js

```js
const worker = new Worker("worker.js");

worker.postMessage(10);

worker.onmessage = function(e) {
  console.log("Result:", e.data); // 20
};
```

---

### ✔ Use cases:

* Video processing
* Image manipulation
* Large calculations
* Data parsing

---

# ✅ **30. Difference between synchronous vs asynchronous code**

### **Synchronous**

* Code runs **line by line**
* Next line waits for previous to finish
* Blocking

### Example

```js
console.log("A");
alert("Blocking alert");
console.log("B");
```

Output:

```
A
(Waits at alert)
B
```

---

### **Asynchronous**

* Code runs without blocking
* Uses callback queue + event loop

### Example

```js
console.log("A");

setTimeout(() => console.log("B"), 1000);

console.log("C");
```

Output:

```
A
C
B
```

