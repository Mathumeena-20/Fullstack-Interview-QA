Here are **clear, interview-ready explanations + examples** for questions **31‚Äì35**.

---

# ‚úÖ **31. What is prototypal inheritance?**

**Prototypal inheritance** means that **objects in JavaScript inherit properties from other objects** via a hidden property called `[[Prototype]]` (accessible as `__proto__`).

Every object has a link to a **prototype object**, and JS looks up properties along this chain.

---

### ‚úî Example

```js
const parent = {
  greet() {
    console.log("Hello from parent");
  }
};

const child = Object.create(parent);

child.greet(); 
```

### How it works internally:

When `child.greet()` is called:

1. JavaScript checks if `greet` exists on `child`
2. If not, it looks at `child.__proto__` ‚Üí which is `parent`
3. Finds `greet` there and executes it

---

### ‚úî Real-world use:

All arrays inherit from `Array.prototype`,
All objects inherit from `Object.prototype`, etc.

```js
const arr = [];
console.log(arr.__proto__ === Array.prototype); // true
```

---

# ‚úÖ **32. How does `class` work in JavaScript internally?**

### **JavaScript classes are NOT like Java or C# classes.**

They are **syntactic sugar over prototypal inheritance**.

Internally, classes simply create:

* A constructor function
* A prototype object

---

### ‚úî Example

```js
class Person {
  constructor(name) {
    this.name = name;
  }

  greet() {
    console.log("Hello " + this.name);
  }
}

const p = new Person("Mathu");
p.greet();
```

---

### Internally, JS transforms it into:

```js
function Person(name) {
  this.name = name;
}

Person.prototype.greet = function() {
  console.log("Hello " + this.name);
};
```

### ‚úî Key points:

* Methods inside class go to **prototype**, not inside objects
* Class still uses **prototypal inheritance under the hood**
* You cannot call a class without `new` ‚Üí it‚Äôs just a protected constructor

---

# ‚úÖ **33. What is the `this` keyword? How does it behave in different contexts?**

`this` refers to **who is calling the function**, not where it is defined.

---

### ‚úî 1. **Global context**

```js
console.log(this); // window (in browser)
```

---

### ‚úî 2. **Inside an object method**

`this` = object that calls the method.

```js
const user = {
  name: "Mathu",
  show() {
    console.log(this.name);
  }
};

user.show(); // Mathu
```

---

### ‚úî 3. **Alone in a function**

Strict mode ‚Üí undefined
Non-strict ‚Üí window

```js
function test() {
  console.log(this);
}
test();
```

---

### ‚úî 4. **Event listeners**

`this` = element that received the event.

```js
button.onclick = function() {
  console.log(this); // button
};
```

---

### ‚úî 5. **`call`, `apply`, `bind`**

You can manually set `this`.

```js
function greet() {
  console.log("Hi " + this.name);
}

greet.call({ name: "Mathu" }); // Hi Mathu
```

---

### ‚úî 6. **Constructor functions**

`this` = new object being created.

```js
function Person(name) {
  this.name = name;
}
```

---

# üî• Summary:

`this` depends on **how** a function is called, not where it is written.

---

# ‚úÖ **34. How do arrow functions treat `this`?**

Arrow functions **do not have their own `this`**.
Instead, they take `this` from their **lexical scope** (the surrounding block).

---

### ‚úî Example

```js
const obj = {
  name: "Mathu",
  show: function() {
    setTimeout(() => {
      console.log(this.name);
    }, 1000);
  }
};

obj.show(); // Mathu
```

### Why?

The arrow function inherits `this` from `show()`, which is `obj`.

---

### Compare with normal function:

```js
setTimeout(function() {
  console.log(this); // window
}, 1000);
```

Normal functions have their own `this` ‚Üí becomes `window` in browser.

---

### ‚úî Arrow functions are best for:

* Callbacks
* Event handlers
* Promise chains
* Avoiding `var self = this` workaround

---

# ‚úÖ **35. Why can't arrow functions be used as constructors?**

Arrow functions **cannot be used with `new`** because:

### ‚úî They do NOT have:

* `[[Construct]]` internal method
* Their own `this`
* Their own `prototype` property

---

### Example:

```js
const Person = (name) => {
  this.name = name;
};

const p = new Person("Mathu"); 
```

### ‚ùå Error:

```
TypeError: Person is not a constructor
```

---

### Why?

Constructors need:

* A prototype
* A new `this` binding

Arrow functions lack both.

