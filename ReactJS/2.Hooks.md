Below are **clear, in-depth, interview-ready explanations + examples** for all key React Hooks questions (useState, useEffect, useMemo, useCallback, useRef, useContext, useReducer).
This is exactly the level expected for **2+ years experience**.

---

# ============================

# âœ… **useState**

# ============================

---

# **1. How does useState work internally?**

### âœ” Internally:

* React stores state in a **linked list of hooks** attached to the component.
* Each render has a **current pointer** that tracks your hook order.
* Updating state schedules a **re-render**, which rebuilds the component tree.

### Example:

```jsx
const [count, setCount] = useState(0);
```

React internally stores:

```
hook1.state = 0
hook1.queue = []
```

When you call `setCount(1)`:

* React queues the update
* Batches multiple updates
* Re-renders the component with the new state

---

# **2. Why does React batch state updates?**

### âœ” To improve performance:

React batches multiple state updates within the same event loop into **one render**.

Example:

```jsx
setCount(count + 1);
setCount(count + 1);
```

Without batching = 2 renders
With batching = 1 render

Batching prevents unnecessary renders â†’ improves performance.

---

# **3. What happens if you update a state based on previous state incorrectly?**

### âŒ Incorrect (using stale state):

```jsx
setCount(count + 1);
setCount(count + 1);
```

Result: only +1 because both updates use the **same stale value**.

### âœ” Correct way:

Use functional update:

```jsx
setCount(prev => prev + 1);
setCount(prev => prev + 1);
```

Now final value = **+2**

---

# ============================

# âœ… **useEffect**

# ============================

---

# **4. Difference between `useEffect`, `useLayoutEffect`, and `useInsertionEffect`.**

| Hook                   | When it runs            | Use case                             |
| ---------------------- | ----------------------- | ------------------------------------ |
| **useEffect**          | After paint             | Data fetching, subscriptions, timers |
| **useLayoutEffect**    | Before paint (blocking) | Read layout, measure DOM             |
| **useInsertionEffect** | Before DOM mutations    | CSS-in-JS libraries                  |

### âœ” Example:

```jsx
useEffect(() => console.log("After paint"));
useLayoutEffect(() => console.log("Before paint"));
```

---

# **5. What is the dependency array? What happens if you leave it empty?**

```jsx
useEffect(() => { ... }, [dep1, dep2]);
```

### Behavior:

* **No array** â†’ runs on EVERY render
* **Empty array []** â†’ runs only ONCE (component mount)
* **[dependencies]** â†’ runs when values change

### Example:

```jsx
useEffect(() => console.log("Runs once"), []);
```

---

# **6. How to avoid infinite renders in useEffect?**

Infinite loop example:

```jsx
useEffect(() => {
  setCount(count + 1); // âŒ state update inside useEffect
});
```

Prevention:

1. **Add dependency array**
2. **Use functional updates**
3. **Protect state updates with conditions**

Correct:

```jsx
useEffect(() => {
  setCount(prev => prev + 1);
}, []);
```

---

# **7. How do you clean up side effects?**

Cleanup function **runs on unmount** or before next effect.

Example:

```jsx
useEffect(() => {
  const id = setInterval(() => console.log("tick"), 1000);

  return () => clearInterval(id); // cleanup
}, []);
```

Other cleanup examples:

* Removing event listeners
* Aborting fetch
* Closing WebSocket

---

# ============================

# âœ… **Other Hooks**

# ============================

---

# **8. What is useMemo and when to use it?**

### âœ” useMemo: Memoizes expensive computations

```jsx
const result = useMemo(() => expensiveCalc(value), [value]);
```

Use it when:

* You have heavy computations
* Computed value is passed to children
* You want to prevent recalculation on every render

---

# **9. What is useCallback and how does it prevent re-renders?**

### âœ” useCallback memoizes a function

```jsx
const handleClick = useCallback(() => {
  console.log(count);
}, [count]);
```

Why useful?

* Prevents child components from re-rendering
* Keeps function references stable
* Essential when using `React.memo`

---

# **10. Difference between useRef and useState.**

| useRef                        | useState                      |
| ----------------------------- | ----------------------------- |
| Stores mutable value          | Stores component state        |
| DOES NOT cause re-render      | Causes re-render              |
| Used for DOM refs             | Used for UI data              |
| Value persists across renders | Value persists but re-renders |

Example:

```jsx
const countRef = useRef(0);
const [count, setCount] = useState(0);
```

---

# **11. How does useContext work?**

Used for **global state** without prop drilling.

### Create context:

```jsx
const ThemeContext = createContext();
```

Provide:

```jsx
<ThemeContext.Provider value="dark">
  <App />
</ThemeContext.Provider>
```

Consume:

```jsx
const theme = useContext(ThemeContext);
```

React re-renders consumers when context value changes.

---

# **12. What is useReducer and when do you prefer it over useState?**

useReducer is used for **complex state logic**.

### Example:

```jsx
function reducer(state, action) {
  switch (action.type) {
    case "increment": return { count: state.count + 1 };
  }
}

const [state, dispatch] = useReducer(reducer, { count: 0 });
```

### âœ” Prefer useReducer when:

* State transitions are complex
* Multiple sub-values need updating
* State updates depend on previous state
* You want Redux-like structure

Examples:

* Forms
* Tabs
* Shopping carts
* Wizards

---

# ðŸŽ¯ **Interview Summary (What to say)**

* `useState` stores component data; React batches updates for performance.
* Use functional updates when updating based on previous state.
* `useEffect` handles side effects; `useLayoutEffect` handles layout reads; `useInsertionEffect` is for CSS injection.
* The dependency array controls when effects run.
* `useMemo` memoizes calculations; `useCallback` memoizes functions; `useRef` stores mutable values without re-rendering.
* `useContext` avoids prop drilling.
* `useReducer` is used for complex state management.

---

