Below is a **clear, complete, interview-ready explanation** of React performance concepts: memoization, re-renders, optimization, windowing, code splitting, lazy loading, and React Profiler ‚Äî with examples.

These answers are ideal for **2+ years experience** React interviews.

---

# ============================

# ‚úÖ **1. What is React Memoization?**

# ============================

React memoization means **caching values or components to avoid unnecessary re-renders or recalculations**.

React provides **three memoization tools**:

---

## **(A) React.memo**

Used to memoize **entire components**.

### ‚úî Prevents re-render if props do not change.

Example:

```jsx
const Child = React.memo(function Child({ value }) {
  console.log("Child rendered");
  return <div>{value}</div>;
});
```

Parent:

```jsx
<Child value={count} />
```

If parent re-renders but `value` is unchanged ‚Üí **Child does not re-render**.

---

## **(B) useMemo**

Memoizes **expensive calculations**.

```jsx
const expensiveValue = useMemo(() => {
  return heavyComputation(data);
}, [data]);
```

Runs only when `data` changes ‚Üí prevents unnecessary CPU work.

---

## **(C) useCallback**

Memoizes a **function reference**.

Useful when passing callbacks to child components.

```jsx
const handleClick = useCallback(() => {
  console.log("clicked");
}, []);
```

Prevents unnecessary re-renders in children using `React.memo`.

---

# üéØ Interview summary:

> React memoization optimizes rendering by caching components (React.memo), functions (useCallback), and computed values (useMemo).

---

# ============================

# ‚úÖ **2. What causes unnecessary re-renders?**

# ============================

### ‚ùå Common reasons:

1. **Parent re-renders ‚Üí all child components re-render**
2. **Inline objects/functions**

```jsx
<Child config={{ dark: true }} />
```

3. **State updates that don‚Äôt change actual value**

```jsx
setCount(count)  // still triggers render
```

4. **Context updates re-rendering entire subtree**
5. **Passing unstable references**
6. **Not using React.memo**

---

### ‚úî Good example to reduce re-renders:

```jsx
const config = useMemo(() => ({ dark: true }), []);
```

---

# üéØ Interview summary:

> Components re-render when state, props, or context change OR when reference values (objects/functions) change.

---

# ============================

# ‚úÖ **3. How do you optimize a large list in React?**

# ============================

Rendering 1,000+ DOM nodes kills performance.

### ‚úî Solutions:

---

## **(A) React.memo**

Prevents child items from re-rendering.

---

## **(B) Windowing (Virtualization)**

Libraries:

* **react-window**
* **react-virtualized**

### ‚úî Only render items that are visible on the screen.

Example (react-window):

```jsx
import { FixedSizeList as List } from "react-window";

<List
  height={400}
  itemCount={10000}
  itemSize={35}
  width={300}
>
  {({ index, style }) => <div style={style}>Row {index}</div>}
</List>
```

**The browser renders ~10 items at a time instead of 10,000.**

---

## **(C) Pagination or infinite scroll**

Render items gradually.

---

## **(D) Key optimization**

Unique, stable keys:

```jsx
<li key={item.id} />
```

---

# üéØ Interview summary:

> Optimizing large lists typically uses windowing (react-window) to render only visible items.

---

# ============================

# ‚úÖ **4. React.memo**

# ============================

`React.memo(Component)` prevents a functional component from re-rendering if **props are the same**.

Example:

```jsx
const User = React.memo(function User({ name }) {
  return <p>{name}</p>;
});
```

If `name` does not change ‚Üí User does NOT re-render.

---

### Custom comparison:

```jsx
React.memo(Component, (prevProps, nextProps) => {
  return prevProps.value === nextProps.value;
});
```

---

# üéØ Interview summary:

> React.memo is used to memoize components and avoid re-renders when props haven't changed.

---

# ============================

# ‚úÖ **5. What is Windowing (Virtualization)?**

# ============================

Rendering thousands of rows slows down the browser.

Windowing =

* Render only the elements visible on screen.
* Recycle components as the user scrolls.

### Libraries:

‚úî react-window
‚úî react-virtualized

---

### Example:

```jsx
<FixedSizeList height={400} width={300} itemCount={10000} itemSize={35}>
  {({ index, style }) => <div style={style}>Row {index}</div>}
</FixedSizeList>
```

---

# üéØ Interview summary:

> Windowing drastically boosts performance by rendering only what the user sees.

---

# ============================

# ‚úÖ **6. What is code splitting and lazy loading?**

# ============================

### ‚ùó Problem:

Large bundle size = slow initial load.

---

# ‚≠ê Code Splitting = Split app into smaller chunks that load when needed.

React uses:

```jsx
const Dashboard = React.lazy(() => import("./Dashboard"));
```

Used with Suspense:

```jsx
<Suspense fallback={<Loading />}>
  <Dashboard />
</Suspense>
```

---

### Benefits:

‚úî Faster initial load
‚úî Load pages/components only when needed
‚úî Better Lighthouse performance

---

# üéØ Interview summary:

> Code splitting + lazy loading improves performance by loading only the required parts of the app.

---

# ============================

# ‚úÖ **7. What is React Profiler?**

# ============================

React Profiler helps find performance issues.

### ‚úî It shows:

* Which components re-rendered
* How long rendering took
* Why they re-rendered
* Visual flame chart of re-render paths

---

### How to use:

In React DevTools ‚Üí "Profiler" tab.

Wrap component to measure performance:

```jsx
<Profiler id="UserList" onRender={callback}>
  <UserList />
</Profiler>
```

---

### Example callback:

```jsx
function callback(
  id, 
  phase, 
  actualTime, 
  baseTime, 
  startTime, 
  commitTime
) {
  console.log(`Rendered ${id} in ${actualTime}ms`);
}
```

---

# üéØ Interview summary:

> The React Profiler shows why components render and helps diagnose unnecessary renders, making it essential for performance tuning.

---

# ============================

# ‚≠ê Final Interview Summary (Say this)

# ============================

> React memoization (React.memo, useMemo, useCallback) reduces unnecessary re-renders.
> Large lists should be optimized using windowing libraries like react-window.
> Code splitting + lazy loading improves initial load performance.
> Unnecessary re-renders happen when props or states are updated or when unstable values are passed.
> React Profiler helps identify rendering bottlenecks and optimize performance.

---

