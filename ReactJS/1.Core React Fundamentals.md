Below are **clear, interview-ready explanations + examples** for all key React questions ‚Äî ideal for **2+ years experience**.

---

# ‚úÖ **1. What are the main features of React?**

React is a **JavaScript library for building user interfaces**, especially dynamic, component-based UIs.

### ‚≠ê Key Features:

### **1. Component-Based Architecture**

UI is split into reusable pieces (components).

### **2. Virtual DOM**

Efficient rendering by updating only required parts of the real DOM.

### **3. Declarative UI**

You describe **what** the UI should look like; React manages the updates.

### **4. Unidirectional Data Flow**

Data flows **one-way** (parent ‚Üí child), making apps predictable.

### **5. JSX**

HTML-like syntax inside JavaScript, improves readability.

### **6. React Hooks (Functional components)**

Manage state, lifecycle, and side effects without classes.

### **7. Large ecosystem**

React Router, Redux, React Query, etc.

---

# ‚úÖ **2. Explain Virtual DOM and how React uses it.**

### ‚ùó Problem with Real DOM:

Updating the browser DOM is slow. Even small updates cause layout & repaint.

---

# ‚≠ê What is the Virtual DOM (VDOM)?

* A **lightweight JavaScript object representation** of the real DOM.
* React maintains this copy for efficient updates.

---

# ‚≠ê How React uses the Virtual DOM:

### Step-by-step:

1. When state changes ‚Üí React creates a **new Virtual DOM tree**.
2. React compares old vs new Virtual DOM using **diffing algorithm**.
3. Only the changed nodes are updated in the real DOM.
4. React batches updates for performance.

---

### ‚úî Example:

```jsx
const [count, setCount] = useState(0);

<button onClick={() => setCount(count + 1)}>
  {count}
</button>
```

Only `{count}` is re-rendered, not the entire page.

---

# üéØ Interview summary:

> React uses the Virtual DOM to minimize real DOM operations. It compares old and new VDOM trees, finds differences, and updates only necessary parts.

---

# ‚úÖ **3. What is JSX and why do we use it?**

### ‚≠ê JSX =

JavaScript + XML-like syntax.

```jsx
const element = <h1>Hello, world!</h1>;
```

It is NOT HTML. It compiles down to:

```js
React.createElement("h1", null, "Hello, world!");
```

---

### ‚úî Why use JSX?

1. **Cleaner + readable UI code**
2. **Mix JS + UI in one file (component-based)**
3. **Compile-time errors (safer than template strings)**
4. **Easier to visualize UI structure**

---

# üéØ Interview summary:

> JSX is a syntax extension that lets you write UI using HTML-like markup inside JavaScript. It improves readability and compiles to React.createElement calls.

---

# ‚úÖ **4. What are React components? Difference between class and functional components?**

### ‚≠ê React Components:

Reusable building blocks of UI.
Each component returns UI (JSX).

---

## **Functional Component**

A JavaScript function that returns JSX.

```jsx
function Greeting() {
  return <h1>Hello!</h1>;
}
```

### Pros:

‚úî Simpler
‚úî Faster
‚úî Hooks support
‚úî Recommended in modern React

---

## **Class Component**

Uses `class` syntax + lifecycle methods.

```jsx
class Greeting extends React.Component {
  render() {
    return <h1>Hello!</h1>;
  }
}
```

### Cons:

‚úò More boilerplate
‚úò No hooks
‚úò Deprecated in many projects

---

# üéØ Interview summary:

> Today, functional components with hooks are preferred. Class components are older and used before hooks were introduced.

---

# ‚úÖ **5. What are props vs state? When do you use each?**

## ‚≠ê Props = Read-only inputs from parent

* Passed **from parent to child**
* Cannot be modified by child
* Used for **configuration**

### Example:

```jsx
function Welcome(props) {
  return <h1>Hello {props.name}</h1>;
}
```

---

## ‚≠ê State = Internal, mutable data of a component

* Managed **inside** component
* Changes via `setState` or `useState`
* Causes re-render

### Example:

```jsx
const [count, setCount] = useState(0);
```

---

### ‚úî When to use each?

| Use case                        | Props | State |
| ------------------------------- | ----- | ----- |
| Data **passed** to a component  | ‚úî     | ‚úò     |
| Data **owned** by component     | ‚úò     | ‚úî     |
| Data that **changes over time** | ‚úò     | ‚úî     |
| Read-only configuration         | ‚úî     | ‚úò     |

---

# üéØ Interview summary:

> Props are external and immutable. State is internal and mutable. Props configure components; state controls behavior and dynamic data.

---

# ‚úÖ **6. Why is state immutable in React?**

State **must not be modified directly** like:

```jsx
state.count = 5; // ‚ùå WRONG
```

### ‚≠ê Reasons:

1. **Direct mutation does NOT trigger re-render**
2. React‚Äôs Virtual DOM diffing relies on **reference changes**
3. Predictable state flow ‚Üí fewer bugs
4. Helps optimize performance (memoization, PureComponent)

---

### ‚úî Correct way:

```jsx
setCount(count + 1);
```

---

# üéØ Interview summary:

> React state is immutable because updating state directly bypasses React‚Äôs rendering and diffing mechanism.

---

# ‚úÖ **7. What is the significance of keys in React lists?**

Keys help React identify which items changed or moved.

---

### ‚úî Example:

```jsx
<ul>
  {items.map(item => (
    <li key={item.id}>{item.name}</li>
  ))}
</ul>
```

---

### ‚≠ê Why keys are important:

1. **Improves performance** (efficient diffing)
2. **Prevents re-render bugs** (especially in forms)
3. **Maintains stable identity of elements**

---

### ‚ùå Bad example (using index):

```jsx
<li key={index}>...</li>
```

Why it's bad:

* Incorrect when list order changes
* Causes unnecessary re-renders
* Breaks input state inside lists

---

# üéØ Interview summary:

> Keys give React a way to identify list items uniquely during re-render. They prevent bugs and improve performance.

---

# ‚≠ê Want the next set of React questions?

I can give:

‚úî React lifecycle methods
‚úî Hooks (useEffect, useMemo, useCallback, useRef)
‚úî Context API
‚úî Redux interview questions
‚úî React performance optimization
‚úî Real frontend scenario-based React questions

Just say **‚ÄúNext React questions‚Äù**.
