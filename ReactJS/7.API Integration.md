Below are **clear, professional, interview-ready explanations + code examples** for API calls using **fetch/axios**, handling **loading**, **error**, **retry**, **debounce**, **throttle**, and **canceling API requests** in React.

---

# ================================

# âœ… 1. **How do you call an API using fetch or axios?**

# ================================

## â­ Using **fetch**

```jsx
useEffect(() => {
  async function loadData() {
    const res = await fetch("https://api.example.com/users");
    const data = await res.json();
    console.log(data);
  }
  loadData();
}, []);
```

---

## â­ Using **axios**

```jsx
import axios from "axios";

useEffect(() => {
  axios.get("https://api.example.com/users")
       .then(res => console.log(res.data))
       .catch(err => console.error(err));
}, []);
```

---

# ================================

# âœ… 2. How do you handle loading state?

# ================================

### âœ” Example with fetch + loading state:

```jsx
function UserList() {
  const [loading, setLoading] = useState(true);
  const [users, setUsers] = useState([]);

  useEffect(() => {
    async function load() {
      try {
        const res = await fetch("/api/users");
        const data = await res.json();
        setUsers(data);
      } finally {
        setLoading(false);
      }
    }
    load();
  }, []);

  if (loading) return <p>Loading...</p>;
  return <div>{users.length} users found</div>;
}
```

---

# ================================

# âœ… 3. How do you handle error state?

# ================================

```jsx
const [error, setError] = useState(null);

useEffect(() => {
  async function load() {
    try {
      const res = await fetch("/api/users");
      if (!res.ok) throw new Error("Network error");
      const data = await res.json();
      setUsers(data);
    } catch (err) {
      setError(err.message);
    }
  }
  load();
}, []);

if (error) return <p>Error: {error}</p>;
```

---

# ================================

# âœ… 4. How do you implement retry logic?

# ================================

### â­ Retry API call up to 3 times:

```jsx
async function fetchWithRetry(url, attempts = 3) {
  try {
    const res = await fetch(url);
    if (!res.ok) throw new Error("Failed");
    return await res.json();
  } catch (err) {
    if (attempts === 1) throw err;
    return fetchWithRetry(url, attempts - 1);
  }
}
```

Usage:

```jsx
useEffect(() => {
  fetchWithRetry("/api/users")
    .then(setUsers)
    .catch(err => setError(err.message));
}, []);
```

---

# ================================

# âœ… 5. What is debounce vs throttle in API calls?

# ================================

## â­ Debounce

Waits for the **user to stop typing** before calling the API.

Use cases:

* Search bar
* Auto-suggestion

Example:

* User types "apple"
* Wait 300ms after typing stops
* Then fire API call

---

## â­ Throttle

Limits API calls to **once every X milliseconds**, no matter how many times the user triggers it.

Use cases:

* Scrolling events
* Resize events

---

### Visual Difference:

| user types â†’ | debounce waits        | throttle limits          |
| ------------ | --------------------- | ------------------------ |
| a-b-c-d      | fires ONCE at the end | fires at fixed intervals |

---

### Example debounce function:

```js
function debounce(fn, delay) {
  let timer;
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => fn(...args), delay);
  };
}
```

---

### Example throttle function:

```js
function throttle(fn, interval) {
  let last = 0;
  return (...args) => {
    const now = Date.now();
    if (now - last >= interval) {
      fn(...args);
      last = now;
    }
  };
}
```

---

# ================================

# âœ… 6. How do you cancel API requests in React?

# ================================

Cancelling prevents:

* Memory leaks
* Updating state after unmount
* Wasting network calls

---

## â­ Cancel fetch using AbortController

```jsx
useEffect(() => {
  const controller = new AbortController();

  fetch("/api/users", { signal: controller.signal })
    .then(res => res.json())
    .then(setUsers)
    .catch(err => {
      if (err.name === "AbortError") console.log("Fetch cancelled");
    });

  return () => controller.abort();
}, []);
```

âœ” If component unmounts â†’ API aborted
âœ” Prevents "Can't perform React state update on unmounted component" warning

---

## â­ Cancel axios request

```jsx
useEffect(() => {
  const controller = new AbortController();

  axios.get("/api/users", { signal: controller.signal })
    .then(res => setUsers(res.data))
    .catch(err => {
      if (axios.isCancel(err)) console.log("Cancelled");
    });

  return () => controller.abort();
}, []);
```

---

# ðŸ“Œ Summary Table

| Feature         | How it works               |
| --------------- | -------------------------- |
| Loading         | `setLoading(true â†’ false)` |
| Error           | Try/Catch + `setError()`   |
| Retry           | Recursive retry logic      |
| Debounce        | Delay until typing stops   |
| Throttle        | Limit API rate             |
| Cancel requests | `AbortController`          |

---

# ðŸŽ¯ Final Interview Summary (Memorize This)

> You call APIs with fetch or axios.
> While calling APIs in React, you handle `loading`, `error`, and `retry` inside useEffect.
> Debounce delays API calls until user stops typing; throttle limits calls to fixed intervals.
> You should cancel ongoing requests using `AbortController` to prevent memory leaks.

---


