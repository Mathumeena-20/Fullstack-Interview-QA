## üß† 1. What are Lambda Expressions?

**Definition:**
A **lambda expression** is a short way to define an **anonymous function** (without a name).
It helps write cleaner code when working with **functional interfaces** (interfaces with one abstract method).

**Syntax:**

```java
(parameter_list) -> { method_body }
```

**Example:**

```java
public class LambdaDemo {
    public static void main(String[] args) {
        // Without lambda
        Runnable r1 = new Runnable() {
            public void run() {
                System.out.println("Running thread without lambda");
            }
        };
        new Thread(r1).start();

        // With lambda
        Runnable r2 = () -> System.out.println("Running thread with lambda");
        new Thread(r2).start();
    }
}
```

‚úÖ **Output:**

```
Running thread without lambda
Running thread with lambda
```

---

## üß© 2. What is a Functional Interface?

**Definition:**
A **Functional Interface** is an interface with **exactly one abstract method**.
You can annotate it using `@FunctionalInterface`.

Examples:

* `Runnable` (run())
* `Callable` (call())
* `Comparator` (compare())
* `Consumer`, `Supplier`, `Function`, `Predicate` (Java 8 built-ins)

**Example:**

```java
@FunctionalInterface
interface MyFunctional {
    void greet(String name);
}

public class FunctionalInterfaceDemo {
    public static void main(String[] args) {
        MyFunctional f = (name) -> System.out.println("Hello, " + name);
        f.greet("Mathu");
    }
}
```

‚úÖ **Output:**

```
Hello, Mathu
```

---

## üåä 3. Explain Stream API and its Operations

**Definition:**
Stream API allows **functional-style operations** on collections (map, filter, reduce, etc.)
It **does not store data**, only processes it.

**Types of operations:**

1. **Intermediate** ‚Äî return a Stream (e.g., `map`, `filter`, `sorted`)
2. **Terminal** ‚Äî produce a result (e.g., `collect`, `forEach`, `count`)

**Example:**

```java
import java.util.*;
import java.util.stream.*;

public class StreamDemo {
    public static void main(String[] args) {
        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);

        List<Integer> evenSquares = numbers.stream()
                .filter(n -> n % 2 == 0)       // Intermediate
                .map(n -> n * n)               // Intermediate
                .collect(Collectors.toList()); // Terminal

        System.out.println(evenSquares);
    }
}
```

‚úÖ **Output:**

```
[4, 16, 36]
```

---

## üîÑ 4. Difference between `map()` and `flatMap()`

| Method      | Purpose                    | Example                 |
| ----------- | -------------------------- | ----------------------- |
| `map()`     | Transforms each element    | List<A> ‚Üí List<B>       |
| `flatMap()` | Flattens nested structures | List<List<A>> ‚Üí List<A> |

**Example:**

```java
import java.util.*;
import java.util.stream.*;

public class MapFlatMapDemo {
    public static void main(String[] args) {
        List<List<String>> names = Arrays.asList(
                Arrays.asList("Amit", "Anu"),
                Arrays.asList("Balu", "Ben")
        );

        // map(): Stream<List<String>>
        System.out.println("Using map:");
        names.stream()
                .map(list -> list.stream())
                .forEach(System.out::println);  // Prints Stream objects

        // flatMap(): Stream<String>
        System.out.println("\nUsing flatMap:");
        names.stream()
                .flatMap(list -> list.stream())
                .forEach(System.out::println);  // Prints names directly
    }
}
```

‚úÖ **Output:**

```
Using map:
java.util.stream.ReferencePipeline$Head@...
java.util.stream.ReferencePipeline$Head@...

Using flatMap:
Amit
Anu
Balu
Ben
```

---

## üéÅ 5. What is the Optional class?

**Definition:**
`Optional<T>` is a container introduced in Java 8 to **avoid NullPointerExceptions**.
It represents a value that may or may not be present.

**Example:**

```java
import java.util.Optional;

public class OptionalDemo {
    public static void main(String[] args) {
        Optional<String> name = Optional.of("Mathu");
        System.out.println(name.get()); // Mathu

        Optional<String> empty = Optional.empty();

        // Safely handle null
        System.out.println(empty.orElse("Default"));
        System.out.println(empty.orElseGet(() -> "Generated Default"));
    }
}
```

‚úÖ **Output:**

```
Mathu
Default
Generated Default
```

---

## üîó 6. What are Method References?

**Definition:**
A **method reference** is a shorthand for a lambda that calls an existing method.

**Syntax types:**

1. **Static method:** `ClassName::staticMethod`
2. **Instance method:** `object::instanceMethod`
3. **Constructor:** `ClassName::new`

**Example:**

```java
import java.util.*;

public class MethodReferenceDemo {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Mathu", "Anu", "Ben");

        // Lambda
        names.forEach(n -> System.out.println(n));

        // Method reference
        names.forEach(System.out::println);
    }
}
```

‚úÖ **Output:**

```
Mathu
Anu
Ben
```

---

## ‚öôÔ∏è 7. What are Default and Static Methods in Interfaces?

**Default Methods:**

* Have body inside an interface.
* Allow adding new functionality without breaking old implementations.

**Static Methods:**

* Belong to the interface, not the object.

**Example:**

```java
interface Vehicle {
    void start();

    default void stop() {
        System.out.println("Vehicle stopped");
    }

    static void service() {
        System.out.println("Vehicle service");
    }
}

public class Car implements Vehicle {
    public void start() {
        System.out.println("Car started");
    }

    public static void main(String[] args) {
        Car c = new Car();
        c.start();
        c.stop();           // default method
        Vehicle.service();  // static method
    }
}
```

‚úÖ **Output:**

```
Car started
Vehicle stopped
Vehicle service
```

---

## üßÆ 8. How do you Filter and Collect Data using Streams?

**Example:**

```java
import java.util.*;
import java.util.stream.*;

public class FilterCollectDemo {
    public static void main(String[] args) {
        List<String> names = Arrays.asList("Mathu", "Anu", "Arun", "Ben", "Mani");

        // Filter names starting with 'A' and collect
        List<String> aNames = names.stream()
                .filter(name -> name.startsWith("A"))
                .collect(Collectors.toList());

        System.out.println(aNames);
    }
}
```

‚úÖ **Output:**

```
[Anu, Arun]
```

---

## üî• Summary Table

| Concept                     | Description                          | Example                   |
| --------------------------- | ------------------------------------ | ------------------------- |
| Lambda                      | Anonymous function                   | `(x) -> x * x`            |
| Functional Interface        | One abstract method                  | `Runnable`, `Predicate`   |
| Stream API                  | Functional processing of collections | `filter()`, `map()`       |
| map() vs flatMap()          | Transform vs Flatten                 | `List<List<T>> ‚Üí List<T>` |
| Optional                    | Avoids null                          | `Optional.ofNullable()`   |
| Method Reference            | Shorthand for lambda                 | `System.out::println`     |
| Default/Static in Interface | Implement logic inside interface     | `default stop()`          |
| Filter + Collect            | Stream data pipeline                 | `.filter().collect()`     |

