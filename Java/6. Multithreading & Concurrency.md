## ðŸ§µ 1. What is a thread in Java?

A **thread** is the smallest unit of a process that can run concurrently with other threads.
Java supports **multithreading**, allowing multiple threads to run in parallel.

**Example:**

```java
public class MyThread extends Thread {
    public void run() {
        System.out.println("Thread is running: " + Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        MyThread t1 = new MyThread();
        t1.start(); // Starts a new thread
        System.out.println("Main thread: " + Thread.currentThread().getName());
    }
}
```

**Output:**

```
Main thread: main
Thread is running: Thread-0
```

---

## âš™ï¸ 2. How to create a thread (2 ways)?

### âœ… Way 1 â€” Extend `Thread` class

```java
class MyThread extends Thread {
    public void run() {
        System.out.println("Running using Thread class");
    }

    public static void main(String[] args) {
        new MyThread().start();
    }
}
```

### âœ… Way 2 â€” Implement `Runnable` interface

```java
class MyRunnable implements Runnable {
    public void run() {
        System.out.println("Running using Runnable interface");
    }

    public static void main(String[] args) {
        Thread t = new Thread(new MyRunnable());
        t.start();
    }
}
```

**When to use:**

* `Runnable` â†’ preferred (allows extending another class, more flexible).

---

## ðŸƒâ€â™‚ï¸ 3. Difference between `start()` and `run()`

| Method    | Behavior                                                               |
| --------- | ---------------------------------------------------------------------- |
| `start()` | Starts a new thread and calls `run()` internally (parallel execution). |
| `run()`   | Just a normal method call (no new thread created).                     |

**Example:**

```java
class Demo extends Thread {
    public void run() {
        System.out.println(Thread.currentThread().getName());
    }

    public static void main(String[] args) {
        Demo d = new Demo();
        d.run();   // executes in main thread
        d.start(); // executes in new thread
    }
}
```

**Output:**

```
main
Thread-0
```

---

## ðŸ” 4. What is synchronization?

Synchronization ensures **only one thread accesses a shared resource** at a time â€” preventing **race conditions**.

**Example (synchronized method):**

```java
class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public int getCount() { return count; }
}

public class SyncExample {
    public static void main(String[] args) throws InterruptedException {
        Counter c = new Counter();

        Thread t1 = new Thread(() -> { for (int i=0;i<1000;i++) c.increment(); });
        Thread t2 = new Thread(() -> { for (int i=0;i<1000;i++) c.increment(); });

        t1.start(); t2.start();
        t1.join(); t2.join();

        System.out.println("Final Count: " + c.getCount());
    }
}
```

Without `synchronized`, output may vary; with it, itâ€™s always `2000`.

---

## âš ï¸ 5. What is a deadlock and how to prevent it?

**Deadlock:** Two or more threads waiting forever for each other to release locks.

**Example:**

```java
class A {}
class B {}

public class DeadlockDemo {
    public static void main(String[] args) {
        final A a = new A();
        final B b = new B();

        Thread t1 = new Thread(() -> {
            synchronized (a) {
                System.out.println("Thread 1 locked A");
                try { Thread.sleep(100); } catch(Exception e){}
                synchronized (b) { System.out.println("Thread 1 locked B"); }
            }
        });

        Thread t2 = new Thread(() -> {
            synchronized (b) {
                System.out.println("Thread 2 locked B");
                synchronized (a) { System.out.println("Thread 2 locked A"); }
            }
        });

        t1.start();
        t2.start();
    }
}
```

Here, both threads wait on each other forever.

**Prevention:**

* Always lock resources in the same order.
* Use `tryLock()` from `ReentrantLock` (non-blocking).
* Use proper timeout mechanisms.

---

## ðŸ˜´ 6. Difference between `wait()` and `sleep()`

| Feature                   | `wait()`             | `sleep()`         |
| ------------------------- | -------------------- | ----------------- |
| Defined in                | `Object` class       | `Thread` class    |
| Releases lock?            | âœ… Yes                | âŒ No              |
| Used for                  | Thread communication | Pausing execution |
| Needs synchronized block? | âœ… Yes                | âŒ No              |

**Example:**

```java
class WaitSleepDemo {
    public static void main(String[] args) throws InterruptedException {
        Object lock = new Object();

        synchronized (lock) {
            lock.wait(1000); // releases lock and waits
            Thread.sleep(1000); // just pauses current thread
        }
    }
}
```

---

## ðŸ§  7. What is `volatile` keyword?

* Ensures **visibility** of variable changes across threads.
* Prevents threads from caching the variable locally.

**Example (without volatile):**

```java
class SharedData {
    boolean flag = false;
}

public class VolatileDemo {
    public static void main(String[] args) {
        SharedData data = new SharedData();

        new Thread(() -> {
            while (!data.flag) {}
            System.out.println("Flag changed!");
        }).start();

        try { Thread.sleep(1000); } catch (Exception e) {}
        data.flag = true; // may never be seen by thread (no volatile)
    }
}
```

âœ… Fix:

```java
class SharedData {
    volatile boolean flag = false;
}
```

---

## ðŸ§© 8. What is `ExecutorService` and thread pooling?

* Creating threads repeatedly is expensive.
* **Thread pool** manages a group of reusable threads.
* `ExecutorService` is used to execute tasks asynchronously.

**Example:**

```java
import java.util.concurrent.*;

public class ThreadPoolExample {
    public static void main(String[] args) {
        ExecutorService executor = Executors.newFixedThreadPool(3);

        for (int i = 1; i <= 5; i++) {
            int task = i;
            executor.execute(() -> System.out.println("Task " + task + " executed by " + Thread.currentThread().getName()));
        }

        executor.shutdown(); // stop accepting new tasks
    }
}
```

**Output:**

```
Task 1 executed by pool-1-thread-1
Task 2 executed by pool-1-thread-2
...
```

---

## âš¡ 9. Difference between `Runnable` and `Callable`

| Feature            | Runnable                       | Callable                    |
| ------------------ | ------------------------------ | --------------------------- |
| Return type        | void                           | Returns a value             |
| Exception handling | Cannot throw checked exception | Can throw checked exception |
| Method             | `run()`                        | `call()`                    |
| Result retrieval   | Not possible                   | Use `Future.get()`          |

**Example:**

```java
import java.util.concurrent.*;

public class CallableExample {
    public static void main(String[] args) throws Exception {
        Callable<Integer> task = () -> {
            Thread.sleep(500);
            return 10 + 20;
        };

        ExecutorService executor = Executors.newSingleThreadExecutor();
        Future<Integer> result = executor.submit(task);

        System.out.println("Result: " + result.get());
        executor.shutdown();
    }
}
```

**Output:**

```
Result: 30
```

---

âœ… **Summary Table**

| Concept              | Key Point                             |
| -------------------- | ------------------------------------- |
| Thread               | Smallest execution unit               |
| start() vs run()     | start â†’ new thread; run â†’ same thread |
| Synchronization      | Prevents race conditions              |
| Deadlock             | Circular lock dependency              |
| wait() vs sleep()    | wait releases lock; sleep doesnâ€™t     |
| volatile             | Ensures visibility across threads     |
| ExecutorService      | Manages thread pool                   |
| Runnable vs Callable | Callable returns a result             |

