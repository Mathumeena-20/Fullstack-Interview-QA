## ‚òëÔ∏è **1Ô∏è‚É£ Difference between Checked and Unchecked Exceptions**

| Feature              | **Checked Exception**                                         | **Unchecked Exception**                                                         |
| -------------------- | ------------------------------------------------------------- | ------------------------------------------------------------------------------- |
| **When checked**     | At **compile-time**                                           | At **runtime**                                                                  |
| **Base class**       | `java.lang.Exception` (excluding `RuntimeException`)          | `java.lang.RuntimeException` and subclasses                                     |
| **Must be handled?** | ‚úÖ Must be handled using `try-catch` or declared with `throws` | ‚ùå Not mandatory                                                                 |
| **Examples**         | `IOException`, `SQLException`, `FileNotFoundException`        | `NullPointerException`, `ArrayIndexOutOfBoundsException`, `ArithmeticException` |

**üí° Example:**

```java
// Checked Exception Example
import java.io.*;
class CheckedExample {
    public static void main(String[] args) {
        try {
            FileReader fr = new FileReader("file.txt"); // may cause FileNotFoundException
        } catch (IOException e) {
            System.out.println("File not found: " + e.getMessage());
        }
    }
}

// Unchecked Exception Example
class UncheckedExample {
    public static void main(String[] args) {
        int a = 5 / 0; // ArithmeticException
    }
}
```

---

## üß© **2Ô∏è‚É£ Explain try, catch, finally, throw, and throws**

| Keyword     | Purpose                                              | Example                                              |
| ----------- | ---------------------------------------------------- | ---------------------------------------------------- |
| **try**     | Defines the block of code to monitor for exceptions. | `try { int x = 5/0; }`                               |
| **catch**   | Handles the exception.                               | `catch (ArithmeticException e) { ... }`              |
| **finally** | Executes **always**, regardless of exception.        | `finally { System.out.println("Always executed"); }` |
| **throw**   | Used to **manually throw** an exception.             | `throw new IOException("File not found");`           |
| **throws**  | Declares that a method may throw exceptions.         | `void read() throws IOException { ... }`             |

**üí° Example:**

```java
class Demo {
    static void divide(int a, int b) throws ArithmeticException {
        if (b == 0)
            throw new ArithmeticException("Cannot divide by zero");
        else
            System.out.println("Result: " + (a / b));
    }

    public static void main(String[] args) {
        try {
            divide(10, 0);
        } catch (ArithmeticException e) {
            System.out.println("Caught Exception: " + e.getMessage());
        } finally {
            System.out.println("Execution completed");
        }
    }
}
```

**‚úÖ Output:**

```
Caught Exception: Cannot divide by zero
Execution completed
```

---

## üß† **3Ô∏è‚É£ Can we have multiple catch blocks?**

‚úÖ **Yes.**
You can handle different exception types **separately** with multiple `catch` blocks.

**üí° Example:**

```java
try {
    int a = 10 / 0;
    int[] arr = new int[2];
    arr[3] = 5;
} 
catch (ArithmeticException e) {
    System.out.println("Arithmetic error: " + e.getMessage());
} 
catch (ArrayIndexOutOfBoundsException e) {
    System.out.println("Array index error");
} 
catch (Exception e) { // parent class
    System.out.println("General exception");
}
```

‚úÖ **Note:**
Always write **child exceptions first**, then **parent** (`Exception`) last, otherwise compiler error occurs.

---

## üßæ **4Ô∏è‚É£ Can finally block be skipped?**

‚úÖ The `finally` block **always executes**, **except** in these cases:

1. **`System.exit(0)` is called**
2. **The JVM crashes** or **power failure**
3. **`Thread.kill()` (deprecated)**

**üí° Example:**

```java
try {
    System.out.println("Inside try");
    System.exit(0); // JVM exits here
} finally {
    System.out.println("This will NOT execute");
}
```

**‚úÖ Output:**

```
Inside try
```

---

## üß∞ **5Ô∏è‚É£ How to create Custom Exceptions?**

‚úÖ You can create your own exception class by **extending** either:

* `Exception` ‚Üí checked custom exception
* `RuntimeException` ‚Üí unchecked custom exception

**üí° Example: Custom Checked Exception**

```java
class InvalidAgeException extends Exception {
    public InvalidAgeException(String message) {
        super(message);
    }
}

class TestCustomException {
    static void validate(int age) throws InvalidAgeException {
        if (age < 18)
            throw new InvalidAgeException("Age must be 18 or above");
        else
            System.out.println("Welcome!");
    }

    public static void main(String[] args) {
        try {
            validate(16);
        } catch (InvalidAgeException e) {
            System.out.println("Caught: " + e.getMessage());
        }
    }
}
```

**‚úÖ Output:**

```
Caught: Age must be 18 or above
```

---

## üí• **6Ô∏è‚É£ Difference between Error and Exception**

| Feature           | **Error**                                | **Exception**                   |
| ----------------- | ---------------------------------------- | ------------------------------- |
| **Package**       | `java.lang.Error`                        | `java.lang.Exception`           |
| **Recoverable?**  | ‚ùå Generally not recoverable              | ‚úÖ Can be handled with try-catch |
| **Occurs due to** | JVM issues or hardware                   | Application logic issues        |
| **Examples**      | `OutOfMemoryError`, `StackOverflowError` | `IOException`, `SQLException`   |

**üí° Example:**

```java
public class Example {
    public static void main(String[] args) {
        try {
            int[] arr = new int[1000000000]; // May cause OutOfMemoryError
        } catch (OutOfMemoryError e) {
            System.out.println("Caught error (not usual practice)");
        }
    }
}
```

‚úÖ **Rule:** Never catch `Error` ‚Äî it usually indicates serious JVM problems.

---

## üß± **7Ô∏è‚É£ How do you handle exceptions in layered architecture (Controller ‚Üí Service ‚Üí DAO)?**

In **Spring Boot or layered applications**, we separate exception handling **per layer** for maintainability and clean architecture.

---

### **Typical 3-Layer Flow**

```
Controller ‚Üí Service ‚Üí DAO (Repository)
```

Each layer may throw exceptions, which are handled either locally or globally.

---

### **Example Implementation**

#### üß© 1. DAO Layer

```java
@Repository
public class UserDao {
    public User findUser(int id) throws SQLException {
        // Simulating DB exception
        throw new SQLException("Database not reachable");
    }
}
```

#### üß© 2. Service Layer

```java
@Service
public class UserService {
    @Autowired
    private UserDao userDao;

    public User getUser(int id) {
        try {
            return userDao.findUser(id);
        } catch (SQLException e) {
            throw new RuntimeException("Service: Unable to fetch user", e);
        }
    }
}
```

#### üß© 3. Controller Layer

```java
@RestController
public class UserController {
    @Autowired
    private UserService userService;

    @GetMapping("/user/{id}")
    public ResponseEntity<String> getUser(@PathVariable int id) {
        try {
            userService.getUser(id);
            return ResponseEntity.ok("User found");
        } catch (RuntimeException e) {
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                                 .body(e.getMessage());
        }
    }
}
```

---

### üß© 4. Global Exception Handler (Best Practice)

Instead of handling in every controller, you can use:

```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(RuntimeException.class)
    public ResponseEntity<String> handleRuntime(RuntimeException ex) {
        return new ResponseEntity<>("Error: " + ex.getMessage(), HttpStatus.BAD_REQUEST);
    }
}
```

‚úÖ **Advantages:**

* Clean code (no repeated try-catch)
* Centralized error handling
* Easier debugging and logging

---

## ‚úÖ **Summary (Quick Notes for Interview)**

| Concept             | Key Idea                                          |
| ------------------- | ------------------------------------------------- |
| Checked Exception   | Checked at compile-time (`IOException`)           |
| Unchecked Exception | Checked at runtime (`NullPointerException`)       |
| try-catch-finally   | Handles and ensures cleanup                       |
| throw               | Manually throw an exception                       |
| throws              | Declares possible exception                       |
| Multiple catch      | Yes, but order child ‚Üí parent                     |
| finally skip cases  | Only on `System.exit()` or JVM crash              |
| Custom Exception    | Extend `Exception` or `RuntimeException`          |
| Error vs Exception  | Error ‚Üí unrecoverable; Exception ‚Üí recoverable    |
| Layered handling    | Use global `@RestControllerAdvice` for clean code |

---
