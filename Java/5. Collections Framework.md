## üß© 1. Difference between List, Set, and Map

| Feature    | List                      | Set                       | Map                                             |
| ---------- | ------------------------- | ------------------------- | ----------------------------------------------- |
| Duplicates | ‚úÖ Allows                  | ‚ùå Not allowed             | Keys ‚ùå, Values ‚úÖ                                |
| Order      | Maintains insertion order | Depends on implementation | No defined order (unless LinkedHashMap/TreeMap) |
| Access     | Index-based               | No index                  | Key-based                                       |
| Examples   | `ArrayList`, `LinkedList` | `HashSet`, `TreeSet`      | `HashMap`, `TreeMap`                            |

**Example:**

```java
import java.util.*;

public class CollectionExample {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("A");
        list.add("A"); // duplicate allowed
        System.out.println("List: " + list);

        Set<String> set = new HashSet<>();
        set.add("A");
        set.add("A"); // duplicate ignored
        System.out.println("Set: " + set);

        Map<Integer, String> map = new HashMap<>();
        map.put(1, "A");
        map.put(1, "B"); // key duplicate, value replaced
        System.out.println("Map: " + map);
    }
}
```

**Output:**

```
List: [A, A]
Set: [A]
Map: {1=B}
```

---

## üß± 2. Difference between ArrayList and LinkedList

| Feature            | ArrayList               | LinkedList            |
| ------------------ | ----------------------- | --------------------- |
| Data structure     | Dynamic array           | Doubly linked list    |
| Access time        | Fast (O(1)) using index | Slow (O(n)) traversal |
| Insertion/Deletion | Slow (shifting needed)  | Fast (no shifting)    |
| Memory usage       | Less                    | More (extra pointers) |

**Example:**

```java
List<String> arrayList = new ArrayList<>();
List<String> linkedList = new LinkedList<>();

arrayList.add("A");
arrayList.add("B");
linkedList.add("X");
linkedList.add("Y");

System.out.println(arrayList); // [A, B]
System.out.println(linkedList); // [X, Y]
```

**When to use:**

* **ArrayList** ‚Üí Random access
* **LinkedList** ‚Üí Frequent insertions/deletions

---

## ‚öôÔ∏è 3. How does a HashMap work internally?

**Core idea:**

* Stores key-value pairs.
* Uses **hashing**:

  1. Compute hash code of key
  2. Find bucket index using `(hash % capacity)`
  3. If collision ‚Üí store in linked list or tree (Java 8+ uses **balanced tree** if bucket size > 8)

**Example:**

```java
Map<String, Integer> map = new HashMap<>();
map.put("A", 10);
map.put("B", 20);
System.out.println(map.get("A")); // 10
```

**Internal working steps:**

1. Key `"A"` ‚Üí `hash("A")` ‚Üí bucket index
2. Store new `Node(hash, key, value, next)`
3. On retrieval, compute hash again ‚Üí traverse bucket ‚Üí match key ‚Üí return value

**Load Factor (default 0.75)** ‚Üí when `size > capacity * 0.75`, resize (rehash)

---

## üîí 4. Difference between HashMap and Hashtable

| Feature         | HashMap                      | Hashtable                   |
| --------------- | ---------------------------- | --------------------------- |
| Synchronization | ‚ùå Not synchronized           | ‚úÖ Synchronized              |
| Null key/value  | ‚úÖ 1 null key allowed         | ‚ùå Not allowed               |
| Performance     | Faster                       | Slower (thread safe)        |
| Legacy          | Part of Java 1.2 Collections | Legacy class (pre-Java 1.2) |

**Example:**

```java
Map<Integer, String> hashMap = new HashMap<>();
hashMap.put(null, "A");
System.out.println(hashMap.get(null)); // Works

Hashtable<Integer, String> hashtable = new Hashtable<>();
// hashtable.put(null, "B"); // Throws NullPointerException
```

---

## üå≥ 5. Difference between HashSet and TreeSet

| Feature        | HashSet           | TreeSet                       |
| -------------- | ----------------- | ----------------------------- |
| Order          | Unordered         | Sorted (ascending by default) |
| Implementation | Backed by HashMap | Backed by TreeMap             |
| Null elements  | Allows one null   | Does **not** allow null       |
| Performance    | Faster (O(1))     | Slower (O(log n))             |

**Example:**

```java
Set<Integer> hashSet = new HashSet<>();
hashSet.add(5);
hashSet.add(1);
hashSet.add(3);
System.out.println(hashSet); // Random order

Set<Integer> treeSet = new TreeSet<>();
treeSet.add(5);
treeSet.add(1);
treeSet.add(3);
System.out.println(treeSet); // [1, 3, 5]
```

---

## üß† 6. What is ConcurrentHashMap?

* A **thread-safe version** of HashMap.
* Uses **segmented locking** (not full map locking).
* Allows **concurrent reads and writes** without blocking.
* Added in **Java 1.5**.

**Example:**

```java
import java.util.concurrent.ConcurrentHashMap;

public class ConcurrentExample {
    public static void main(String[] args) {
        ConcurrentHashMap<Integer, String> map = new ConcurrentHashMap<>();
        map.put(1, "A");
        map.put(2, "B");
        System.out.println(map);
    }
}
```

**Key Point:** Unlike `Hashtable`, it allows concurrency and better performance in multi-threaded environments.

---

## ‚ö° 7. Fail-Fast vs Fail-Safe Iterators

| Type          | Example                                     | Behavior                                                              |
| ------------- | ------------------------------------------- | --------------------------------------------------------------------- |
| **Fail-Fast** | `ArrayList`, `HashMap`                      | Throws `ConcurrentModificationException` if modified during iteration |
| **Fail-Safe** | `ConcurrentHashMap`, `CopyOnWriteArrayList` | Works on a copy, no exception thrown                                  |

**Example:**

```java
List<Integer> list = new ArrayList<>();
list.add(1); list.add(2);

for (Integer i : list) {
    list.add(3); // ConcurrentModificationException
}
```

**Fail-Safe Example:**

```java
CopyOnWriteArrayList<Integer> safeList = new CopyOnWriteArrayList<>();
safeList.add(1); safeList.add(2);

for (Integer i : safeList) {
    safeList.add(3); // Works fine
}
```

---

## üìä 8. Sorting Custom Objects (Comparable & Comparator)

### ‚úÖ Using Comparable (natural order)

```java
class Student implements Comparable<Student> {
    int id;
    String name;
    Student(int id, String name) { this.id = id; this.name = name; }

    @Override
    public int compareTo(Student s) {
        return this.id - s.id; // Ascending by ID
    }

    public String toString() { return id + " - " + name; }
}

public class ComparableDemo {
    public static void main(String[] args) {
        List<Student> list = new ArrayList<>();
        list.add(new Student(2, "John"));
        list.add(new Student(1, "Alice"));

        Collections.sort(list);
        System.out.println(list); // Sorted by ID
    }
}
```

### ‚úÖ Using Comparator (custom order)

```java
import java.util.*;

class Student {
    int id; String name;
    Student(int id, String name) { this.id = id; this.name = name; }
    public String toString() { return id + " - " + name; }
}

public class ComparatorDemo {
    public static void main(String[] args) {
        List<Student> list = Arrays.asList(
            new Student(2, "John"),
            new Student(1, "Alice")
        );

        list.sort(Comparator.comparing(s -> s.name));
        System.out.println(list); // Sorted by name
    }
}
