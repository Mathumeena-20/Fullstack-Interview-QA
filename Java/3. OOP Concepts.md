## ‚öôÔ∏è **1Ô∏è‚É£ Explain the four pillars of OOP**

The **four main pillars** (principles) of Object-Oriented Programming are:

| Pillar            | Description                                                                           | Example                                                                  |
| ----------------- | ------------------------------------------------------------------------------------- | ------------------------------------------------------------------------ |
| **Encapsulation** | Binding data (variables) and methods (functions) together into a single unit (class). | Hiding internal details using private fields and public getters/setters. |
| **Abstraction**   | Hiding complex implementation details and showing only the necessary functionality.   | Abstract classes, Interfaces.                                            |
| **Inheritance**   | Acquiring properties and behaviors of a parent class into a child class.              | `class Child extends Parent`                                             |
| **Polymorphism**  | Ability of an object to take many forms ‚Äî same method behaves differently.            | Method Overloading, Overriding                                           |

---

## üß± **2Ô∏è‚É£ Difference between Abstraction and Encapsulation**

| Feature         | **Abstraction**                   | **Encapsulation**                             |
| --------------- | --------------------------------- | --------------------------------------------- |
| **Focus**       | Hides *implementation complexity* | Hides *data* (data protection)                |
| **Achieved by** | Abstract classes, Interfaces      | Access modifiers (private, public, protected) |
| **Purpose**     | Show only what‚Äôs necessary        | Restrict unauthorized access                  |
| **Example**     | `abstract void draw();`           | private variables with getters/setters        |

**üí° Example:**

```java
// Abstraction example
abstract class Shape {
    abstract void draw(); // hides implementation
}

class Circle extends Shape {
    void draw() { System.out.println("Drawing Circle"); }
}

// Encapsulation example
class Account {
    private double balance; // hidden data

    public void deposit(double amount) { balance += amount; }
    public double getBalance() { return balance; }
}
```

---

## üß¨ **3Ô∏è‚É£ What is Inheritance? Can you inherit multiple classes?**

**üëâ Definition:**
Inheritance allows a **child class (subclass)** to **reuse** fields and methods of a **parent class (superclass)**.

**üí° Example:**

```java
class Vehicle {
    void start() { System.out.println("Vehicle starting..."); }
}

class Car extends Vehicle {
    void honk() { System.out.println("Car honking!"); }
}

public class Main {
    public static void main(String[] args) {
        Car car = new Car();
        car.start(); // inherited from Vehicle
        car.honk();
    }
}
```

**‚úÖ Output:**

```
Vehicle starting...
Car honking!
```

**üö´ Multiple Inheritance in Java:**
Not allowed for **classes** (to avoid ambiguity), but possible using **interfaces**.

```java
interface A { void show(); }
interface B { void show(); }

class C implements A, B {
    public void show() { System.out.println("Multiple inheritance via interfaces"); }
}
```

---

## üåÄ **4Ô∏è‚É£ What is Polymorphism?**

**üëâ Definition:**
Polymorphism means *‚Äúmany forms‚Äù* ‚Äî the ability of an object to behave differently based on context.

### üîπ Types of Polymorphism

1. **Compile-time Polymorphism** ‚Üí *Method Overloading*
2. **Runtime Polymorphism** ‚Üí *Method Overriding*

---

## üîÑ **5Ô∏è‚É£ Difference between Method Overloading and Method Overriding**

| Feature         | **Overloading**                        | **Overriding**                                                   |
| --------------- | -------------------------------------- | ---------------------------------------------------------------- |
| **Type**        | Compile-time                           | Runtime                                                          |
| **Definition**  | Same method name, different parameters | Same method name, same parameters, different class (inheritance) |
| **Binding**     | Static                                 | Dynamic                                                          |
| **Access**      | Within same class                      | Between parent-child classes                                     |
| **Return type** | Can differ (if parameters differ)      | Must be same or covariant                                        |

**üí° Example:**

```java
// Overloading
class Calculator {
    int add(int a, int b) { return a + b; }
    double add(double a, double b) { return a + b; }
}

// Overriding
class Animal {
    void sound() { System.out.println("Animal sound"); }
}
class Dog extends Animal {
    @Override
    void sound() { System.out.println("Bark"); }
}
```

---

## üß∞ **6Ô∏è‚É£ What is an Abstract Class and an Interface?**

### **Abstract Class**

* Can have **abstract and non-abstract methods**.
* Cannot be instantiated.
* Used for **partial abstraction**.

**üí° Example:**

```java
abstract class Animal {
    abstract void sound(); // abstract method
    void eat() { System.out.println("Eating"); } // concrete method
}

class Dog extends Animal {
    void sound() { System.out.println("Bark"); }
}
```

### **Interface**

* Pure abstraction before Java 8 (only method signatures).
* From Java 8 ‚Üí can have **default** and **static** methods.
* A class **implements** an interface.

**üí° Example:**

```java
interface Animal {
    void sound();
}

class Dog implements Animal {
    public void sound() { System.out.println("Bark"); }
}
```

---

## ‚öñÔ∏è **7Ô∏è‚É£ Difference between Abstract Class and Interface (Java 8+)**

| Feature                  | **Abstract Class**                         | **Interface**                          |
| ------------------------ | ------------------------------------------ | -------------------------------------- |
| **Keyword**              | `abstract`                                 | `interface`                            |
| **Methods**              | Abstract + Concrete                        | Abstract + Default + Static            |
| **Variables**            | Can have any type                          | Implicitly `public static final`       |
| **Constructor**          | Can have constructors                      | ‚ùå Cannot have constructors             |
| **Multiple Inheritance** | Not allowed                                | ‚úÖ Allowed                              |
| **Use When**             | You want partial abstraction & shared code | You want full abstraction or contracts |

**üí° Example (Java 8+)**

```java
interface Vehicle {
    void start();
    default void service() { System.out.println("Default service method"); }
    static void info() { System.out.println("Static method in interface"); }
}

class Car implements Vehicle {
    public void start() { System.out.println("Car starting..."); }
}

public class Main {
    public static void main(String[] args) {
        Car c = new Car();
        c.start();
        c.service(); // default method
        Vehicle.info(); // static method
    }
}
```

**‚úÖ Output:**

```
Car starting...
Default service method
Static method in interface
```

---

## ‚öôÔ∏è **8Ô∏è‚É£ What are Default and Static Methods in Interfaces?**

### **Default Methods:**

* Introduced in Java 8.
* Provide **method body** in interface.
* Used to **add new methods** without breaking existing implementations.

```java
interface Printer {
    default void print() {
        System.out.println("Default Print Method");
    }
}
```

### **Static Methods:**

* Belong to the interface itself, not instances.
* Called using `InterfaceName.methodName()`.

```java
interface Printer {
    static void show() {
        System.out.println("Static method in interface");
    }
}
```

---

## üß© **9Ô∏è‚É£ What is the `super` keyword used for?**

**üëâ Uses of `super`:**

1. To **access parent class variables** or methods hidden by subclass.
2. To **invoke parent class constructor**.

**üí° Example:**

```java
class Parent {
    int value = 10;
    Parent() { System.out.println("Parent Constructor"); }
}

class Child extends Parent {
    int value = 20;
    Child() {
        super(); // call parent constructor
        System.out.println("Child Constructor");
    }

    void show() {
        System.out.println("Parent value: " + super.value);
        System.out.println("Child value: " + value);
    }
}

public class Main {
    public static void main(String[] args) {
        Child c = new Child();
        c.show();
    }
}
```

**‚úÖ Output:**

```
Parent Constructor
Child Constructor
Parent value: 10
Child value: 20
```

---

## üö´ **üîü Can we override a static method?**

**No.**
Static methods belong to the **class**, not to an instance ‚Äî hence **they cannot be overridden**, only **hidden**.

**üí° Example:**

```java
class Parent {
    static void show() { System.out.println("Parent static method"); }
}
class Child extends Parent {
    static void show() { System.out.println("Child static method"); }
}

public class Main {
    public static void main(String[] args) {
        Parent p = new Child();
        p.show(); // calls Parent's method (compile-time binding)
    }
}
```

**‚úÖ Output:**

```
Parent static method
```

Because **static methods are bound at compile-time**, not runtime.

---

## ‚úÖ **Summary (Quick Interview Notes)**

| Concept                      | Key Point                                             |
| ---------------------------- | ----------------------------------------------------- |
| 4 Pillars                    | Encapsulation, Abstraction, Inheritance, Polymorphism |
| Abstraction vs Encapsulation | Implementation hiding vs Data hiding                  |
| Inheritance                  | ‚ÄúIS-A‚Äù relationship                                   |
| Polymorphism                 | Compile-time (overloading), Runtime (overriding)      |
| Abstract Class               | Partial abstraction                                   |
| Interface                    | Full abstraction, multiple inheritance                |
| Default Method               | Implemented inside interface                          |
| Static Method (interface)    | Called via Interface name                             |
| `super` keyword              | Refers to parent class                                |
| Static Override              | Not possible, only hidden                             |

