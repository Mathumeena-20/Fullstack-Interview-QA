## ğŸ§© **1ï¸âƒ£ What is Java and what are its key features?**

**ğŸ‘‰ Answer:**
Java is a **high-level, object-oriented, platform-independent programming language** developed by **Sun Microsystems (now Oracle)**.

**âœ… Key Features of Java:**

1. **Platform Independent:** Write Once, Run Anywhere (WORA).
2. **Object-Oriented:** Everything revolves around classes and objects.
3. **Robust:** Strong memory management, exception handling.
4. **Secure:** No pointers, uses JVM sandbox.
5. **Multithreaded:** Supports multiple threads of execution.
6. **Portable:** Same code runs on any platform.
7. **Dynamic:** Classes are loaded dynamically at runtime.
8. **High Performance:** Uses Just-In-Time (JIT) compiler.

**ğŸ’¡ Example:**

```java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, Java!");
    }
}
```

**Explanation:**
The code is compiled into **bytecode**, which runs on any machine with a **Java Virtual Machine (JVM)**.

---

## âš™ï¸ **2ï¸âƒ£ Difference between JDK, JRE, and JVM**

| Component | Full Form                | Purpose                                              | Contains                                   |
| --------- | ------------------------ | ---------------------------------------------------- | ------------------------------------------ |
| **JDK**   | Java Development Kit     | Used to **develop**, compile, and run Java programs. | JRE + Development Tools (compiler `javac`) |
| **JRE**   | Java Runtime Environment | Used to **run** Java programs.                       | JVM + Libraries                            |
| **JVM**   | Java Virtual Machine     | Executes the bytecode.                               | Converts bytecode â†’ machine code           |

**ğŸ’¡ Example:**

* You write `Hello.java`
* JDK compiles it â†’ `Hello.class` (bytecode)
* JVM executes the bytecode inside JRE.

---

## ğŸ”  **3ï¸âƒ£ What is bytecode?**

**ğŸ‘‰ Answer:**
Bytecode is the **intermediate, platform-independent code** generated by the Java compiler (`javac`) after compiling a `.java` file.

The JVM executes this bytecode.

**ğŸ’¡ Example:**

```bash
javac Hello.java   # compiles to Hello.class
java Hello         # JVM executes Hello.class
```

Inside `Hello.class`, bytecode looks like:

```
0: getstatic #2
3: ldc       #3
6: invokevirtual #4
9: return
```

**âœ… Benefit:**
You can run the same `.class` file on **Windows, Linux, or Mac** â€” thatâ€™s Javaâ€™s **platform independence**.

---

## ğŸŒ **4ï¸âƒ£ How Java achieves platform independence?**

**ğŸ‘‰ Explanation:**
Java achieves platform independence using **JVM**.

* The **Java compiler** converts source code into **bytecode**.
* **JVM** on each platform (Windows/Linux/Mac) interprets the bytecode into native machine instructions.

**ğŸ’¡ Diagram:**

```
.java â†’ (Compiler) â†’ .class (Bytecode) â†’ (JVM) â†’ Machine Code
```

**âœ… Example:**

```java
public class PlatformDemo {
    public static void main(String[] args) {
        System.out.println("Platform Independent!");
    }
}
```

You can run the same `.class` file on any OS that has JVM installed.

---

## ğŸ“¦ **5ï¸âƒ£ What are Wrapper Classes?**

**ğŸ‘‰ Answer:**
Wrapper classes **convert primitive data types into objects**.
They are part of `java.lang` package.

| Primitive Type | Wrapper Class |
| -------------- | ------------- |
| int            | Integer       |
| double         | Double        |
| boolean        | Boolean       |
| char           | Character     |
| float          | Float         |

**ğŸ’¡ Example:**

```java
int x = 10;
Integer y = Integer.valueOf(x); // wrapping
int z = y.intValue();           // unwrapping
```

**âœ… Use Case:**
Needed when working with **Collections** like `ArrayList` (which can store only objects).

---

## ğŸ” **6ï¸âƒ£ What is Autoboxing and Unboxing?**

**ğŸ‘‰ Answer:**
Introduced in Java 5, itâ€™s the **automatic conversion** between primitives and wrapper objects.

* **Autoboxing:** Primitive â†’ Wrapper
* **Unboxing:** Wrapper â†’ Primitive

**ğŸ’¡ Example:**

```java
int a = 10;           // primitive
Integer b = a;        // autoboxing
int c = b;            // unboxing
```

**âœ… Benefit:**
Reduces boilerplate â€” no need for `Integer.valueOf()` or `intValue()` explicitly.

---

## âš–ï¸ **7ï¸âƒ£ Difference between `==` and `.equals()`**

| Comparison  | Used For             | Behavior                                                         |
| ----------- | -------------------- | ---------------------------------------------------------------- |
| `==`        | Reference Comparison | Checks if two references point to the **same object**            |
| `.equals()` | Value Comparison     | Checks if two objects have **equal content** (can be overridden) |

**ğŸ’¡ Example:**

```java
String s1 = new String("Hello");
String s2 = new String("Hello");

System.out.println(s1 == s2);       // false (different objects)
System.out.println(s1.equals(s2));  // true (same content)
```

**âœ… Note:**
For primitives, `==` compares actual values.
For objects, use `.equals()` for value equality.

---

## âš™ï¸ **8ï¸âƒ£ What is the purpose of `static` keyword?**

**ğŸ‘‰ Explanation:**
`static` means the **member belongs to the class**, not an instance (object).

**ğŸ’¡ Uses of static:**

1. **Static Variable:** Shared across all objects.
2. **Static Method:** Can be called without creating an object.
3. **Static Block:** Executes once when the class is loaded.

**ğŸ’¡ Example:**

```java
class Student {
    static String school = "ABC School";
    String name;

    static void showSchool() {
        System.out.println(school);
    }
}

public class Demo {
    public static void main(String[] args) {
        Student.showSchool(); // static method called without object
    }
}
```

---

## ğŸ§  **9ï¸âƒ£ Can we overload `main()` method?**

**ğŸ‘‰ Answer:**
âœ… Yes, you can **overload** `main()` method,
âŒ but **JVM will only call the `main(String[] args)`** method as entry point.

**ğŸ’¡ Example:**

```java
public class MainOverload {
    public static void main(String[] args) {
        System.out.println("Main with String[] args");
        main(5);
    }
    public static void main(int x) {
        System.out.println("Overloaded main: " + x);
    }
}
```

**Output:**

```
Main with String[] args
Overloaded main: 5
```

---

## ğŸ” **ğŸ”Ÿ What are Access Modifiers in Java?**

**ğŸ‘‰ Explanation:**
Access modifiers **control the visibility (scope)** of classes, variables, methods, and constructors.

| Modifier                  | Within Class | Same Package | Subclass (other pkg) | Other Package |
| ------------------------- | ------------ | ------------ | -------------------- | ------------- |
| **private**               | âœ…            | âŒ            | âŒ                    | âŒ             |
| **default** (no modifier) | âœ…            | âœ…            | âŒ                    | âŒ             |
| **protected**             | âœ…            | âœ…            | âœ…                    | âŒ             |
| **public**                | âœ…            | âœ…            | âœ…                    | âœ…             |

**ğŸ’¡ Example:**

```java
public class AccessDemo {
    private int a = 10;
    protected int b = 20;
    public int c = 30;
    int d = 40; // default
}
```

**âœ… Summary:**

* `private` â†’ only inside the same class
* `protected` â†’ same package + subclasses
* `public` â†’ accessible everywhere
* `default` â†’ same package only
