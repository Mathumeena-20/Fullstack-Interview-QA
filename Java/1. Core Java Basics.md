## 🧩 **1️⃣ What is Java and what are its key features?**

**👉 Answer:**
Java is a **high-level, object-oriented, platform-independent programming language** developed by **Sun Microsystems (now Oracle)**.

**✅ Key Features of Java:**

1. **Platform Independent:** Write Once, Run Anywhere (WORA).
2. **Object-Oriented:** Everything revolves around classes and objects.
3. **Robust:** Strong memory management, exception handling.
4. **Secure:** No pointers, uses JVM sandbox.
5. **Multithreaded:** Supports multiple threads of execution.
6. **Portable:** Same code runs on any platform.
7. **Dynamic:** Classes are loaded dynamically at runtime.
8. **High Performance:** Uses Just-In-Time (JIT) compiler.

**💡 Example:**

```java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, Java!");
    }
}
```

**Explanation:**
The code is compiled into **bytecode**, which runs on any machine with a **Java Virtual Machine (JVM)**.

---

## ⚙️ **2️⃣ Difference between JDK, JRE, and JVM**

| Component | Full Form                | Purpose                                              | Contains                                   |
| --------- | ------------------------ | ---------------------------------------------------- | ------------------------------------------ |
| **JDK**   | Java Development Kit     | Used to **develop**, compile, and run Java programs. | JRE + Development Tools (compiler `javac`) |
| **JRE**   | Java Runtime Environment | Used to **run** Java programs.                       | JVM + Libraries                            |
| **JVM**   | Java Virtual Machine     | Executes the bytecode.                               | Converts bytecode → machine code           |

**💡 Example:**

* You write `Hello.java`
* JDK compiles it → `Hello.class` (bytecode)
* JVM executes the bytecode inside JRE.

---

## 🔠 **3️⃣ What is bytecode?**

**👉 Answer:**
Bytecode is the **intermediate, platform-independent code** generated by the Java compiler (`javac`) after compiling a `.java` file.

The JVM executes this bytecode.

**💡 Example:**

```bash
javac Hello.java   # compiles to Hello.class
java Hello         # JVM executes Hello.class
```

Inside `Hello.class`, bytecode looks like:

```
0: getstatic #2
3: ldc       #3
6: invokevirtual #4
9: return
```

**✅ Benefit:**
You can run the same `.class` file on **Windows, Linux, or Mac** — that’s Java’s **platform independence**.

---

## 🌍 **4️⃣ How Java achieves platform independence?**

**👉 Explanation:**
Java achieves platform independence using **JVM**.

* The **Java compiler** converts source code into **bytecode**.
* **JVM** on each platform (Windows/Linux/Mac) interprets the bytecode into native machine instructions.

**💡 Diagram:**

```
.java → (Compiler) → .class (Bytecode) → (JVM) → Machine Code
```

**✅ Example:**

```java
public class PlatformDemo {
    public static void main(String[] args) {
        System.out.println("Platform Independent!");
    }
}
```

You can run the same `.class` file on any OS that has JVM installed.

---

## 📦 **5️⃣ What are Wrapper Classes?**

**👉 Answer:**
Wrapper classes **convert primitive data types into objects**.
They are part of `java.lang` package.

| Primitive Type | Wrapper Class |
| -------------- | ------------- |
| int            | Integer       |
| double         | Double        |
| boolean        | Boolean       |
| char           | Character     |
| float          | Float         |

**💡 Example:**

```java
int x = 10;
Integer y = Integer.valueOf(x); // wrapping
int z = y.intValue();           // unwrapping
```

**✅ Use Case:**
Needed when working with **Collections** like `ArrayList` (which can store only objects).

---

## 🔁 **6️⃣ What is Autoboxing and Unboxing?**

**👉 Answer:**
Introduced in Java 5, it’s the **automatic conversion** between primitives and wrapper objects.

* **Autoboxing:** Primitive → Wrapper
* **Unboxing:** Wrapper → Primitive

**💡 Example:**

```java
int a = 10;           // primitive
Integer b = a;        // autoboxing
int c = b;            // unboxing
```

**✅ Benefit:**
Reduces boilerplate — no need for `Integer.valueOf()` or `intValue()` explicitly.

---

## ⚖️ **7️⃣ Difference between `==` and `.equals()`**

| Comparison  | Used For             | Behavior                                                         |
| ----------- | -------------------- | ---------------------------------------------------------------- |
| `==`        | Reference Comparison | Checks if two references point to the **same object**            |
| `.equals()` | Value Comparison     | Checks if two objects have **equal content** (can be overridden) |

**💡 Example:**

```java
String s1 = new String("Hello");
String s2 = new String("Hello");

System.out.println(s1 == s2);       // false (different objects)
System.out.println(s1.equals(s2));  // true (same content)
```

**✅ Note:**
For primitives, `==` compares actual values.
For objects, use `.equals()` for value equality.

---

## ⚙️ **8️⃣ What is the purpose of `static` keyword?**

**👉 Explanation:**
`static` means the **member belongs to the class**, not an instance (object).

**💡 Uses of static:**

1. **Static Variable:** Shared across all objects.
2. **Static Method:** Can be called without creating an object.
3. **Static Block:** Executes once when the class is loaded.

**💡 Example:**

```java
class Student {
    static String school = "ABC School";
    String name;

    static void showSchool() {
        System.out.println(school);
    }
}

public class Demo {
    public static void main(String[] args) {
        Student.showSchool(); // static method called without object
    }
}
```

---

## 🧠 **9️⃣ Can we overload `main()` method?**

**👉 Answer:**
✅ Yes, you can **overload** `main()` method,
❌ but **JVM will only call the `main(String[] args)`** method as entry point.

**💡 Example:**

```java
public class MainOverload {
    public static void main(String[] args) {
        System.out.println("Main with String[] args");
        main(5);
    }
    public static void main(int x) {
        System.out.println("Overloaded main: " + x);
    }
}
```

**Output:**

```
Main with String[] args
Overloaded main: 5
```

---

## 🔐 **🔟 What are Access Modifiers in Java?**

**👉 Explanation:**
Access modifiers **control the visibility (scope)** of classes, variables, methods, and constructors.

| Modifier                  | Within Class | Same Package | Subclass (other pkg) | Other Package |
| ------------------------- | ------------ | ------------ | -------------------- | ------------- |
| **private**               | ✅            | ❌            | ❌                    | ❌             |
| **default** (no modifier) | ✅            | ✅            | ❌                    | ❌             |
| **protected**             | ✅            | ✅            | ✅                    | ❌             |
| **public**                | ✅            | ✅            | ✅                    | ✅             |

**💡 Example:**

```java
public class AccessDemo {
    private int a = 10;
    protected int b = 20;
    public int c = 30;
    int d = 40; // default
}
```

**✅ Summary:**

* `private` → only inside the same class
* `protected` → same package + subclasses
* `public` → accessible everywhere
* `default` → same package only
