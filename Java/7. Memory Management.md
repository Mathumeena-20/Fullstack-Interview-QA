## üß† 1. Difference between Heap and Stack Memory

| Feature      | Stack Memory                     | Heap Memory                    |
| ------------ | -------------------------------- | ------------------------------ |
| Stores       | Local variables and method calls | Objects and instance variables |
| Access       | Fast (LIFO)                      | Slower                         |
| Lifetime     | Destroyed after method ends      | Exists until garbage collected |
| Thread Scope | Each thread has its own stack    | Shared among all threads       |
| Example      | Method calls, primitive types    | Objects created using `new`    |

**Example:**

```java
public class MemoryExample {
    int instanceVar = 10;  // Stored in Heap (inside object)

    public void methodA() {
        int localVar = 5;   // Stored in Stack
        MemoryExample obj = new MemoryExample(); // obj in Stack, instanceVar in Heap
    }

    public static void main(String[] args) {
        new MemoryExample().methodA();
    }
}
```

üìå **Summary:**

* **Stack:** Method-level data ‚Üí temporary
* **Heap:** Object-level data ‚Üí persistent (until GC)

---

## üßπ 2. What is Garbage Collection?

**Garbage Collection (GC)** automatically removes unused (unreachable) objects from the heap to free memory.

### ‚úÖ How it works:

* JVM checks for objects **with no references**.
* Such objects become **eligible for garbage collection**.
* GC runs automatically (you can suggest using `System.gc()`).

**Example:**

```java
public class GarbageCollectionDemo {
    public static void main(String[] args) {
        GarbageCollectionDemo obj = new GarbageCollectionDemo();
        obj = null; // No reference ‚Üí eligible for GC

        System.gc(); // Suggest GC (not guaranteed)
    }

    @Override
    protected void finalize() {
        System.out.println("Object is garbage collected");
    }
}
```

**Output (may vary):**

```
Object is garbage collected
```

---

## üß± 3. What are Strong, Weak, and Soft References?

Java provides reference types in `java.lang.ref` package to control **object reachability** for GC.

| Type                  | Behavior                                       | Example Class      |
| --------------------- | ---------------------------------------------- | ------------------ |
| **Strong Reference**  | Default, GC never removes unless out of memory | Normal object      |
| **Soft Reference**    | GC removes only when memory is low             | `SoftReference`    |
| **Weak Reference**    | GC removes as soon as no strong refs exist     | `WeakReference`    |
| **Phantom Reference** | Used for cleanup tasks before GC               | `PhantomReference` |

**Example:**

```java
import java.lang.ref.*;

public class ReferenceDemo {
    public static void main(String[] args) {
        // Strong Reference
        String strong = new String("StrongRef");

        // Soft Reference
        SoftReference<String> soft = new SoftReference<>(new String("SoftRef"));

        // Weak Reference
        WeakReference<String> weak = new WeakReference<>(new String("WeakRef"));

        System.out.println("Before GC: Weak = " + weak.get());
        System.gc();
        System.out.println("After GC: Weak = " + weak.get()); // likely null
    }
}
```

**Output Example:**

```
Before GC: Weak = WeakRef
After GC: Weak = null
```

‚úÖ **Use case:**

* **SoftReference** ‚Üí cache data (kept until memory pressure)
* **WeakReference** ‚Üí avoid memory leaks for listeners, maps, etc.

---

## üß© 4. What is the use of `finalize()` method?

* It‚Äôs a method in `Object` class, called by GC **before destroying an object**.
* You can override it to perform cleanup (close file, release resources).
* But it‚Äôs **deprecated in Java 9+** because it‚Äôs **unreliable and slow**.

**Example:**

```java
public class FinalizeExample {
    @Override
    protected void finalize() {
        System.out.println("Finalize called before object removal");
    }

    public static void main(String[] args) {
        FinalizeExample obj = new FinalizeExample();
        obj = null;
        System.gc(); // suggest GC
    }
}
```

**Output:**

```
Finalize called before object removal
```

‚ö†Ô∏è **Note:** Never rely on `finalize()` for resource management ‚Äî use `try-with-resources` or `finally` block instead.

---

## üí• 5. What is a Memory Leak in Java?

A **memory leak** occurs when objects are no longer needed but still **have references**, preventing GC from reclaiming memory.

**Example:**

```java
import java.util.*;

public class MemoryLeakDemo {
    static List<int[]> memoryLeakList = new ArrayList<>();

    public static void main(String[] args) {
        for (int i = 0; i < 100000; i++) {
            memoryLeakList.add(new int[100000]); // Objects never released
        }
    }
}
```

Here, `memoryLeakList` keeps all object references alive ‚Üí GC cannot clean ‚Üí **OutOfMemoryError**.

‚úÖ **Prevention:**

* Remove unused references.
* Use **WeakReference** for caches.
* Always close **Streams, Connections, ResultSets**.
* Use tools like **VisualVM**, **JConsole**, or **Eclipse MAT** to monitor heap.

---

## üîë 6. Difference between `final`, `finally`, and `finalize()`

| Keyword        | Type     | Purpose                                         |
| -------------- | -------- | ----------------------------------------------- |
| **final**      | Modifier | Prevents modification (variable, method, class) |
| **finally**    | Block    | Executes cleanup code (with try-catch)          |
| **finalize()** | Method   | Called by GC before destroying object           |

**Example:**

```java
public class FinalKeywordsDemo {
    // final variable
    final int value = 100;

    // final method
    final void display() {
        System.out.println("This cannot be overridden");
    }

    public static void main(String[] args) {
        try {
            int x = 10 / 0;
        } catch (ArithmeticException e) {
            System.out.println("Exception handled");
        } finally {
            System.out.println("Finally block always executes");
        }
    }

    @Override
    protected void finalize() {
        System.out.println("Finalize called before GC");
    }
}
```

**Output:**

```
Exception handled
Finally block always executes
Finalize called before GC
```

---

‚úÖ **Summary Table**

| Concept                          | Description                       | Example / Usage    |
| -------------------------------- | --------------------------------- | ------------------ |
| **Heap**                         | Stores objects                    | `new` keyword      |
| **Stack**                        | Stores local variables            | Inside method      |
| **Garbage Collection**           | Auto memory cleanup               | `System.gc()`      |
| **Soft / Weak References**       | GC-friendly references            | Cache, maps        |
| **finalize()**                   | Called before object destruction  | Deprecated         |
| **Memory Leak**                  | Unused but referenced objects     | Big list or map    |
| **final / finally / finalize()** | Modifier / Cleanup block / Method | Different purposes |

