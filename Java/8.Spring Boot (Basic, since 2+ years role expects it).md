## 1Ô∏è‚É£ Difference between Spring and Spring Boot

* **Spring Framework**

  * Provides core features: Dependency Injection (DI), AOP, MVC.
  * Requires lots of configuration (XML or Java-based).

* **Spring Boot**

  * Built on top of Spring.
  * Provides **auto-configuration**, embedded server (Tomcat/Jetty), and starter dependencies.
  * Simplifies development (no XML, minimal config).

üëâ **Interview Tip**:
If asked, say: *"Spring Boot is opinionated and convention over configuration, while Spring needs more manual setup."*

---

## 2Ô∏è‚É£ What is Dependency Injection (DI)?

* **DI = Object dependencies are injected by the Spring container, not manually created.**
* Promotes loose coupling.

üîπ Example:

```java
@Component
class Engine {
    public void start() {
        System.out.println("Engine started!");
    }
}

@Component
class Car {
    private final Engine engine;

    @Autowired
    Car(Engine engine) {  // Constructor Injection
        this.engine = engine;
    }

    public void drive() {
        engine.start();
        System.out.println("Car is moving...");
    }
}
```

üëâ **Best practice**: Prefer **constructor injection** over field injection.

---

## 3Ô∏è‚É£ Common Annotations

* **@Autowired** ‚Üí injects bean automatically.
* **@Component** ‚Üí generic bean.
* **@Service** ‚Üí service layer bean.
* **@Repository** ‚Üí DAO layer bean, adds DB exception translation.

üîπ Example:

```java
@Repository
class UserRepository { }

@Service
class UserService {
    @Autowired
    private UserRepository repo;
}

@Component
class AppRunner implements CommandLineRunner {
    @Autowired
    private UserService userService;
    
    public void run(String... args) {
        System.out.println("App started!");
    }
}
```

üëâ **Tip**: Use `@Qualifier` if multiple beans of the same type exist.

---

## 4Ô∏è‚É£ Spring Bean Lifecycle

1. Bean Instantiation
2. Dependency Injection
3. `@PostConstruct` (custom init method)
4. Bean ready to use
5. `@PreDestroy` (cleanup before shutdown)

üîπ Example:

```java
@Component
class DemoBean {
    @PostConstruct
    public void init() {
        System.out.println("Bean initialized!");
    }

    @PreDestroy
    public void destroy() {
        System.out.println("Bean destroyed!");
    }
}
```

---

## 5Ô∏è‚É£ Singleton vs Prototype Beans

* **Singleton (default)** ‚Üí one instance per Spring container.
* **Prototype** ‚Üí new instance every time requested.

üîπ Example:

```java
@Component
@Scope("singleton")
class SingletonBean { }

@Component
@Scope("prototype")
class PrototypeBean { }
```

üëâ **Interview Tip**: Singleton is cached, prototype isn‚Äôt managed fully (no destroy callbacks).

---

## 6Ô∏è‚É£ Exception Handling in Spring Boot

Use **@ControllerAdvice + @ExceptionHandler**.

üîπ Example:

```java
@ControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(RuntimeException.class)
    public ResponseEntity<String> handleRuntime(RuntimeException ex) {
        return ResponseEntity
                .status(HttpStatus.BAD_REQUEST)
                .body("Error: " + ex.getMessage());
    }
}
```

üëâ **Tip**: For REST APIs, use `@RestControllerAdvice` (sends JSON responses).

---

## 7Ô∏è‚É£ REST Controller vs Controller

* **@Controller** ‚Üí returns **views (JSP/Thymeleaf)**, used in web MVC.
* **@RestController** = `@Controller + @ResponseBody` ‚Üí returns **JSON/XML**.

üîπ Example:

```java
@Controller
class PageController {
    @GetMapping("/home")
    public String homePage() {
        return "home"; // returns view name
    }
}

@RestController
class ApiController {
    @GetMapping("/api/data")
    public String getData() {
        return "Hello API"; // returns JSON
    }
}
```

---

## 8Ô∏è‚É£ Connecting Spring Boot with Database (JPA/Hibernate)

* Add dependency: `spring-boot-starter-data-jpa` + DB driver.
* Configure `application.properties`:

```properties
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=1234
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
```

* Create Entity + Repository:

```java
@Entity
class User {
    @Id
    @GeneratedValue
    private Long id;
    private String name;
}

@Repository
interface UserRepository extends JpaRepository<User, Long> { }
```

* Service + REST API:

```java
@RestController
class UserController {
    @Autowired
    private UserRepository repo;

    @PostMapping("/users")
    public User addUser(@RequestBody User user) {
        return repo.save(user);
    }

    @GetMapping("/users")
    public List<User> getAllUsers() {
        return repo.findAll();
    }
}
```

üëâ **Tip**: Always explain **Spring Boot Auto-Configuration**:
It wires **EntityManager, DataSource, Hibernate** automatically.

---

‚úÖ **Quick Recap Table**

| Topic                  | Key Point                                           | Example/Tip                     |
| ---------------------- | --------------------------------------------------- | ------------------------------- |
| Spring vs Boot         | Boot = Auto-config, embedded server                 | Boot saves boilerplate          |
| DI                     | Container injects dependencies                      | Prefer constructor injection    |
| Annotations            | @Component, @Service, @Repository                   | @Autowired auto wires           |
| Bean Lifecycle         | init ‚Üí use ‚Üí destroy                                | `@PostConstruct`, `@PreDestroy` |
| Singleton vs Prototype | Singleton = 1 instance, Prototype = new per request | Default = singleton             |
| Exception Handling     | @ControllerAdvice + @ExceptionHandler               | REST ‚Üí @RestControllerAdvice    |
| REST vs Controller     | Controller = view, RestController = JSON            | Rest used for APIs              |
| DB Integration         | JPA + Hibernate + Spring Data                       | `JpaRepository<User, Long>`     |

